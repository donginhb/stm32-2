###############################################################################
#                                                                             #
#                                                       08/Jul/2014  15:37:30 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\dri #
#                    vers\pmc\pmc.c                                           #
#    Command line =  "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\dri #
#                    vers\pmc\pmc.c" -D IAR -D TWR_K60N512 -lCN               #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -lB             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -o              #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\" --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config              #
#                    C:\IAR\arm\INC\c\DLib_Config_Normal.h -I                 #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\projects\hello_world\" -I    #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\common\" -I                  #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\" -I                     #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\headers\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\adc16\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\enet\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\pmc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\rtc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\lptmr\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\uart\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\mcg\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\wdog\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\platforms\" -I               #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\ftm\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\SPI\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\OLED\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\" -Ol --use_c++_inline                 #
#    List file    =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\pmc.lst           #
#    Object file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\pmc.o              #
#                                                                             #
#                                                                             #
###############################################################################

E:\完成设计的产品\K60资料\OLED资料 (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\drivers\pmc\pmc.c
      1          /*
      2           * File:        pmc.c
      3           * Purpose:     Provides routines for entering low power modes.
      4           *
      5           * Notes:	Since the wakeup mechanism for low power modes
      6           *              will be application specific, these routines
      7           *              do not include code to setup interrupts to exit
      8           *              from the low power modes. The desired means of
      9           *              low power mode exit should be configured before
     10           *              calling any of these functions.
     11           *
     12           *              These routines do not include protection to
     13           *              prevent illegal state transitions in the mode
     14           *              controller, and all routines that write to the
     15           *              PMPROT register write a value to allow all
     16           *              possible low power modes (it is write once, so
     17           *              if only the currently requested mode is enabled
     18           *              a different mode couldn't be enabled later on).
     19           *              
     20           */
     21          
     22          #include "common.h"
     23          #include "pmc.h"
     24          #include "mcg.h"
     25          #include "uart.h"
     26          extern int core_clk_khz;
     27          extern int core_clk_mhz;
     28          extern int periph_clk_khz;

   \                                 In section .bss, align 4
     29          int i;
   \                     i:
   \   00000000                      DS8 4
     30                 
     31          /********************************************************************/
     32          /* WAIT mode entry routine. Puts the processor into wait mode.
     33           * In this mode the core clock is disabled (no code executing), but 
     34           * bus clocks are enabled (peripheral modules are operational). 
     35           *
     36           * Mode transitions:
     37           * RUN -> WAIT
     38           * VLPR -> VLPW
     39           *
     40           * This function can be used to enter normal wait mode or VLPW
     41           * mode. If you are executing in normal run mode when calling this
     42           * function, then you will enter normal wait mode. If you are in VLPR
     43           * mode when calling this function, then you will enter VLPW mode instead.
     44           *
     45           * NOTE: Some modules include a programmable option to disable them in 
     46           * wait mode. If those modules are programmed to disable in wait mode, 
     47           * they will not be able to generate interrupts to wake up the core.
     48           *
     49           * WAIT mode is exited using any enabled interrupt or RESET, so no
     50           * exit_wait routine is needed. 
     51           *
     52           * If in VLPW mode, the statue of the MC_PMCTRL[LPWUI] bit determines if 
     53           * the processor exits to VLPR (LPWUI cleared) or normal run mode (LPWUI 
     54           * set). The enable_lpwui() and disable_lpwui()functions can be used to set
     55           * this bit to the desired option prior to calling enter_wait().
     56           * 
     57           * 
     58           * Parameters:
     59           * none
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          void enter_wait(void)
     62          {
   \                     enter_wait:
   \   00000000   0xB580             PUSH     {R7,LR}
     63              wait();
   \   00000002   0x.... 0x....      BL       wait
     64          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
     65          /********************************************************************/
     66          /* STOP mode entry routine. Puts the processor into normal stop mode.
     67           * In this mode core, bus and peripheral clocks are disabled.
     68           *
     69           * Mode transitions:
     70           * RUN -> STOP
     71           * VLPR -> VLPS
     72           *
     73           * This function can be used to enter normal stop mode or VLPS
     74           * mode. If you are executing in normal run mode when calling this
     75           * function, then you will enter normal stop mode. If you are in VLPR
     76           * mode when calling this function, then you will enter VLPS mode instead.
     77           *
     78           * STOP mode is exited using any enabled interrupt or RESET, so no
     79           * exit_stop routine is needed.
     80           *
     81           * Parameters:
     82           * none
     83           */

   \                                 In section .text, align 2, keep-with-next
     84          void enter_stop(void)
     85          {
   \                     enter_stop:
   \   00000000   0xB580             PUSH     {R7,LR}
     86              /* Set the LPLLSM field to 0b000 for normal STOP mode - Need to retain state of LPWUI bit 8 */
     87              MC_PMCTRL =  MC_PMCTRL_LPLLSM(0);           // set LPLLSM = 0b000
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4007e003
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     88              stop();
   \   0000000A   0x.... 0x....      BL       stop
     89          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
     90          /********************************************************************/
     91          /* VLPR mode entry routine. Puts the processor into very low power
     92           * run mode. In this mode all clocks are enabled, but the core, bus,
     93           * and peripheral clocks are limited to 2MHz or less. The flash 
     94           * clock is limited to 1MHz or less. 
     95           *
     96           * Mode transitions:
     97           * RUN -> VLPR
     98           *
     99           * exit_vlpr() function or an interrupt with LPWUI set can be used 
    100           * to switch from VLPR back to RUN. The enable_lpwui() and disable_lpwui()
    101           * functions can be used to set LPWUI to the desired option prior to 
    102           * calling enter_vlpr().
    103           *
    104           * Parameters:
    105           * none
    106           */

   \                                 In section .text, align 2, keep-with-next
    107          void enter_vlpr(char lpwui_value)
    108          {
   \                     enter_vlpr:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    109               MC_PMPROT = MC_PMPROT_AVLP_MASK;  // write oneif not all set make sure all enabled
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x4007e002
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    110                                                 //this write-once bit allows the MCU to enter the
    111                                                 //very low power modes: VLPR, VLPW, and VLPS.
    112              
    113             /* Reduce system clock to < 2MHz */
    114              printf("\n\n\n To communicate in VLPR - Auto-Trim must have been done, Change to 19200 baud after key hit !!!! \n\r");
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000010   0x.... 0x....      BL       printf
    115              printf("\r\n Send any character to go into lower divide mode \r\n");
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000018   0x.... 0x....      BL       printf
    116              in_char();
   \   0000001C   0x.... 0x....      BL       in_char
    117          
    118              mcg_pee_2_blpi();
   \   00000020   0x.... 0x....      BL       mcg_pee_2_blpi
    119              SIM_CLKDIV1  =  0x03330000;    //(SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV2(3) \
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40048044
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x3330000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    120                                                 // SIM_CLKDIV1_OUTDIV3(3) | SIM_CLKDIV1_OUTDIV4(3));
    121                                                 //core = 1 bus = /1 flexbus = /1 flash clk =/4
    122           
    123              //change the UART serial baud  rate to 19200 baud
    124              core_clk_khz = 1786;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \   00000032   0xF240 0x61FA      MOVW     R1,#+1786
   \   00000036   0x6001             STR      R1,[R0, #+0]
    125              periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40048044
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   00000052   0x6008             STR      R0,[R1, #+0]
    126              if ((TERM_PORT == UART0_BASE_PTR) | (TERM_PORT == UART1_BASE_PTR))
    127                  uart_init (TERM_PORT, core_clk_khz, TERMINAL_BAUD);
    128              else
    129                  uart_init (TERM_PORT, periph_clk_khz, TERMINAL_BAUD);
   \   00000054   0xF44F 0x4216      MOV      R2,#+38400
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x4006d000
   \   00000062   0x.... 0x....      BL       uart_init
    130              // ~1.78MHz
    131          
    132              printf("\r\n Send any character to go into low power mode \r\n");
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000006A   0x.... 0x....      BL       printf
    133              in_char();
   \   0000006E   0x.... 0x....      BL       in_char
    134          
    135               /* Set the RUNM field to 0b10 for VLPR mode - Need to retain state of LPWUI bit 8 */
    136              /* Set the LPLLSM field to 0b010 for VLPS mode - Need to set state of LPWUI bit 8 */
    137              if(lpwui_value){
   \   00000072   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD004             BEQ.N    ??enter_vlpr_0
    138                 MC_PMCTRL = (MC_PMCTRL_LPWUI_MASK       // set LPWUI
    139                              | MC_PMCTRL_RUNM(2));       // set RUNM = 0b10     
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4007e003
   \   0000007C   0x21C0             MOVS     R1,#+192
   \   0000007E   0x7001             STRB     R1,[R0, #+0]
   \   00000080   0xE003             B.N      ??enter_vlpr_1
    140             
    141               } else {
    142                 MC_PMCTRL = (!MC_PMCTRL_LPWUI_MASK            // clear LPWUI
    143                             | MC_PMCTRL_RUNM(2));             // set RUNM = 0b10 
   \                     ??enter_vlpr_0:
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4007e003
   \   00000086   0x2140             MOVS     R1,#+64
   \   00000088   0x7001             STRB     R1,[R0, #+0]
    144               }       
    145                  
    146              
    147                /* Wait for VLPS regulator mode to be confirmed */
    148          
    149               while((PMC_REGSC & PMC_REGSC_VLPRS_MASK)==0);    // 0 MCU is not in VLPR mode
   \                     ??enter_vlpr_1:
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable13_10  ;; 0x4007d002
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x0700             LSLS     R0,R0,#+28
   \   00000092   0xD5FA             BPL.N    ??enter_vlpr_1
    150                                                             // 1 MCU is in VLPR mode
    151               for (i= 0;i<0xffff;i++){
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable13_11
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x6001             STR      R1,[R0, #+0]
   \   0000009C   0xE006             B.N      ??enter_vlpr_2
   \                     ??enter_vlpr_3:
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable13_11
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable13_11
   \   000000AA   0x6008             STR      R0,[R1, #+0]
   \                     ??enter_vlpr_2:
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable13_11
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xDA07             BGE.N    ??enter_vlpr_4
    152           //          printf(" Now in VLPR at 19200 baud  \r\n");
    153                     printf("U");
   \   000000BA   0x....             ADR.N    R0,??DataTable11  ;; "U"
   \   000000BC   0x.... 0x....      BL       printf
    154                        if ((UART_S1_REG(TERM_PORT) & UART_S1_RDRF_MASK)) {
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable13_12  ;; 0x4006d004
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x0680             LSLS     R0,R0,#+26
   \   000000C8   0xD5E9             BPL.N    ??enter_vlpr_3
    155                           break;
    156                        }//if char received  */
    157               }//for
    158          
    159          }
   \                     ??enter_vlpr_4:
   \   000000CA   0xBD10             POP      {R4,PC}          ;; return
    160          /********************************************************************/
    161          /* VLPR mode exit routine. Puts the processor into normal run mode
    162           * from VLPR mode. You can transition from VLPR to normal run using
    163           * this function or an interrupt with LPWUI set. The enable_lpwui() 
    164           * and disable_lpwui() functions can be used to set LPWUI to the 
    165           * desired option prior to calling enter_vlpr().
    166           *
    167           * Mode transitions:
    168           * VLPR -> RUN
    169           *
    170           * Parameters:
    171           * none
    172           */

   \                                 In section .text, align 2, keep-with-next
    173          void exit_vlpr(void)
    174          {
   \                     exit_vlpr:
   \   00000000   0xB580             PUSH     {R7,LR}
    175              /* Clear RUNM */
    176              MC_PMCTRL &= ~(MC_PMCTRL_RUNM(0x3));
   \   00000002   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x009F      ANDS     R0,R0,#0x9F
   \   0000000A   0x....             LDR.N    R1,??DataTable13  ;; 0x4007e003
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    177                             
    178              /* Wait for normal RUN regulation mode to be confirmed */                   
    179              while (PMC_REGSC & PMC_REGSC_VLPRS_MASK); // 0 MCU is not in VLPR mode
   \                     ??exit_vlpr_0:
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable13_10  ;; 0x4007d002
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD4FA             BMI.N    ??exit_vlpr_0
    180                                                        // 1 MCU is in VLPR mode
    181              while(!(PMC_REGSC & PMC_REGSC_REGONS_MASK)); 
   \                     ??exit_vlpr_1:
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13_10  ;; 0x4007d002
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x0740             LSLS     R0,R0,#+29
   \   00000020   0xD5FA             BPL.N    ??exit_vlpr_1
    182              
    183              /* Transition MCG back to the PLL enabled state */
    184              mcg_blpi_2_pee();
   \   00000022   0x.... 0x....      BL       mcg_blpi_2_pee
    185              //sim_clkdivided back to default
    186              SIM_CLKDIV1 = 0x00010000;   //(SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV2(3) \
   \   00000026   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40048044
   \   00000028   0xF45F 0x3180      MOVS     R1,#+65536
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    187                                          // SIM_CLKDIV1_OUTDIV3(3) | SIM_CLKDIV1_OUTDIV4(3));
    188                                          //core = /1 bus = /1 =flex bus /2 flash clk /2
    189              core_clk_khz = core_clk_mhz * 1000;
   \   0000002E   0x....             LDR.N    R0,??DataTable13_13
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF44F 0x717A      MOV      R1,#+1000
   \   00000036   0x4348             MULS     R0,R1,R0
   \   00000038   0x....             LDR.N    R1,??DataTable13_6
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    190              periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
   \   0000003C   0x....             LDR.N    R0,??DataTable13_6
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40048044
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004E   0x....             LDR.N    R1,??DataTable13_7
   \   00000050   0x6008             STR      R0,[R1, #+0]
    191              if ((TERM_PORT == UART3_BASE_PTR) | (TERM_PORT == UART1_BASE_PTR))
    192                   uart_init (TERM_PORT, core_clk_khz, TERMINAL_BAUD);
   \   00000052   0xF44F 0x4216      MOV      R2,#+38400
   \   00000056   0x....             LDR.N    R0,??DataTable13_6
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0x....             LDR.N    R0,??DataTable13_8  ;; 0x4006d000
   \   0000005C   0x.... 0x....      BL       uart_init
    193              else
    194                   uart_init (TERM_PORT, periph_clk_khz, TERMINAL_BAUD);
    195              
    196              printf("               Now in Run Mode at 115200 baud \r");
   \   00000060   0x....             LDR.N    R0,??DataTable13_14
   \   00000062   0x.... 0x....      BL       printf
    197          
    198          }
   \   00000066   0xBD01             POP      {R0,PC}          ;; return
    199          /********************************************************************/
    200          /* VLPS mode entry routine. Puts the processor into VLPS mode directly
    201           * from normal run mode. 
    202           *
    203           * Mode transitions:
    204           * RUN -> VLPS
    205           *
    206           * If VLPS mode is entered directly from normal RUN mode, then the 
    207           * LPWUI bit is forced to 1 by hardware. This means that when an
    208           * interrupt occurs you will exit to normal run mode instead of VLPR.
    209           *
    210           * If however VLPS mode is entered from VLPR the state of the LPWUI bit
    211           * determines the state the MCU will return to upon exit from VLPS.If LPWUI is set
    212           * and an interrupt occurs you will exit to normal run mode instead of VLPR. 
    213           * If LPWUI is clear and an interrupt occurs you will exit to VLPR.
    214           *
    215           * Parameters:  value of LPWUI
    216           * none
    217           */

   \                                 In section .text, align 2, keep-with-next
    218          void enter_vlps(char lpwui_value)
    219          {
   \                     enter_vlps:
   \   00000000   0xB580             PUSH     {R7,LR}
    220              /* Write to PMPROT to allow VLPS power modes */
    221              MC_PMPROT = MC_PMPROT_AVLP_MASK;   // write oneif not all set make sure all enabled
   \   00000002   0x....             LDR.N    R1,??DataTable13_1  ;; 0x4007e002
   \   00000004   0x2220             MOVS     R2,#+32
   \   00000006   0x700A             STRB     R2,[R1, #+0]
    222                                                 //this write-once bit allows the MCU to enter the
    223                                                 //very low power modes: VLPR, VLPW, and VLPS.
    224           
    225              /* Reduce system clock to < 2MHz */
    226           //   mcg_pee_2_blpi();    // you don't need to chage to lower frequency for VLPS
    227                 
    228              /* Set the LPLLSM field to 0b010 for VLPS mode - Need to set state of LPWUI bit 8 */
    229              if(lpwui_value){
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??enter_vlps_0
    230                 MC_PMCTRL = (MC_PMCTRL_LPWUI_MASK            // set LPWUI
    231                            | MC_PMCTRL_LPLLSM(2));           // set LPLLSM = 0b10
   \   0000000E   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000010   0x2182             MOVS     R1,#+130
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0xE002             B.N      ??enter_vlps_1
    232               } else {
    233                 MC_PMCTRL = (!MC_PMCTRL_LPWUI_MASK           // set LPWUI
    234                            | MC_PMCTRL_LPLLSM(2));           // set LPLLSM = 0b10
   \                     ??enter_vlps_0:
   \   00000016   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    235               }       
    236              /* Now execute the stop instruction to go into VLPS */
    237              stop();
   \                     ??enter_vlps_1:
   \   0000001C   0x.... 0x....      BL       stop
    238          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    239          /********************************************************************/
    240          /* LLS mode entry routine. Puts the processor into LLS mode from
    241           * normal run mode or VLPR. 
    242           *
    243           * Mode transitions:
    244           * RUN -> LLS
    245           * VLPR -> LLS
    246           *
    247           * NOTE: LLS mode will always exit to RUN mode even if you were 
    248           * in VLPR mode before entering LLS.
    249           *
    250           * Wakeup from LLS mode is controlled by the LLWU module. Most
    251           * modules cannot issue a wakeup interrupt in LLS mode, so make
    252           * sure to setup the desired wakeup sources in the LLWU before 
    253           * calling this function.
    254           *
    255           * Parameters:
    256           * none
    257           */

   \                                 In section .text, align 2, keep-with-next
    258          void enter_lls(void)
    259          {
   \                     enter_lls:
   \   00000000   0xB580             PUSH     {R7,LR}
    260              /* Write to PMPROT to allow LLS power modes */
    261              MC_PMPROT = MC_PMPROT_ALLS_MASK;   //this write-once bit allows the MCU to enter the
   \   00000002   0x....             LDR.N    R0,??DataTable13_1  ;; 0x4007e002
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    262                                                 //LLS low power mode
    263          
    264                  
    265              /* Set the LPLLSM field to 0b011 for LLS mode  */
    266              MC_PMCTRL  =  MC_PMCTRL_LPLLSM(3);           // set LPLLSM = 0b11
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    267                  
    268              /* Now execute the stop instruction to go into LLS */
    269              stop();
   \   0000000E   0x.... 0x....      BL       stop
    270          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    271          /********************************************************************/
    272          /* VLLS3 mode entry routine. Puts the processor into VLLS3 mode from
    273           * normal run mode or VLPR. 
    274           *
    275           * Mode transitions:
    276           * RUN -> VLLS3
    277           * VLPR -> VLLS3
    278           *
    279           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    280           * in VLPR mode before entering VLLSx.
    281           *
    282           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    283           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    284           * sure to setup the desired wakeup sources in the LLWU before 
    285           * calling this function.
    286           *
    287           * Parameters:
    288           * none  
    289           */

   \                                 In section .text, align 2, keep-with-next
    290          void enter_vlls3(void)
    291          {
   \                     enter_vlls3:
   \   00000000   0xB580             PUSH     {R7,LR}
    292              /* Write to PMPROT to allow VLLS3 power modes */
    293              MC_PMPROT = MC_PMPROT_AVLLS3_MASK;
   \   00000002   0x....             LDR.N    R0,??DataTable13_1  ;; 0x4007e002
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    294                  
    295              /* Set the LPLLSM field to 0b101 for VLLS3 mode  */
    296              MC_PMCTRL =  MC_PMCTRL_LPLLSM(5);           // set LPLLSM = 0b101
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   0000000A   0x2105             MOVS     R1,#+5
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    297              disable_ports();    
   \   0000000E   0x.... 0x....      BL       disable_ports
    298              /* Now execute the stop instruction to go into VLLS3 */
    299              stop();
   \   00000012   0x.... 0x....      BL       stop
    300          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    301          /********************************************************************/
    302          /* VLLS2 mode entry routine. Puts the processor into VLLS2 mode from
    303           * normal run mode or VLPR. 
    304           *
    305           * Mode transitions:
    306           * RUN -> VLLS2
    307           * VLPR -> VLLS2
    308           *
    309           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    310           * in VLPR mode before entering VLLSx.
    311           *
    312           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    313           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    314           * sure to setup the desired wakeup sources in the LLWU before 
    315           * calling this function.
    316           *
    317           * Parameters:
    318           * none  
    319           */

   \                                 In section .text, align 2, keep-with-next
    320          void enter_vlls2(void)
    321          {
   \                     enter_vlls2:
   \   00000000   0xB580             PUSH     {R7,LR}
    322              /* Write to PMPROT to allow VLLS2 power modes */
    323              MC_PMPROT = MC_PMPROT_AVLLS2_MASK;
   \   00000002   0x....             LDR.N    R0,??DataTable13_1  ;; 0x4007e002
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    324                  
    325              /* Set the LPLLSM field to 0b110 for VLLS2 mode */
    326              MC_PMCTRL =  MC_PMCTRL_LPLLSM(6);           // set LPLLSM = 0b110
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   0000000A   0x2106             MOVS     R1,#+6
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    327              disable_ports();    
   \   0000000E   0x.... 0x....      BL       disable_ports
    328                  
    329              /* Now execute the stop instruction to go into VLLS2 */
    330              stop();
   \   00000012   0x.... 0x....      BL       stop
    331          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    332          /********************************************************************/
    333          /* VLLS1 mode entry routine. Puts the processor into VLLS1 mode from
    334           * normal run mode or VLPR. 
    335           *
    336           * Mode transitions:
    337           * RUN -> VLLS1
    338           * VLPR -> VLLS1
    339           *
    340           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    341           * in VLPR mode before entering VLLSx.
    342           *
    343           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    344           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    345           * sure to setup the desired wakeup sources in the LLWU before 
    346           * calling this function.
    347           *
    348           * Parameters:
    349           * none  
    350           */

   \                                 In section .text, align 2, keep-with-next
    351          void enter_vlls1(void)
    352          {
   \                     enter_vlls1:
   \   00000000   0xB580             PUSH     {R7,LR}
    353              /* Write to PMPROT to allow all possible power modes */
    354              MC_PMPROT = MC_PMPROT_AVLLS1_MASK;
   \   00000002   0x....             LDR.N    R0,??DataTable13_1  ;; 0x4007e002
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    355                  
    356              /* Set the LPLLSM field to 0b111 for VLLS1 mode  */
    357              MC_PMCTRL =  MC_PMCTRL_LPLLSM(7);           // set LPLLSM = 0b111
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   0000000A   0x2107             MOVS     R1,#+7
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    358              disable_ports();    
   \   0000000E   0x.... 0x....      BL       disable_ports
    359                  
    360              /* Now execute the stop instruction to go into VLLS1 */
    361              stop();
   \   00000012   0x.... 0x....      BL       stop
    362          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    363          /********************************************************************/
    364          /* Enable low power wake up on interrupt. This function can be used
    365           * to set the LPWUI bit. When this bit is set VLPx modes will exit
    366           * to normal run mode. When this bit is cleared VLPx modes will exit
    367           * to VLPR mode.
    368           *
    369           * The disable_lpwui() function can be used to clear the LPWUI bit.
    370           *
    371           * Parameters:
    372           * none
    373           */
    374          
    375             
    376          

   \                                 In section .text, align 2, keep-with-next
    377          void enable_lpwui(void)
    378          {
    379              MC_PMCTRL |= MC_PMCTRL_LPWUI_MASK;
   \                     enable_lpwui:
   \   00000000   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000008   0x....             LDR.N    R1,??DataTable13  ;; 0x4007e003
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    380          }
   \   0000000C   0x4770             BX       LR               ;; return
    381          /********************************************************************/
    382          /* Disable low power wake up on interrupt. This function can be used
    383           * to clear the LPWUI bit. When this bit is set VLPx modes will exit
    384           * to normal run mode. When this bit is cleared VLPx modes will exit
    385           * to VLPR mode.
    386           *
    387           * The enable_lpwui() function can be used to set the LPWUI bit.
    388           *
    389           * Parameters:
    390           * none
    391           */

   \                                 In section .text, align 2, keep-with-next
    392          void disable_lpwui(void)
    393          {
    394              MC_PMCTRL &= ~MC_PMCTRL_LPWUI_MASK;
   \                     disable_lpwui:
   \   00000000   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000008   0x....             LDR.N    R1,??DataTable13  ;; 0x4007e003
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    395          }
   \   0000000C   0x4770             BX       LR               ;; return
    396          /********************************************************************/
    397             /* entry mode variable is set to one of the valid settings following
    398              000 Normal stop
    399              001 Reserved
    400              010 Very low power stop (VLPS)
    401              011 Low leakage stop (LLS)
    402              100 Reserved
    403              101 Very low leakage stop 3 (VLLS3)
    404              110 Very low leakage stop 2 (VLLS2)
    405              111 Very low leakage stop 1 (VLLS1)
    406             */
    407          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          void enter_stop_mode(char mode)
    409          {
   \                     enter_stop_mode:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    410              printf("\n-------------------------------------\n");
   \   00000004   0x....             LDR.N    R0,??DataTable13_15
   \   00000006   0x.... 0x....      BL       printf
    411              printf("  MC_Enter Low Power Modes Utility    \n");
   \   0000000A   0x....             LDR.N    R0,??DataTable13_16
   \   0000000C   0x.... 0x....      BL       printf
    412              printf("--------------------------------------\n");
   \   00000010   0x....             LDR.N    R0,??DataTable13_17
   \   00000012   0x.... 0x....      BL       printf
    413              
    414              MC_PMPROT = 0x37;               //This value enables all possible power modes.
   \   00000016   0x....             LDR.N    R0,??DataTable13_1  ;; 0x4007e002
   \   00000018   0x2137             MOVS     R1,#+55
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    415           
    416              MC_PMCTRL = MC_PMCTRL_LPWUI_MASK | MC_PMCTRL_LPLLSM(mode) ;  
   \   0000001C   0xF014 0x0007      ANDS     R0,R4,#0x7
   \   00000020   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000024   0x....             LDR.N    R1,??DataTable13  ;; 0x4007e003
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    417              stop();         
   \   00000028   0x.... 0x....      BL       stop
    418          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    419          

   \                                 In section .text, align 2, keep-with-next
    420          void     disable_ports(void){
    421          #if (defined(TWR_K60N512))
    422             PORTE_PCR26 = PORT_PCR_IRQC(00);;
   \                     disable_ports:
   \   00000000   0x....             LDR.N    R0,??DataTable13_18  ;; 0x4004d068
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    423             PORTA_PCR19 = PORT_PCR_IRQC(00);
   \   00000006   0x....             LDR.N    R0,??DataTable13_19  ;; 0x4004904c
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    424             #endif
    425            
    426          #if (defined(TWR_K40X256))
    427             //  SW6 and SW7
    428               PORTC_PCR5  = PORT_PCR_IRQC(00);
    429               PORTC_PCR13  = PORT_PCR_IRQC(00);
    430          #endif
    431               
    432             // disable trace clock output
    433               PORTA_PCR6 = ( PORT_PCR_MUX(0x0));
   \   0000000C   0x....             LDR.N    R0,??DataTable13_20  ;; 0x40049018
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6001             STR      R1,[R0, #+0]
    434             // disable JTAG i/o PTA0-3 5
    435               PORTA_PCR0 = ( PORT_PCR_MUX(0x0));
   \   00000012   0x....             LDR.N    R0,??DataTable13_21  ;; 0x40049000
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6001             STR      R1,[R0, #+0]
    436               PORTA_PCR1 = ( PORT_PCR_MUX(0x0));
   \   00000018   0x....             LDR.N    R0,??DataTable13_22  ;; 0x40049004
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    437               PORTA_PCR2 = ( PORT_PCR_MUX(0x0));
   \   0000001E   0x....             LDR.N    R0,??DataTable13_23  ;; 0x40049008
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6001             STR      R1,[R0, #+0]
    438               PORTA_PCR3 = ( PORT_PCR_MUX(0x0));
   \   00000024   0x....             LDR.N    R0,??DataTable13_24  ;; 0x4004900c
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x6001             STR      R1,[R0, #+0]
    439               PORTA_PCR5 = ( PORT_PCR_MUX(0x0));
   \   0000002A   0x....             LDR.N    R0,??DataTable13_25  ;; 0x40049014
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    440          
    441             // disable fb_clk output
    442               PORTC_PCR3 = ( PORT_PCR_MUX(0x0));
   \   00000030   0x....             LDR.N    R0,??DataTable13_26  ;; 0x4004b00c
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6001             STR      R1,[R0, #+0]
    443           	/* Disable the pins for the selected UART */
    444               if (TERM_PORT == UART0_BASE_PTR)
    445                   {
    446                      /* Disable the UART0_TXD function on PTD6 */
    447                      PORTD_PCR6 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    448          
    449                      /* Disable the UART0_RXD function on PTD7 */
    450                      PORTD_PCR7 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    451                   }
    452          
    453               if (TERM_PORT == UART1_BASE_PTR)
    454            	 {
    455                           /* Disable the UART1_TXD function on PTC4 */
    456            		PORTC_PCR4 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    457          
    458            		/* Enable the UART1_RXD function on PTC3 */
    459            		PORTC_PCR3 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    460            	}
    461          
    462              if (TERM_PORT == UART2_BASE_PTR)
    463            	{
    464                           /* Disable the UART2_TXD function on PTD3 */
    465            		PORTD_PCR3 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    466          
    467            		/* Disable the UART2_RXD function on PTD2 */
    468            		PORTD_PCR2 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    469            	}
    470          
    471              if (TERM_PORT == UART3_BASE_PTR)
    472            	{
    473                           /* Disable the UART3_TXD function on PTC17 */
    474            		PORTC_PCR17 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
   \   00000036   0x....             LDR.N    R0,??DataTable13_27  ;; 0x4004b044
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    475          
    476            		/* Enable the UART3_RXD function on PTC16 */
    477            		PORTC_PCR16 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
   \   0000003C   0x....             LDR.N    R0,??DataTable13_28  ;; 0x4004b040
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6001             STR      R1,[R0, #+0]
    478            	}
    479              if (TERM_PORT == UART4_BASE_PTR)
    480            	{
    481                           /* Disable the UART3_TXD function on PTC17 */
    482            		PORTE_PCR24 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    483          
    484            		/* Disable the UART3_RXD function on PTC16 */
    485            		PORTE_PCR25 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    486            	}
    487              if (TERM_PORT == UART5_BASE_PTR)
    488            	{
    489                           /* Disable the UART3_TXD function on PTC17 */
    490            		PORTE_PCR8 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    491          
    492            		/* Disable the UART3_RXD function on PTC16 */
    493            		PORTE_PCR9 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    494            	}
    495            // disable clock gating
    496            SIM_SCGC1 = 0;
   \   00000042   0x....             LDR.N    R0,??DataTable13_29  ;; 0x40048028
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6001             STR      R1,[R0, #+0]
    497            SIM_SCGC2 = 0;
   \   00000048   0x....             LDR.N    R0,??DataTable13_30  ;; 0x4004802c
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    498            SIM_SCGC3 = 0;
   \   0000004E   0x....             LDR.N    R0,??DataTable13_31  ;; 0x40048030
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x6001             STR      R1,[R0, #+0]
    499            SIM_SCGC4 = 0;
   \   00000054   0x....             LDR.N    R0,??DataTable13_32  ;; 0x40048034
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6001             STR      R1,[R0, #+0]
    500            SIM_SCGC5 = 0;
   \   0000005A   0x....             LDR.N    R0,??DataTable13_33  ;; 0x40048038
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    501            SIM_SCGC6 = 0;
   \   00000060   0x....             LDR.N    R0,??DataTable13_34  ;; 0x4004803c
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6001             STR      R1,[R0, #+0]
    502            SIM_SCGC7 = 0;
   \   00000066   0x....             LDR.N    R0,??DataTable13_35  ;; 0x40048040
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    503          
    504          }
   \   0000006C   0x4770             BX       LR               ;; return
    505          
    506          //AJJ

   \                                 In section .text, align 2, keep-with-next
    507          void     disable_ports_partial(void){
    508          /*
    509          #if (defined(TWR_K60N512))
    510             PORTE_PCR26 = PORT_PCR_IRQC(00);;
    511             PORTA_PCR19 = PORT_PCR_IRQC(00);
    512             #endif
    513            
    514          #if (defined(TWR_K40X256))
    515             //  SW6 and SW7
    516               PORTC_PCR5  = PORT_PCR_IRQC(00);
    517               PORTC_PCR13  = PORT_PCR_IRQC(00);
    518          #endif
    519          */    
    520             // disable trace clock output
    521               PORTA_PCR6 = ( PORT_PCR_MUX(0x0));
   \                     disable_ports_partial:
   \   00000000   0x....             LDR.N    R0,??DataTable13_20  ;; 0x40049018
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    522             // disable JTAG i/o PTA0-3 5
    523               PORTA_PCR0 = ( PORT_PCR_MUX(0x0));
   \   00000006   0x....             LDR.N    R0,??DataTable13_21  ;; 0x40049000
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    524               PORTA_PCR1 = ( PORT_PCR_MUX(0x0));
   \   0000000C   0x....             LDR.N    R0,??DataTable13_22  ;; 0x40049004
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6001             STR      R1,[R0, #+0]
    525               PORTA_PCR2 = ( PORT_PCR_MUX(0x0));
   \   00000012   0x....             LDR.N    R0,??DataTable13_23  ;; 0x40049008
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6001             STR      R1,[R0, #+0]
    526               PORTA_PCR3 = ( PORT_PCR_MUX(0x0));
   \   00000018   0x....             LDR.N    R0,??DataTable13_24  ;; 0x4004900c
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    527               PORTA_PCR5 = ( PORT_PCR_MUX(0x0));
   \   0000001E   0x....             LDR.N    R0,??DataTable13_25  ;; 0x40049014
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6001             STR      R1,[R0, #+0]
    528          /*
    529             // disable fb_clk output
    530               PORTC_PCR3 = ( PORT_PCR_MUX(0x0));
    531           	// Disable the pins for the selected UART 
    532               if (TERM_PORT == UART0_BASE_PTR)
    533                   {
    534                      // Disable the UART0_TXD function on PTD6 
    535                      PORTD_PCR6 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    536          
    537                      // Disable the UART0_RXD function on PTD7 
    538                      PORTD_PCR7 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    539                   }
    540          
    541               if (TERM_PORT == UART1_BASE_PTR)
    542            	 {
    543                           // Disable the UART1_TXD function on PTC4 
    544            		PORTC_PCR4 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    545          
    546            		// Enable the UART1_RXD function on PTC3 
    547            		PORTC_PCR3 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    548            	}
    549          
    550              if (TERM_PORT == UART2_BASE_PTR)
    551            	{
    552                           // Disable the UART2_TXD function on PTD3 
    553            		PORTD_PCR3 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    554          
    555            		// Disable the UART2_RXD function on PTD2 
    556            		PORTD_PCR2 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    557            	}
    558          
    559              if (TERM_PORT == UART3_BASE_PTR)
    560            	{
    561                           // Disable the UART3_TXD function on PTC17 
    562            		PORTC_PCR17 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    563          
    564            		// Enable the UART3_RXD function on PTC16 
    565            		PORTC_PCR16 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    566            	}
    567              if (TERM_PORT == UART4_BASE_PTR)
    568            	{
    569                           // Disable the UART3_TXD function on PTC17 
    570            		PORTE_PCR24 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    571          
    572            		// Disable the UART3_RXD function on PTC16 
    573            		PORTE_PCR25 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    574            	}
    575              if (TERM_PORT == UART5_BASE_PTR)
    576            	{
    577                           // Disable the UART3_TXD function on PTC17 
    578            		PORTE_PCR8 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    579          
    580            		// Disable the UART3_RXD function on PTC16 
    581            		PORTE_PCR9 = PORT_PCR_MUX(0x0); // UART is alt3 function for this pin
    582            	}
    583          */
    584          
    585               // disable clock gating
    586            //SIM_SCGC1 = 0;  //uart 4 & 5
    587            //SIM_SCGC2 = 0;  //DAC 0 & 1, ENET
    588          //  SIM_SCGC3 = 0;  //ADC1(27), FTM2(24), SDHC(17), SPI2(12), FLEXCAN1(4), RNGB(0)
    589          
    590          //  printf("SIM_SCGC4 is %08x \n\r\n", SIM_SCGC4);
    591          //  printf("SIM_SCGC4 is %08x \n\r\n", SIM_SCGC4);
    592          
    593            SIM_SCGC4 = SIM_SCGC4 & 0x70102030;  //LLWU(28), VREF(20), CMP(19), USBOTG(18), UART3 - 0(13-10), 
   \   00000024   0x....             LDR.N    R0,??DataTable13_32  ;; 0x40048034
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x....             LDR.N    R1,??DataTable13_36  ;; 0x70102030
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0x....             LDR.N    R1,??DataTable13_32  ;; 0x40048034
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    594                            //I2C1(7), I2C0(6), CMT(2), EWM(1)   VREF defaults to 1
    595          //  printf("SIM_SCGC4 is %08x \n\r\n", SIM_SCGC4);
    596          //  while(!(UART3_S1&UART_S1_TC_MASK));  //make sure uart buffer is empty before exiting
    597          
    598          
    599            //SIM_SCGC5 = 0;  //PortE - A(13-9), TSI(5), REGFILE(1), LPTIMER(0)
    600            //SIM_SCGC6 = 0;  //RTC(29), ADC0(27), FTM1(25), FTM0(24), PIT(23), PDB(22), USBDCD(21), CRC(18), 
    601                            //I2S(15), SPI1(13), DSPI0(12), FLEXCAN0(4), DMAMUX(1), FTFL(0)
    602            SIM_SCGC7 = 0x00000000;  //MPU(2), DMA(1), FLEXBUS(0)
   \   00000030   0x....             LDR.N    R0,??DataTable13_35  ;; 0x40048040
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6001             STR      R1,[R0, #+0]
    603          
    604          
    605          }
   \   00000036   0x4770             BX       LR               ;; return
    606          

   \                                 In section .text, align 2, keep-with-next
    607          void outSRS(void){                         //[outSRS]
   \                     outSRS:
   \   00000000   0xB580             PUSH     {R7,LR}
    608            if (MC_SRSH & MC_SRSH_SW_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable13_37  ;; 0x4007e000
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0740             LSLS     R0,R0,#+29
   \   00000008   0xD502             BPL.N    ??outSRS_0
    609          		printf("[outSRS]Software Reset\n");
   \   0000000A   0x....             LDR.N    R0,??DataTable13_38
   \   0000000C   0x.... 0x....      BL       printf
    610          	if (MC_SRSH & MC_SRSH_LOCKUP_MASK)
   \                     ??outSRS_0:
   \   00000010   0x....             LDR.N    R0,??DataTable13_37  ;; 0x4007e000
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD502             BPL.N    ??outSRS_1
    611          		printf("[outSRS]Core Lockup Event Reset\n");
   \   00000018   0x....             LDR.N    R0,??DataTable13_39
   \   0000001A   0x.... 0x....      BL       printf
    612          	if (MC_SRSH & MC_SRSH_JTAG_MASK)
   \                     ??outSRS_1:
   \   0000001E   0x....             LDR.N    R0,??DataTable13_37  ;; 0x4007e000
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD502             BPL.N    ??outSRS_2
    613          		printf("[outSRS]JTAG Reset\n");
   \   00000026   0x....             LDR.N    R0,??DataTable13_40
   \   00000028   0x.... 0x....      BL       printf
    614          	
    615          	if (MC_SRSL & MC_SRSL_POR_MASK)
   \                     ??outSRS_2:
   \   0000002C   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x0600             LSLS     R0,R0,#+24
   \   00000032   0xD502             BPL.N    ??outSRS_3
    616          		printf("[outSRS]Power-on Reset\n");
   \   00000034   0x....             LDR.N    R0,??DataTable13_42
   \   00000036   0x.... 0x....      BL       printf
    617          	if (MC_SRSL & MC_SRSL_PIN_MASK){
   \                     ??outSRS_3:
   \   0000003A   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x0640             LSLS     R0,R0,#+25
   \   00000040   0xD502             BPL.N    ??outSRS_4
    618          	    // find out which mode we are wakeing up from
    619                    printf("External Pin Reset\n");
   \   00000042   0x....             LDR.N    R0,??DataTable13_43
   \   00000044   0x.... 0x....      BL       printf
    620          	}
    621          	if (MC_SRSL & MC_SRSL_WAKEUP_MASK){
   \                     ??outSRS_4:
   \   00000048   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x07C0             LSLS     R0,R0,#+31
   \   0000004E   0xD548             BPL.N    ??outSRS_5
    622          	     printf("[outSRS]Pin Reset wakeup from low power modes\n");
   \   00000050   0x....             LDR.N    R0,??DataTable13_44
   \   00000052   0x.... 0x....      BL       printf
    623                 //The state of PMCTRL[LPLLSM] prior to clearing due to update 
    624                 // of PMPROT indicates which power mode was exited and should be 
    625                 // used by initialization software for proper power mode recovery.
    626                    if ((MC_PMCTRL & MC_PMCTRL_LPLLSM_MASK) == 0)
   \   00000056   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2107             MOVS     R1,#+7
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD102             BNE.N    ??outSRS_6
    627                       printf("[outSRS]Pin Reset wakeup from Normal Stop\n");
   \   00000060   0x....             LDR.N    R0,??DataTable13_45
   \   00000062   0x.... 0x....      BL       printf
    628          	        if ((MC_PMCTRL & MC_PMCTRL_LPLLSM_MASK) == 2)
   \                     ??outSRS_6:
   \   00000066   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0xD102             BNE.N    ??outSRS_7
    629          		         printf("[outSRS]Pin Reset wakeup from Very Low Power Stop(VLPS)\n");
   \   00000074   0x....             LDR.N    R0,??DataTable13_46
   \   00000076   0x.... 0x....      BL       printf
    630          		      if ((MC_PMCTRL & MC_PMCTRL_LPLLSM_MASK) == 3)
   \                     ??outSRS_7:
   \   0000007A   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD102             BNE.N    ??outSRS_8
    631          		         printf("[outSRS]Pin Reset wakeup from Low Leakage Stop (LLS)\n");
   \   00000088   0x....             LDR.N    R0,??DataTable13_47
   \   0000008A   0x.... 0x....      BL       printf
    632          		      if ((MC_PMCTRL & MC_PMCTRL_LPLLSM_MASK) == 5 )
   \                     ??outSRS_8:
   \   0000008E   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000098   0x2805             CMP      R0,#+5
   \   0000009A   0xD102             BNE.N    ??outSRS_9
    633          		         printf("[outSRS]Pin Reset wakeup from Very low leakage stop (VLLS3)\n");
   \   0000009C   0x....             LDR.N    R0,??DataTable13_48
   \   0000009E   0x.... 0x....      BL       printf
    634          		      if ((MC_PMCTRL & MC_PMCTRL_LPLLSM_MASK) == 6)
   \                     ??outSRS_9:
   \   000000A2   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000000AC   0x2806             CMP      R0,#+6
   \   000000AE   0xD102             BNE.N    ??outSRS_10
    635          		         printf("[outSRS]Pin Reset wakeup from Very low leakage stop (VLLS2)\n");
   \   000000B0   0x....             LDR.N    R0,??DataTable13_49
   \   000000B2   0x.... 0x....      BL       printf
    636          		      if ((MC_PMCTRL & MC_PMCTRL_LPLLSM_MASK) == 7)		       
   \                     ??outSRS_10:
   \   000000B6   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000000C0   0x2807             CMP      R0,#+7
   \   000000C2   0xD102             BNE.N    ??outSRS_11
    637          		         printf("Pin Reset wakeup from Very low leakage stop 1(VLLS1)\n");
   \   000000C4   0x....             LDR.N    R0,??DataTable13_50
   \   000000C6   0x.... 0x....      BL       printf
    638                    printf("[outSRS]MC PMPROT= %#02X \r\n",   (MC_PMPROT)  );
   \                     ??outSRS_11:
   \   000000CA   0x....             LDR.N    R0,??DataTable13_1  ;; 0x4007e002
   \   000000CC   0x7801             LDRB     R1,[R0, #+0]
   \   000000CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D0   0x....             LDR.N    R0,??DataTable13_51
   \   000000D2   0x.... 0x....      BL       printf
    639                    printf("[outSRS]MC PMCTRL= %#02X \r\n\n", (MC_PMCTRL) ) ;
   \   000000D6   0x....             LDR.N    R0,??DataTable13  ;; 0x4007e003
   \   000000D8   0x7801             LDRB     R1,[R0, #+0]
   \   000000DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DC   0x....             LDR.N    R0,??DataTable13_52
   \   000000DE   0x.... 0x....      BL       printf
    640          	}
    641          	if (MC_SRSL & MC_SRSL_COP_MASK)
   \                     ??outSRS_5:
   \   000000E2   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x0680             LSLS     R0,R0,#+26
   \   000000E8   0xD502             BPL.N    ??outSRS_12
    642          	 	printf("[outSRS]Watchdog(COP) Reset\n");
   \   000000EA   0x....             LDR.N    R0,??DataTable13_53
   \   000000EC   0x.... 0x....      BL       printf
    643            if (MC_SRSL & MC_SRSL_LOC_MASK)
   \                     ??outSRS_12:
   \   000000F0   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x0740             LSLS     R0,R0,#+29
   \   000000F6   0xD502             BPL.N    ??outSRS_13
    644          		printf("[outSRS]Loss of Clock Reset\n");
   \   000000F8   0x....             LDR.N    R0,??DataTable13_54
   \   000000FA   0x.... 0x....      BL       printf
    645          	if (MC_SRSL & MC_SRSL_LVD_MASK)
   \                     ??outSRS_13:
   \   000000FE   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0x0780             LSLS     R0,R0,#+30
   \   00000104   0xD502             BPL.N    ??outSRS_14
    646          	  printf("[outSRS]Low-voltage Detect Reset\n");
   \   00000106   0x....             LDR.N    R0,??DataTable13_55
   \   00000108   0x.... 0x....      BL       printf
    647            if (MC_SRSL & MC_SRSL_WAKEUP_MASK)
   \                     ??outSRS_14:
   \   0000010C   0x....             LDR.N    R0,??DataTable13_41  ;; 0x4007e001
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x07C0             LSLS     R0,R0,#+31
   \   00000112   0xD502             BPL.N    ??outSRS_15
    648          		printf("[outSRS]LLWU Reset\n");	
   \   00000114   0x....             LDR.N    R0,??DataTable13_56
   \   00000116   0x.... 0x....      BL       printf
    649          }
   \                     ??outSRS_15:
   \   0000011A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x55 0x00          DC8      "U",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x4007E003         DC32     0x4007e003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x4007E002         DC32     0x4007e002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     `?<Constant "\\n\\n\\n To communicate in...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     `?<Constant "\\r\\n Send any character...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x03330000         DC32     0x3330000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     periph_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     `?<Constant "\\r\\n Send any character...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x4007D002         DC32     0x4007d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     i

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x4006D004         DC32     0x4006d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     core_clk_mhz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     `?<Constant "               Now in...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x........         DC32     `?<Constant "\\n--------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x........         DC32     `?<Constant "  MC_Enter Low Power ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x........         DC32     `?<Constant "---------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x4004D068         DC32     0x4004d068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x4004904C         DC32     0x4004904c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x40049018         DC32     0x40049018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \   00000000   0x40049004         DC32     0x40049004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_23:
   \   00000000   0x40049008         DC32     0x40049008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_24:
   \   00000000   0x4004900C         DC32     0x4004900c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_25:
   \   00000000   0x40049014         DC32     0x40049014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_26:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_27:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_28:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_29:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_30:
   \   00000000   0x4004802C         DC32     0x4004802c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_31:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_32:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_33:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_34:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_35:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_36:
   \   00000000   0x70102030         DC32     0x70102030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_37:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_38:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Software Reset\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_39:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Core Lockup E...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_40:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]JTAG Reset\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_41:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_42:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Power-on Reset\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_43:
   \   00000000   0x........         DC32     `?<Constant "External Pin Reset\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_44:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Pin Reset wak...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_45:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Pin Reset wak...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_46:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Pin Reset wak...">_2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_47:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Pin Reset wak...">_3`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_48:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Pin Reset wak...">_4`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_49:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Pin Reset wak...">_5`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_50:
   \   00000000   0x........         DC32     `?<Constant "Pin Reset wakeup from...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_51:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]MC PMPROT= %#...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_52:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]MC PMCTRL= %#...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_53:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Watchdog(COP)...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_54:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Loss of Clock...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_55:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]Low-voltage D...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_56:
   \   00000000   0x........         DC32     `?<Constant "[outSRS]LLWU Reset\\n">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\n To communicate in...">`:
   \   00000000   0x0A 0x0A          DC8 0AH, 0AH, 0AH, 20H, 54H, 6FH, 20H, 63H
   \              0x0A 0x20    
   \              0x54 0x6F    
   \              0x20 0x63    
   \   00000008   0x6F 0x6D          DC8 6FH, 6DH, 6DH, 75H, 6EH, 69H, 63H, 61H
   \              0x6D 0x75    
   \              0x6E 0x69    
   \              0x63 0x61    
   \   00000010   0x74 0x65          DC8 74H, 65H, 20H, 69H, 6EH, 20H, 56H, 4CH
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x56 0x4C    
   \   00000018   0x50 0x52          DC8 50H, 52H, 20H, 2DH, 20H, 41H, 75H, 74H
   \              0x20 0x2D    
   \              0x20 0x41    
   \              0x75 0x74    
   \   00000020   0x6F 0x2D          DC8 6FH, 2DH, 54H, 72H, 69H, 6DH, 20H, 6DH
   \              0x54 0x72    
   \              0x69 0x6D    
   \              0x20 0x6D    
   \   00000028   0x75 0x73          DC8 75H, 73H, 74H, 20H, 68H, 61H, 76H, 65H
   \              0x74 0x20    
   \              0x68 0x61    
   \              0x76 0x65    
   \   00000030   0x20 0x62          DC8 20H, 62H, 65H, 65H, 6EH, 20H, 64H, 6FH
   \              0x65 0x65    
   \              0x6E 0x20    
   \              0x64 0x6F    
   \   00000038   0x6E 0x65          DC8 6EH, 65H, 2CH, 20H, 43H, 68H, 61H, 6EH
   \              0x2C 0x20    
   \              0x43 0x68    
   \              0x61 0x6E    
   \   00000040   0x67 0x65          DC8 67H, 65H, 20H, 74H, 6FH, 20H, 31H, 39H
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x31 0x39    
   \   00000048   0x32 0x30          DC8 32H, 30H, 30H, 20H, 62H, 61H, 75H, 64H
   \              0x30 0x20    
   \              0x62 0x61    
   \              0x75 0x64    
   \   00000050   0x20 0x61          DC8 20H, 61H, 66H, 74H, 65H, 72H, 20H, 6BH
   \              0x66 0x74    
   \              0x65 0x72    
   \              0x20 0x6B    
   \   00000058   0x65 0x79          DC8 65H, 79H, 20H, 68H, 69H, 74H, 20H, 21H
   \              0x20 0x68    
   \              0x69 0x74    
   \              0x20 0x21    
   \   00000060   0x21 0x21          DC8 21H, 21H, 21H, 20H, 0AH, 0DH, 0
   \              0x21 0x20    
   \              0x0A 0x0D    
   \              0x00         
   \   00000067   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\r\\n Send any character...">`:
   \   00000000   0x0D 0x0A          DC8 0DH, 0AH, 20H, 53H, 65H, 6EH, 64H, 20H
   \              0x20 0x53    
   \              0x65 0x6E    
   \              0x64 0x20    
   \   00000008   0x61 0x6E          DC8 61H, 6EH, 79H, 20H, 63H, 68H, 61H, 72H
   \              0x79 0x20    
   \              0x63 0x68    
   \              0x61 0x72    
   \   00000010   0x61 0x63          DC8 61H, 63H, 74H, 65H, 72H, 20H, 74H, 6FH
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x74 0x6F    
   \   00000018   0x20 0x67          DC8 20H, 67H, 6FH, 20H, 69H, 6EH, 74H, 6FH
   \              0x6F 0x20    
   \              0x69 0x6E    
   \              0x74 0x6F    
   \   00000020   0x20 0x6C          DC8 20H, 6CH, 6FH, 77H, 65H, 72H, 20H, 64H
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x20 0x64    
   \   00000028   0x69 0x76          DC8 69H, 76H, 69H, 64H, 65H, 20H, 6DH, 6FH
   \              0x69 0x64    
   \              0x65 0x20    
   \              0x6D 0x6F    
   \   00000030   0x64 0x65          DC8 64H, 65H, 20H, 0DH, 0AH, 0
   \              0x20 0x0D    
   \              0x0A 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\r\\n Send any character...">_1`:
   \   00000000   0x0D 0x0A          DC8 0DH, 0AH, 20H, 53H, 65H, 6EH, 64H, 20H
   \              0x20 0x53    
   \              0x65 0x6E    
   \              0x64 0x20    
   \   00000008   0x61 0x6E          DC8 61H, 6EH, 79H, 20H, 63H, 68H, 61H, 72H
   \              0x79 0x20    
   \              0x63 0x68    
   \              0x61 0x72    
   \   00000010   0x61 0x63          DC8 61H, 63H, 74H, 65H, 72H, 20H, 74H, 6FH
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x74 0x6F    
   \   00000018   0x20 0x67          DC8 20H, 67H, 6FH, 20H, 69H, 6EH, 74H, 6FH
   \              0x6F 0x20    
   \              0x69 0x6E    
   \              0x74 0x6F    
   \   00000020   0x20 0x6C          DC8 20H, 6CH, 6FH, 77H, 20H, 70H, 6FH, 77H
   \              0x6F 0x77    
   \              0x20 0x70    
   \              0x6F 0x77    
   \   00000028   0x65 0x72          DC8 65H, 72H, 20H, 6DH, 6FH, 64H, 65H, 20H
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \   00000030   0x0D 0x0A          DC8 0DH, 0AH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x55 0x00          DC8 "U"

   \                                 In section .rodata, align 4
   \                     `?<Constant "               Now in...">`:
   \   00000000   0x20 0x20          DC8 "               Now in Run Mode at 115200 baud \015"
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x4E    
   \              0x6F 0x77    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x52 0x75    
   \              0x6E 0x20    
   \              0x4D 0x6F    
   \              0x64 0x65    
   \              0x20 0x61    
   \              0x74 0x20    
   \              0x31 0x31    
   \              0x35 0x32    
   \              0x30 0x30    
   \              0x20 0x62    
   \              0x61 0x75    
   \              0x64 0x20    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n--------------------...">`:
   \   00000000   0x0A 0x2D          DC8 "\012-------------------------------------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "  MC_Enter Low Power ...">`:
   \   00000000   0x20 0x20          DC8 "  MC_Enter Low Power Modes Utility    \012"
   \              0x4D 0x43    
   \              0x5F 0x45    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x4C    
   \              0x6F 0x77    
   \              0x20 0x50    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x20 0x4D    
   \              0x6F 0x64    
   \              0x65 0x73    
   \              0x20 0x55    
   \              0x74 0x69    
   \              0x6C 0x69    
   \              0x74 0x79    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "---------------------...">`:
   \   00000000   0x2D 0x2D          DC8 "--------------------------------------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Software Reset\\n">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Software Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Core Lockup E...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Core Lockup Event Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x43 0x6F    
   \              0x72 0x65    
   \              0x20 0x4C    
   \              0x6F 0x63    
   \              0x6B 0x75    
   \              0x70 0x20    
   \              0x45 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]JTAG Reset\\n">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]JTAG Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x4A 0x54    
   \              0x41 0x47    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Power-on Reset\\n">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Power-on Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x50 0x6F    
   \              0x77 0x65    
   \              0x72 0x2D    
   \              0x6F 0x6E    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "External Pin Reset\\n">`:
   \   00000000   0x45 0x78          DC8 "External Pin Reset\012"
   \              0x74 0x65    
   \              0x72 0x6E    
   \              0x61 0x6C    
   \              0x20 0x50    
   \              0x69 0x6E    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Pin Reset wak...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Pin Reset wakeup from low power modes\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x50 0x69    
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x6C 0x6F    
   \              0x77 0x20    
   \              0x70 0x6F    
   \              0x77 0x65    
   \              0x72 0x20    
   \              0x6D 0x6F    
   \              0x64 0x65    
   \              0x73 0x0A    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Pin Reset wak...">_1`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Pin Reset wakeup from Normal Stop\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x50 0x69    
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x4E 0x6F    
   \              0x72 0x6D    
   \              0x61 0x6C    
   \              0x20 0x53    
   \              0x74 0x6F    
   \              0x70 0x0A    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Pin Reset wak...">_2`:
   \   00000000   0x5B 0x6F          DC8 5BH, 6FH, 75H, 74H, 53H, 52H, 53H, 5DH
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \   00000008   0x50 0x69          DC8 50H, 69H, 6EH, 20H, 52H, 65H, 73H, 65H
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \   00000010   0x74 0x20          DC8 74H, 20H, 77H, 61H, 6BH, 65H, 75H, 70H
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \   00000018   0x20 0x66          DC8 20H, 66H, 72H, 6FH, 6DH, 20H, 56H, 65H
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x56 0x65    
   \   00000020   0x72 0x79          DC8 72H, 79H, 20H, 4CH, 6FH, 77H, 20H, 50H
   \              0x20 0x4C    
   \              0x6F 0x77    
   \              0x20 0x50    
   \   00000028   0x6F 0x77          DC8 6FH, 77H, 65H, 72H, 20H, 53H, 74H, 6FH
   \              0x65 0x72    
   \              0x20 0x53    
   \              0x74 0x6F    
   \   00000030   0x70 0x28          DC8 70H, 28H, 56H, 4CH, 50H, 53H, 29H, 0AH
   \              0x56 0x4C    
   \              0x50 0x53    
   \              0x29 0x0A    
   \   00000038   0x00               DC8 0
   \   00000039   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Pin Reset wak...">_3`:
   \   00000000   0x5B 0x6F          DC8 5BH, 6FH, 75H, 74H, 53H, 52H, 53H, 5DH
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \   00000008   0x50 0x69          DC8 50H, 69H, 6EH, 20H, 52H, 65H, 73H, 65H
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \   00000010   0x74 0x20          DC8 74H, 20H, 77H, 61H, 6BH, 65H, 75H, 70H
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \   00000018   0x20 0x66          DC8 20H, 66H, 72H, 6FH, 6DH, 20H, 4CH, 6FH
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x4C 0x6F    
   \   00000020   0x77 0x20          DC8 77H, 20H, 4CH, 65H, 61H, 6BH, 61H, 67H
   \              0x4C 0x65    
   \              0x61 0x6B    
   \              0x61 0x67    
   \   00000028   0x65 0x20          DC8 65H, 20H, 53H, 74H, 6FH, 70H, 20H, 28H
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x20 0x28    
   \   00000030   0x4C 0x4C          DC8 4CH, 4CH, 53H, 29H, 0AH, 0
   \              0x53 0x29    
   \              0x0A 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Pin Reset wak...">_4`:
   \   00000000   0x5B 0x6F          DC8 5BH, 6FH, 75H, 74H, 53H, 52H, 53H, 5DH
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \   00000008   0x50 0x69          DC8 50H, 69H, 6EH, 20H, 52H, 65H, 73H, 65H
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \   00000010   0x74 0x20          DC8 74H, 20H, 77H, 61H, 6BH, 65H, 75H, 70H
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \   00000018   0x20 0x66          DC8 20H, 66H, 72H, 6FH, 6DH, 20H, 56H, 65H
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x56 0x65    
   \   00000020   0x72 0x79          DC8 72H, 79H, 20H, 6CH, 6FH, 77H, 20H, 6CH
   \              0x20 0x6C    
   \              0x6F 0x77    
   \              0x20 0x6C    
   \   00000028   0x65 0x61          DC8 65H, 61H, 6BH, 61H, 67H, 65H, 20H, 73H
   \              0x6B 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \   00000030   0x74 0x6F          DC8 74H, 6FH, 70H, 20H, 28H, 56H, 4CH, 4CH
   \              0x70 0x20    
   \              0x28 0x56    
   \              0x4C 0x4C    
   \   00000038   0x53 0x33          DC8 53H, 33H, 29H, 0AH, 0
   \              0x29 0x0A    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Pin Reset wak...">_5`:
   \   00000000   0x5B 0x6F          DC8 5BH, 6FH, 75H, 74H, 53H, 52H, 53H, 5DH
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \   00000008   0x50 0x69          DC8 50H, 69H, 6EH, 20H, 52H, 65H, 73H, 65H
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \   00000010   0x74 0x20          DC8 74H, 20H, 77H, 61H, 6BH, 65H, 75H, 70H
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \   00000018   0x20 0x66          DC8 20H, 66H, 72H, 6FH, 6DH, 20H, 56H, 65H
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x56 0x65    
   \   00000020   0x72 0x79          DC8 72H, 79H, 20H, 6CH, 6FH, 77H, 20H, 6CH
   \              0x20 0x6C    
   \              0x6F 0x77    
   \              0x20 0x6C    
   \   00000028   0x65 0x61          DC8 65H, 61H, 6BH, 61H, 67H, 65H, 20H, 73H
   \              0x6B 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \   00000030   0x74 0x6F          DC8 74H, 6FH, 70H, 20H, 28H, 56H, 4CH, 4CH
   \              0x70 0x20    
   \              0x28 0x56    
   \              0x4C 0x4C    
   \   00000038   0x53 0x32          DC8 53H, 32H, 29H, 0AH, 0
   \              0x29 0x0A    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Pin Reset wakeup from...">`:
   \   00000000   0x50 0x69          DC8 50H, 69H, 6EH, 20H, 52H, 65H, 73H, 65H
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \   00000008   0x74 0x20          DC8 74H, 20H, 77H, 61H, 6BH, 65H, 75H, 70H
   \              0x77 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \   00000010   0x20 0x66          DC8 20H, 66H, 72H, 6FH, 6DH, 20H, 56H, 65H
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x56 0x65    
   \   00000018   0x72 0x79          DC8 72H, 79H, 20H, 6CH, 6FH, 77H, 20H, 6CH
   \              0x20 0x6C    
   \              0x6F 0x77    
   \              0x20 0x6C    
   \   00000020   0x65 0x61          DC8 65H, 61H, 6BH, 61H, 67H, 65H, 20H, 73H
   \              0x6B 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \   00000028   0x74 0x6F          DC8 74H, 6FH, 70H, 20H, 31H, 28H, 56H, 4CH
   \              0x70 0x20    
   \              0x31 0x28    
   \              0x56 0x4C    
   \   00000030   0x4C 0x53          DC8 4CH, 53H, 31H, 29H, 0AH, 0
   \              0x31 0x29    
   \              0x0A 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]MC PMPROT= %#...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]MC PMPROT= %#02X \015\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x4D 0x43    
   \              0x20 0x50    
   \              0x4D 0x50    
   \              0x52 0x4F    
   \              0x54 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]MC PMCTRL= %#...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]MC PMCTRL= %#02X \015\012\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x4D 0x43    
   \              0x20 0x50    
   \              0x4D 0x43    
   \              0x54 0x52    
   \              0x4C 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Watchdog(COP)...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Watchdog(COP) Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x57 0x61    
   \              0x74 0x63    
   \              0x68 0x64    
   \              0x6F 0x67    
   \              0x28 0x43    
   \              0x4F 0x50    
   \              0x29 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Loss of Clock...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Loss of Clock Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x4C 0x6F    
   \              0x73 0x73    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x43 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]Low-voltage D...">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]Low-voltage Detect Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x4C 0x6F    
   \              0x77 0x2D    
   \              0x76 0x6F    
   \              0x6C 0x74    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x44 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "[outSRS]LLWU Reset\\n">`:
   \   00000000   0x5B 0x6F          DC8 "[outSRS]LLWU Reset\012"
   \              0x75 0x74    
   \              0x53 0x52    
   \              0x53 0x5D    
   \              0x4C 0x4C    
   \              0x57 0x55    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x0A 0x00    
    650          
    651          
    652          
    653          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  disable_lpwui
        0  disable_ports
        0  disable_ports_partial
        0  enable_lpwui
        8  enter_lls
             8 -> stop
        8  enter_stop
             8 -> stop
        8  enter_stop_mode
             8 -> printf
             8 -> stop
        8  enter_vlls1
             8 -> disable_ports
             8 -> stop
        8  enter_vlls2
             8 -> disable_ports
             8 -> stop
        8  enter_vlls3
             8 -> disable_ports
             8 -> stop
        8  enter_vlpr
             8 -> in_char
             8 -> mcg_pee_2_blpi
             8 -> printf
             8 -> uart_init
        8  enter_vlps
             8 -> stop
        8  enter_wait
             8 -> wait
        8  exit_vlpr
             8 -> mcg_blpi_2_pee
             8 -> printf
             8 -> uart_init
        8  outSRS
             8 -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      48  ?<Constant "               Now in...">
      40  ?<Constant "  MC_Enter Low Power ...">
      40  ?<Constant "---------------------...">
      20  ?<Constant "External Pin Reset\n">
      56  ?<Constant "Pin Reset wakeup from...">
       2  ?<Constant "U">
      36  ?<Constant "[outSRS]Core Lockup E...">
      20  ?<Constant "[outSRS]JTAG Reset\n">
      20  ?<Constant "[outSRS]LLWU Reset\n">
      32  ?<Constant "[outSRS]Loss of Clock...">
      36  ?<Constant "[outSRS]Low-voltage D...">
      32  ?<Constant "[outSRS]MC PMCTRL= %#...">
      28  ?<Constant "[outSRS]MC PMPROT= %#...">
      48  ?<Constant "[outSRS]Pin Reset wak...">
      44  ?<Constant "[outSRS]Pin Reset wak...">_1
      60  ?<Constant "[outSRS]Pin Reset wak...">_2
      56  ?<Constant "[outSRS]Pin Reset wak...">_3
      64  ?<Constant "[outSRS]Pin Reset wak...">_4
      64  ?<Constant "[outSRS]Pin Reset wak...">_5
      24  ?<Constant "[outSRS]Power-on Reset\n">
      24  ?<Constant "[outSRS]Software Reset\n">
      32  ?<Constant "[outSRS]Watchdog(COP)...">
      40  ?<Constant "\n--------------------...">
     104  ?<Constant "\n\n\n To communicate in...">
      56  ?<Constant "\r\n Send any character...">
      52  ?<Constant "\r\n Send any character...">_1
       4  ??DataTable11
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_47
       4  ??DataTable13_48
       4  ??DataTable13_49
       4  ??DataTable13_5
       4  ??DataTable13_50
       4  ??DataTable13_51
       4  ??DataTable13_52
       4  ??DataTable13_53
       4  ??DataTable13_54
       4  ??DataTable13_55
       4  ??DataTable13_56
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      14  disable_lpwui
     110  disable_ports
      56  disable_ports_partial
      14  enable_lpwui
      20  enter_lls
      16  enter_stop
      46  enter_stop_mode
      24  enter_vlls1
      24  enter_vlls2
      24  enter_vlls3
     204  enter_vlpr
      34  enter_vlps
       8  enter_wait
     104  exit_vlpr
       4  i
     284  outSRS

 
     4 bytes in section .bss
 1 078 bytes in section .rodata
 1 214 bytes in section .text
 
 1 214 bytes of CODE  memory
 1 078 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
