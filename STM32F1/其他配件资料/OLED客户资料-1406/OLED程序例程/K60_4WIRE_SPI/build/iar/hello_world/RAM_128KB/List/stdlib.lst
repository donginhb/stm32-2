###############################################################################
#                                                                             #
#                                                       07/May/2014  16:39:04 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\common\stdlib.c                               #
#    Command line =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\common\stdlib.c -D IAR -D TWR_K60N512 -lCN    #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -lB         #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -o          #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\ --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.0           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\projects\hello #
#                    _world\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kin #
#                    etisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\com #
#                    mon\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\headers #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\a #
#                    dc16\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kinet #
#                    isK60_Demo_OLED\build\iar\hello_world\..\..\..\src\drive #
#                    rs\enet\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Ki #
#                    netisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\dr #
#                    ivers\pmc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\ #
#                    KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\ #
#                    drivers\rtc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³ #
#                    Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\sr #
#                    c\drivers\lptmr\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐ #
#                    òÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\. #
#                    .\src\drivers\uart\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\ #
#                    ³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\. #
#                    .\..\src\drivers\mcg\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁ #
#                    Ï\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\.. #
#                    \..\..\src\drivers\wdog\ -I                              #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\platforms\ -I  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\drivers\ftm\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\SPI #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\O #
#                    LED\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\ -On             #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\stdlib.lst   #
#    Object file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\stdlib.o      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\src\common\stdlib.c
      1          /*
      2           * File:        stdlib.c
      3           * Purpose:     Functions normally found in a standard C lib.
      4           *
      5           * Notes:       This supports ASCII only!!!
      6           *
      7           */
      8          
      9          #include "common.h"
     10          #include "stdlib.h"
     11          
     12          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     13          int
     14          isspace (int ch)
     15          {
   \                     isspace:
   \   00000000   0x0001             MOVS     R1,R0
     16              if ((ch == ' ') || (ch == '\t'))    /* \n ??? */
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xD001             BEQ.N    ??isspace_0
   \   00000006   0x2909             CMP      R1,#+9
   \   00000008   0xD101             BNE.N    ??isspace_1
     17                  return TRUE;
   \                     ??isspace_0:
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??isspace_2
     18              else
     19                  return FALSE;
   \                     ??isspace_1:
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??isspace_2:
   \   00000010   0x4770             BX       LR               ;; return
     20          }
     21          
     22          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     23          int
     24          isalnum (int ch)
     25          {
   \                     isalnum:
   \   00000000   0x0001             MOVS     R1,R0
     26              /* ASCII only */
     27              if (((ch >= '0') && (ch <= '9')) ||
     28                  ((ch >= 'A') && (ch <= 'Z')) ||
     29                  ((ch >= 'a') && (ch <= 'z')))
   \   00000002   0x2930             CMP      R1,#+48
   \   00000004   0xDB01             BLT.N    ??isalnum_0
   \   00000006   0x293A             CMP      R1,#+58
   \   00000008   0xDB07             BLT.N    ??isalnum_1
   \                     ??isalnum_0:
   \   0000000A   0x2941             CMP      R1,#+65
   \   0000000C   0xDB01             BLT.N    ??isalnum_2
   \   0000000E   0x295B             CMP      R1,#+91
   \   00000010   0xDB03             BLT.N    ??isalnum_1
   \                     ??isalnum_2:
   \   00000012   0x2961             CMP      R1,#+97
   \   00000014   0xDB03             BLT.N    ??isalnum_3
   \   00000016   0x297B             CMP      R1,#+123
   \   00000018   0xDA01             BGE.N    ??isalnum_3
     30                  return TRUE;
   \                     ??isalnum_1:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??isalnum_4
     31              else
     32                  return FALSE;
   \                     ??isalnum_3:
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??isalnum_4:
   \   00000020   0x4770             BX       LR               ;; return
     33          }
     34          
     35          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     36          int
     37          isdigit (int ch)
     38          {
   \                     isdigit:
   \   00000000   0x0001             MOVS     R1,R0
     39              /* ASCII only */
     40              if ((ch >= '0') && (ch <= '9'))
   \   00000002   0x2930             CMP      R1,#+48
   \   00000004   0xDB03             BLT.N    ??isdigit_0
   \   00000006   0x293A             CMP      R1,#+58
   \   00000008   0xDA01             BGE.N    ??isdigit_0
     41                  return TRUE;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??isdigit_1
     42              else
     43                  return FALSE;
   \                     ??isdigit_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??isdigit_1:
   \   00000010   0x4770             BX       LR               ;; return
     44          }
     45          
     46          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     47          int
     48          isupper (int ch)
     49          {
   \                     isupper:
   \   00000000   0x0001             MOVS     R1,R0
     50              /* ASCII only */
     51              if ((ch >= 'A') && (ch <= 'Z'))
   \   00000002   0x2941             CMP      R1,#+65
   \   00000004   0xDB03             BLT.N    ??isupper_0
   \   00000006   0x295B             CMP      R1,#+91
   \   00000008   0xDA01             BGE.N    ??isupper_0
     52                  return TRUE;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??isupper_1
     53              else
     54                  return FALSE;
   \                     ??isupper_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??isupper_1:
   \   00000010   0x4770             BX       LR               ;; return
     55          }
     56          
     57          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     58          int
     59          strcasecmp (const char *s1, const char *s2)
     60          {
   \                     strcasecmp:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
     61              char    c1, c2;
     62              int     result = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     63          
     64              while (result == 0)
   \                     ??strcasecmp_0:
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD11F             BNE.N    ??strcasecmp_1
     65              {
     66                  c1 = *s1++;
   \   0000000A   0x7815             LDRB     R5,[R2, #+0]
   \   0000000C   0x002B             MOVS     R3,R5
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
     67                  c2 = *s2++;
   \   00000010   0x780D             LDRB     R5,[R1, #+0]
   \   00000012   0x002C             MOVS     R4,R5
   \   00000014   0x1C49             ADDS     R1,R1,#+1
     68                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   00000016   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000018   0x2B61             CMP      R3,#+97
   \   0000001A   0xD303             BCC.N    ??strcasecmp_2
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x2B7B             CMP      R3,#+123
   \   00000020   0xD200             BCS.N    ??strcasecmp_2
     69                      c1 = (char)(c1 - ' ');
   \   00000022   0x3B20             SUBS     R3,R3,#+32
     70                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strcasecmp_2:
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C61             CMP      R4,#+97
   \   00000028   0xD303             BCC.N    ??strcasecmp_3
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C7B             CMP      R4,#+123
   \   0000002E   0xD200             BCS.N    ??strcasecmp_3
     71                      c2 = (char)(c2 - ' ');
   \   00000030   0x3C20             SUBS     R4,R4,#+32
     72                  if ((result = (c1 - c2)) != 0)
   \                     ??strcasecmp_3:
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x1B1D             SUBS     R5,R3,R4
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD105             BNE.N    ??strcasecmp_1
     73                      break;
     74                  if ((c1 == 0) || (c2 == 0))
   \                     ??strcasecmp_4:
   \   0000003E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000040   0x2B00             CMP      R3,#+0
   \   00000042   0xD002             BEQ.N    ??strcasecmp_5
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD1DD             BNE.N    ??strcasecmp_0
     75                      break;
     76              }
     77              return result;
   \                     ??strcasecmp_5:
   \                     ??strcasecmp_1:
   \   0000004A   0xBC30             POP      {R4,R5}
   \   0000004C   0x4770             BX       LR               ;; return
     78          }
     79          
     80          
     81          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     82          int
     83          strncasecmp (const char *s1, const char *s2, int n)
     84          {
   \                     strncasecmp:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
     85              char    c1, c2;
     86              int     k = 0;
   \   00000004   0x2600             MOVS     R6,#+0
     87              int     result = 0;
   \   00000006   0x2000             MOVS     R0,#+0
     88          
     89              while ( k++ < n )
   \                     ??strncasecmp_0:
   \   00000008   0x0037             MOVS     R7,R6
   \   0000000A   0x1C7E             ADDS     R6,R7,#+1
   \   0000000C   0x4297             CMP      R7,R2
   \   0000000E   0xDA1F             BGE.N    ??strncasecmp_1
     90              {
     91                  c1 = *s1++;
   \   00000010   0x781F             LDRB     R7,[R3, #+0]
   \   00000012   0x003C             MOVS     R4,R7
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
     92                  c2 = *s2++;
   \   00000016   0x780F             LDRB     R7,[R1, #+0]
   \   00000018   0x003D             MOVS     R5,R7
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
     93                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C61             CMP      R4,#+97
   \   00000020   0xD303             BCC.N    ??strncasecmp_2
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C7B             CMP      R4,#+123
   \   00000026   0xD200             BCS.N    ??strncasecmp_2
     94                      c1 = (char)(c1 - ' ');
   \   00000028   0x3C20             SUBS     R4,R4,#+32
     95                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strncasecmp_2:
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D61             CMP      R5,#+97
   \   0000002E   0xD303             BCC.N    ??strncasecmp_3
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D7B             CMP      R5,#+123
   \   00000034   0xD200             BCS.N    ??strncasecmp_3
     96                      c2 = (char)(c2 - ' ');
   \   00000036   0x3D20             SUBS     R5,R5,#+32
     97                  if ((result = (c1 - c2)) != 0)
   \                     ??strncasecmp_3:
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x1B67             SUBS     R7,R4,R5
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD105             BNE.N    ??strncasecmp_1
     98                      break;
     99                  if ((c1 == 0) || (c2 == 0))
   \                     ??strncasecmp_4:
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD002             BEQ.N    ??strncasecmp_5
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD1DB             BNE.N    ??strncasecmp_0
    100                      break;
    101              }
    102              return result;
   \                     ??strncasecmp_5:
   \                     ??strncasecmp_1:
   \   00000050   0xBCF0             POP      {R4-R7}
   \   00000052   0x4770             BX       LR               ;; return
    103          }
    104          
    105          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          uint32
    107          strtoul (char *str, char **ptr, int base)
    108          {
   \                     strtoul:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    109              unsigned long rvalue;
    110              int c, err, neg;
    111              char *endp;
    112              char *startp;
    113          
    114              rvalue = 0;  err = 0;  neg = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0007             MOVS     R7,R0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4680             MOV      R8,R0
    115          
    116              /* Check for invalid arguments */
    117              if ((str == NULL) || (base < 0) || (base == 1) || (base > 36))
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD005             BEQ.N    ??strtoul_0
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD403             BMI.N    ??strtoul_0
   \   0000001E   0x2E01             CMP      R6,#+1
   \   00000020   0xD001             BEQ.N    ??strtoul_0
   \   00000022   0x2E25             CMP      R6,#+37
   \   00000024   0xDB04             BLT.N    ??strtoul_1
    118              {
    119                  if (ptr != NULL)
   \                     ??strtoul_0:
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD000             BEQ.N    ??strtoul_2
    120                  {
    121                      *ptr = str;
   \   0000002A   0x602C             STR      R4,[R5, #+0]
    122                  }
    123                  return 0;
   \                     ??strtoul_2:
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE068             B.N      ??strtoul_3
    124              }
    125          
    126              /* Skip leading white spaces */
    127              for (startp = str; isspace(*startp); ++startp)
   \                     ??strtoul_1:
   \   00000030   0x46A2             MOV      R10,R4
   \                     ??strtoul_4:
   \   00000032   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000036   0x.... 0x....      BL       isspace
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ.N    ??strtoul_5
   \   0000003E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000042   0xE7F6             B.N      ??strtoul_4
    128                  ;
    129          
    130              /* Check for notations */
    131              switch (startp[0])
   \                     ??strtoul_5:
   \   00000044   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000048   0x282D             CMP      R0,#+45
   \   0000004A   0xD012             BEQ.N    ??strtoul_6
   \   0000004C   0x2830             CMP      R0,#+48
   \   0000004E   0xD115             BNE.N    ??strtoul_7
    132              {
    133                  case '0':
    134                      if ((startp[1] == 'x') || (startp[1] == 'X'))
   \                     ??strtoul_8:
   \   00000050   0xF89A 0x0001      LDRB     R0,[R10, #+1]
   \   00000054   0x2878             CMP      R0,#+120
   \   00000056   0xD003             BEQ.N    ??strtoul_9
   \   00000058   0xF89A 0x0001      LDRB     R0,[R10, #+1]
   \   0000005C   0x2858             CMP      R0,#+88
   \   0000005E   0xD107             BNE.N    ??strtoul_10
    135                      {
    136                          if ((base == 0) || (base == 16))
   \                     ??strtoul_9:
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD001             BEQ.N    ??strtoul_11
   \   00000064   0x2E10             CMP      R6,#+16
   \   00000066   0xD103             BNE.N    ??strtoul_10
    137                          {
    138                              base = 16;
   \                     ??strtoul_11:
   \   00000068   0x2010             MOVS     R0,#+16
   \   0000006A   0x0006             MOVS     R6,R0
    139                              startp = &startp[2];
   \   0000006C   0xF11A 0x0A02      ADDS     R10,R10,#+2
    140                          }
    141                      }
    142                      break;
   \                     ??strtoul_10:
   \   00000070   0xE004             B.N      ??strtoul_12
    143                  case '-':
    144                      neg = 1;
   \                     ??strtoul_6:
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x4680             MOV      R8,R0
    145                      startp = &startp[1];
   \   00000076   0xF11A 0x0A01      ADDS     R10,R10,#+1
    146                      break;
   \   0000007A   0xE7FF             B.N      ??strtoul_12
    147                  default:
    148                      break;
    149              }
    150          
    151              if (base == 0)
   \                     ??strtoul_7:
   \                     ??strtoul_12:
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD101             BNE.N    ??strtoul_13
    152                  base = 10;
   \   00000080   0x200A             MOVS     R0,#+10
   \   00000082   0x0006             MOVS     R6,R0
    153          
    154              /* Check for invalid chars in str */
    155              for ( endp = startp; (c = *endp) != '\0'; ++endp)
   \                     ??strtoul_13:
   \   00000084   0x46D1             MOV      R9,R10
   \                     ??strtoul_14:
   \   00000086   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000008A   0x4683             MOV      R11,R0
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD02B             BEQ.N    ??strtoul_15
    156              {
    157                  /* Check for 0..9,Aa-Zz */
    158                  if (!isalnum(c))
   \   00000090   0x4658             MOV      R0,R11
   \   00000092   0x.... 0x....      BL       isalnum
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD102             BNE.N    ??strtoul_16
    159                  {
    160                      err = 1;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x9000             STR      R0,[SP, #+0]
    161                      break;
   \   0000009E   0xE023             B.N      ??strtoul_15
    162                  }
    163          
    164                  /* Convert char to num in 0..36 */
    165                  if (isdigit(c))
   \                     ??strtoul_16:
   \   000000A0   0x4658             MOV      R0,R11
   \   000000A2   0x.... 0x....      BL       isdigit
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD002             BEQ.N    ??strtoul_17
    166                  {
    167                      c = c - '0';
   \   000000AA   0xF1BB 0x0B30      SUBS     R11,R11,#+48
   \   000000AE   0xE009             B.N      ??strtoul_18
    168                  }
    169                  else
    170                  {
    171                      if (isupper(c))
   \                     ??strtoul_17:
   \   000000B0   0x4658             MOV      R0,R11
   \   000000B2   0x.... 0x....      BL       isupper
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD002             BEQ.N    ??strtoul_19
    172                      {
    173                          c = c - 'A' + 10;
   \   000000BA   0xF1BB 0x0B37      SUBS     R11,R11,#+55
   \   000000BE   0xE001             B.N      ??strtoul_18
    174                      }
    175                      else
    176                      {
    177                          c = c - 'a' + 10;
   \                     ??strtoul_19:
   \   000000C0   0xF1BB 0x0B57      SUBS     R11,R11,#+87
    178                      }
    179                  }
    180          
    181                  /* check c against base */
    182                  if (c >= base)
   \                     ??strtoul_18:
   \   000000C4   0x45B3             CMP      R11,R6
   \   000000C6   0xDB02             BLT.N    ??strtoul_20
    183                  {
    184                      err = 1;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x9000             STR      R0,[SP, #+0]
    185                      break;
   \   000000CC   0xE00C             B.N      ??strtoul_15
    186                  }
    187          
    188                  if (neg)
   \                     ??strtoul_20:
   \   000000CE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D2   0xD004             BEQ.N    ??strtoul_21
    189                  {
    190                      rvalue = (rvalue * base) - c;
   \   000000D4   0xFB06 0xF007      MUL      R0,R6,R7
   \   000000D8   0xEBB0 0x070B      SUBS     R7,R0,R11
   \   000000DC   0xE001             B.N      ??strtoul_22
    191                  }
    192                  else
    193                  {
    194                      rvalue = (rvalue * base) + c;
   \                     ??strtoul_21:
   \   000000DE   0xFB06 0xB707      MLA      R7,R6,R7,R11
    195                  }
    196              }
   \                     ??strtoul_22:
   \   000000E2   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000E6   0xE7CE             B.N      ??strtoul_14
    197          
    198              /* Upon exit, endp points to the character at which valid info */
    199              /* STOPS.  No chars including and beyond endp are used.        */
    200          
    201              if (ptr != NULL)
   \                     ??strtoul_15:
   \   000000E8   0x2D00             CMP      R5,#+0
   \   000000EA   0xD001             BEQ.N    ??strtoul_23
    202                  *ptr = endp;
   \   000000EC   0xF8C5 0x9000      STR      R9,[R5, #+0]
    203          
    204              if (err)
   \                     ??strtoul_23:
   \   000000F0   0x9800             LDR      R0,[SP, #+0]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD004             BEQ.N    ??strtoul_24
    205              {
    206                  if (ptr != NULL)
   \   000000F6   0x2D00             CMP      R5,#+0
   \   000000F8   0xD000             BEQ.N    ??strtoul_25
    207                      *ptr = str;
   \   000000FA   0x602C             STR      R4,[R5, #+0]
    208                  
    209                  return 0;
   \                     ??strtoul_25:
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xE000             B.N      ??strtoul_3
    210              }
    211              else
    212              {
    213                  return rvalue;
   \                     ??strtoul_24:
   \   00000100   0x0038             MOVS     R0,R7
   \                     ??strtoul_3:
   \   00000102   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    214              }
    215          }
    216          
    217          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    218          int
    219          strlen (const char *str)
    220          {
   \                     strlen:
   \   00000000   0x0001             MOVS     R1,R0
    221              char *s = (char *)str;
   \   00000002   0x000A             MOVS     R2,R1
    222              int len = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    223          
    224              if (s == NULL)
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??strlen_0
    225                  return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE007             B.N      ??strlen_1
    226          
    227              while (*s++ != '\0')
   \                     ??strlen_0:
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0x1C42             ADDS     R2,R0,#+1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??strlen_2
    228                  ++len;
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \   0000001A   0xE7F8             B.N      ??strlen_0
    229          
    230              return len;
   \                     ??strlen_2:
   \   0000001C   0x0018             MOVS     R0,R3
   \                     ??strlen_1:
   \   0000001E   0x4770             BX       LR               ;; return
    231          }
    232          
    233          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          char *
    235          strcat (char *dest, const char *src)
    236          {
   \                     strcat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    237              char *dp;
    238              char *sp = (char *)src;
   \   00000006   0x002F             MOVS     R7,R5
    239          
    240              if ((dest != NULL) && (src != NULL))
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD010             BEQ.N    ??strcat_0
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD00E             BEQ.N    ??strcat_0
    241              {
    242                  dp = &dest[strlen(dest)];
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       strlen
   \   00000016   0x1900             ADDS     R0,R0,R4
   \   00000018   0x0006             MOVS     R6,R0
    243          
    244                  while (*sp != '\0')
   \                     ??strcat_1:
   \   0000001A   0x7838             LDRB     R0,[R7, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??strcat_2
    245                  {
    246                      *dp++ = *sp++;
   \   00000020   0x7838             LDRB     R0,[R7, #+0]
   \   00000022   0x7030             STRB     R0,[R6, #+0]
   \   00000024   0x1C7F             ADDS     R7,R7,#+1
   \   00000026   0x1C76             ADDS     R6,R6,#+1
   \   00000028   0xE7F7             B.N      ??strcat_1
    247                  }
    248                  *dp = '\0';
   \                     ??strcat_2:
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7030             STRB     R0,[R6, #+0]
    249              }
    250              return dest;
   \                     ??strcat_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    251          }
    252          
    253          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    254          char *
    255          strncat (char *dest, const char *src, int n)
    256          {
   \                     strncat:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
    257              char *dp;
    258              char *sp = (char *)src;
   \   0000000A   0x002F             MOVS     R7,R5
    259          
    260              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD018             BEQ.N    ??strncat_0
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD016             BEQ.N    ??strncat_0
   \   00000014   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000018   0xDB13             BLT.N    ??strncat_0
    261              {
    262                  dp = &dest[strlen(dest)];
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0x1900             ADDS     R0,R0,R4
   \   00000022   0x0006             MOVS     R6,R0
    263          
    264                  while ((*sp != '\0') && (n-- > 0))
   \                     ??strncat_1:
   \   00000024   0x7838             LDRB     R0,[R7, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD009             BEQ.N    ??strncat_2
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xDB04             BLT.N    ??strncat_2
    265                  {
    266                      *dp++ = *sp++;
   \   00000034   0x7838             LDRB     R0,[R7, #+0]
   \   00000036   0x7030             STRB     R0,[R6, #+0]
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \   0000003C   0xE7F2             B.N      ??strncat_1
    267                  }
    268                  *dp = '\0';
   \                     ??strncat_2:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7030             STRB     R0,[R6, #+0]
    269              }
    270              return dest;
   \                     ??strncat_0:
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    271          }
    272          
    273          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    274          char *
    275          strcpy (char *dest, const char *src)
    276          {
   \                     strcpy:
   \   00000000   0xB410             PUSH     {R4}
    277              char *dp = (char *)dest;
   \   00000002   0x0002             MOVS     R2,R0
    278              char *sp = (char *)src;
   \   00000004   0x000B             MOVS     R3,R1
    279          
    280              if ((dest != NULL) && (src != NULL))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00B             BEQ.N    ??strcpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD009             BEQ.N    ??strcpy_0
    281              {
    282                  while (*sp != '\0')
   \                     ??strcpy_1:
   \   0000000E   0x781C             LDRB     R4,[R3, #+0]
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??strcpy_2
    283                  {
    284                      *dp++ = *sp++;
   \   00000014   0x781C             LDRB     R4,[R3, #+0]
   \   00000016   0x7014             STRB     R4,[R2, #+0]
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0xE7F7             B.N      ??strcpy_1
    285                  }
    286                  *dp = '\0';
   \                     ??strcpy_2:
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x7014             STRB     R4,[R2, #+0]
    287              }
    288              return dest;
   \                     ??strcpy_0:
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
    289          }
    290          
    291          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    292          char *
    293          strncpy (char *dest, const char *src, int n)
    294          {
   \                     strncpy:
   \   00000000   0xB430             PUSH     {R4,R5}
    295              char *dp = (char *)dest;
   \   00000002   0x0003             MOVS     R3,R0
    296              char *sp = (char *)src;
   \   00000004   0x000C             MOVS     R4,R1
    297          
    298              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD011             BEQ.N    ??strncpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD00F             BEQ.N    ??strncpy_0
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xDB0D             BLT.N    ??strncpy_0
    299              {
    300                  while ((*sp != '\0') && (n-- > 0))
   \                     ??strncpy_1:
   \   00000012   0x7825             LDRB     R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD008             BEQ.N    ??strncpy_2
   \   00000018   0x0015             MOVS     R5,R2
   \   0000001A   0x1E6A             SUBS     R2,R5,#+1
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xDB04             BLT.N    ??strncpy_2
    301                  {
    302                      *dp++ = *sp++;
   \   00000020   0x7825             LDRB     R5,[R4, #+0]
   \   00000022   0x701D             STRB     R5,[R3, #+0]
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \   00000026   0x1C5B             ADDS     R3,R3,#+1
   \   00000028   0xE7F3             B.N      ??strncpy_1
    303                  }
    304                  *dp = '\0';
   \                     ??strncpy_2:
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x701D             STRB     R5,[R3, #+0]
    305              }
    306              return dest;
   \                     ??strncpy_0:
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return
    307          }
    308          
    309          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    310          int
    311          strcmp (const char *s1, const char *s2)
    312          {
   \                     strcmp:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    313              /* No checks for NULL */
    314              char *s1p = (char *)s1;
   \   00000004   0x0010             MOVS     R0,R2
    315              char *s2p = (char *)s2;
   \   00000006   0x000B             MOVS     R3,R1
    316          
    317              while (*s2p != '\0')
   \                     ??strcmp_0:
   \   00000008   0x781C             LDRB     R4,[R3, #+0]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??strcmp_1
    318              {
    319                  if (*s1p != *s2p)
   \   0000000E   0x7804             LDRB     R4,[R0, #+0]
   \   00000010   0x781D             LDRB     R5,[R3, #+0]
   \   00000012   0x42AC             CMP      R4,R5
   \   00000014   0xD102             BNE.N    ??strcmp_1
    320                      break;
    321          
    322                  ++s1p;
   \                     ??strcmp_2:
   \   00000016   0x1C40             ADDS     R0,R0,#+1
    323                  ++s2p;
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \   0000001A   0xE7F5             B.N      ??strcmp_0
    324              }
    325              return (*s1p - *s2p);
   \                     ??strcmp_1:
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x781B             LDRB     R3,[R3, #+0]
   \   00000020   0x1AC0             SUBS     R0,R0,R3
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
    326          }
    327          
    328          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          int
    330          strncmp (const char *s1, const char *s2, int n)
    331          {
   \                     strncmp:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    332              /* No checks for NULL */
    333              char *s1p = (char *)s1;
   \   00000004   0x001C             MOVS     R4,R3
    334              char *s2p = (char *)s2;
   \   00000006   0x000D             MOVS     R5,R1
    335          
    336              if (n <= 0)
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xDA01             BGE.N    ??strncmp_0
    337                  return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??strncmp_1
    338          
    339              while (*s2p != '\0')
   \                     ??strncmp_0:
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD009             BEQ.N    ??strncmp_2
    340              {
    341                  if (*s1p != *s2p)
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x782E             LDRB     R6,[R5, #+0]
   \   0000001A   0x42B0             CMP      R0,R6
   \   0000001C   0xD105             BNE.N    ??strncmp_2
    342                      break;
    343          
    344                  if (--n == 0)
   \                     ??strncmp_3:
   \   0000001E   0x1E52             SUBS     R2,R2,#+1
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD002             BEQ.N    ??strncmp_2
    345                      break;
    346          
    347                  ++s1p;
   \                     ??strncmp_4:
   \   00000024   0x1C64             ADDS     R4,R4,#+1
    348                  ++s2p;
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \   00000028   0xE7F2             B.N      ??strncmp_0
    349              }
    350              return (*s1p - *s2p);
   \                     ??strncmp_2:
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x782C             LDRB     R4,[R5, #+0]
   \   0000002E   0x1B00             SUBS     R0,R0,R4
   \                     ??strncmp_1:
   \   00000030   0xBC70             POP      {R4-R6}
   \   00000032   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          void *
    355          memcpy (void *dest, const void *src, unsigned n)
    356          {
   \                     memcpy:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    357              int longs, bytes;
    358              uint32 *dpl = (uint32 *)dest;
   \   00000002   0x0004             MOVS     R4,R0
    359              uint32 *spl = (uint32 *)src;
   \   00000004   0x000D             MOVS     R5,R1
    360              uint8  *dpb, *spb;
    361          
    362              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD027             BEQ.N    ??memcpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD025             BEQ.N    ??memcpy_0
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD023             BEQ.N    ??memcpy_0
    363              {
    364                  bytes = (n & 0x3);
   \   00000012   0xF012 0x0E03      ANDS     LR,R2,#0x3
   \   00000016   0x4673             MOV      R3,LR
    365                  longs = (n - bytes) >> 2;
   \   00000018   0xEBB2 0x0E03      SUBS     LR,R2,R3
   \   0000001C   0xEA5F 0x0E9E      LSRS     LR,LR,#+2
   \   00000020   0x46F4             MOV      R12,LR
    366              
    367                  while (longs--)
   \                     ??memcpy_1:
   \   00000022   0x46E6             MOV      LR,R12
   \   00000024   0xF1BE 0x0C01      SUBS     R12,LR,#+1
   \   00000028   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000002C   0xD006             BEQ.N    ??memcpy_2
    368                      *dpl++ = *spl++;
   \   0000002E   0xF8D5 0xE000      LDR      LR,[R5, #+0]
   \   00000032   0xF8C4 0xE000      STR      LR,[R4, #+0]
   \   00000036   0x1D2D             ADDS     R5,R5,#+4
   \   00000038   0x1D24             ADDS     R4,R4,#+4
   \   0000003A   0xE7F2             B.N      ??memcpy_1
    369                  
    370                  dpb = (uint8 *)dpl;
   \                     ??memcpy_2:
   \   0000003C   0x0026             MOVS     R6,R4
    371                  spb = (uint8 *)spl;
   \   0000003E   0x002F             MOVS     R7,R5
    372                  
    373                  while (bytes--)
   \                     ??memcpy_3:
   \   00000040   0x469E             MOV      LR,R3
   \   00000042   0xF1BE 0x0301      SUBS     R3,LR,#+1
   \   00000046   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000004A   0xD006             BEQ.N    ??memcpy_0
    374                      *dpb++ = *spb++;
   \   0000004C   0xF897 0xE000      LDRB     LR,[R7, #+0]
   \   00000050   0xF886 0xE000      STRB     LR,[R6, #+0]
   \   00000054   0x1C7F             ADDS     R7,R7,#+1
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \   00000058   0xE7F2             B.N      ??memcpy_3
    375              }
    376              return dest;
   \                     ??memcpy_0:
   \   0000005A   0xBDF0             POP      {R4-R7,PC}       ;; return
    377          }
    378          
    379          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          void *
    381          memset (void *s, int c, unsigned n)
    382          {
   \                     memset:
   \   00000000   0xB410             PUSH     {R4}
    383              /* Not optimized, but very portable */
    384              unsigned char *sp = (unsigned char *)s;
   \   00000002   0x0003             MOVS     R3,R0
    385          
    386              if ((s != NULL) && (n > 0))
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??memset_0
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD006             BEQ.N    ??memset_0
    387              {
    388                  while (n--)
   \                     ??memset_1:
   \   0000000C   0x0014             MOVS     R4,R2
   \   0000000E   0x1E62             SUBS     R2,R4,#+1
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD002             BEQ.N    ??memset_0
    389                  {
    390                      *sp++ = (unsigned char)c;
   \   00000014   0x7019             STRB     R1,[R3, #+0]
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \   00000018   0xE7F8             B.N      ??memset_1
    391                  }
    392              }
    393              return s;
   \                     ??memset_0:
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    394          }
    395          
    396          /****************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  isalnum
        0  isdigit
        0  isspace
        0  isupper
       20  memcpy
        4  memset
        8  strcasecmp
       24  strcat
             24 -> strlen
        8  strcmp
        4  strcpy
        0  strlen
       16  strncasecmp
       24  strncat
             24 -> strlen
       12  strncmp
        8  strncpy
       40  strtoul
             40 -> isalnum
             40 -> isdigit
             40 -> isspace
             40 -> isupper


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      34  isalnum
      18  isdigit
      18  isspace
      18  isupper
      92  memcpy
      30  memset
      78  strcasecmp
      50  strcat
      38  strcmp
      38  strcpy
      32  strlen
      84  strncasecmp
      72  strncat
      52  strncmp
      50  strncpy
     262  strtoul

 
 966 bytes in section .text
 
 966 bytes of CODE memory

Errors: none
Warnings: none
