###############################################################################
#                                                                             #
#                                                       08/Jul/2014  15:37:31 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\com #
#                    mon\uif.c                                                #
#    Command line =  "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\com #
#                    mon\uif.c" -D IAR -D TWR_K60N512 -lCN                    #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -lB             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -o              #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\" --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config              #
#                    C:\IAR\arm\INC\c\DLib_Config_Normal.h -I                 #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\projects\hello_world\" -I    #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\common\" -I                  #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\" -I                     #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\headers\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\adc16\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\enet\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\pmc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\rtc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\lptmr\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\uart\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\mcg\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\wdog\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\platforms\" -I               #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\ftm\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\SPI\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\OLED\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\" -Ol --use_c++_inline                 #
#    List file    =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\uif.lst           #
#    Object file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\uif.o              #
#                                                                             #
#                                                                             #
###############################################################################

E:\完成设计的产品\K60资料\OLED资料 (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\common\uif.c
      1          /*
      2           * File:    uif.c
      3           * Purpose: Provide an interactive user interface
      4           *              
      5           * Notes:   The commands, set/show parameters, and prompt are configured 
      6           *          at the project level
      7           */
      8          
      9          #include "common.h"
     10          #include "uif.h"
     11          
     12          /********************************************************************/
     13          /*
     14           * Global messages -- constant strings
     15           */

   \                                 In section .rodata, align 4
     16          const char HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     17              "Enter 'help' for help.\n";
     18          

   \                                 In section .rodata, align 4
     19          const char INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     20              "Error: Invalid argument: %s\n";
     21          

   \                                 In section .rodata, align 4
     22          const char INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     23              "Error: Invalid value: %s\n";
     24          
     25          /*
     26           * Strings used by this file only
     27           */

   \                                 In section .rodata, align 4
     28          static const char INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     29              "Error: No such command: %s\n";
     30          

   \                                 In section .rodata, align 4
     31          static const char HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     32              "%8s  %-25s %s %s\n";
     33          

   \                                 In section .rodata, align 4
     34          static const char SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     35              "Error: Invalid syntax for: %s\n";
     36          

   \                                 In section .rodata, align 4
     37          static const char INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     38              "Error:  Invalid set/show option: %s\n";
     39          

   \                                 In section .rodata, align 4
     40          static const char OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     41              "%12s: ";
     42          

   \                                 In section .bss, align 4
     43          static char cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
     44          static char cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
     45          
     46          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     47          char *
     48          get_line (char *line)
     49          {
   \                     get_line:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     50              int pos;
     51              int ch;
     52          
     53              pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     54              ch = (int)in_char();
   \   00000006   0x.... 0x....      BL       in_char
   \   0000000A   0xE00D             B.N      ??get_line_0
     55              while ( (ch != 0x0D /* CR */) &&
     56                      (ch != 0x0A /* LF/NL */) &&
     57                      (pos < UIF_MAX_LINE))
     58              {
     59                  switch (ch)
     60                  {
     61                      case 0x08:      /* Backspace */
     62                      case 0x7F:      /* Delete */
     63                          if (pos > 0)
     64                          {
     65                              pos -= 1;
     66                              out_char(0x08);    /* backspace */
     67                              out_char(' ');
     68                              out_char(0x08);    /* backspace */
     69                          }
     70                          break;
     71                      default:
     72                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1:
   \   0000000C   0x1C69             ADDS     R1,R5,#+1
   \   0000000E   0x2950             CMP      R1,#+80
   \   00000010   0xDA08             BGE.N    ??get_line_2
     73                          {
     74                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000012   0xF1B0 0x0120      SUBS     R1,R0,#+32
   \   00000016   0x2960             CMP      R1,#+96
   \   00000018   0xD204             BCS.N    ??get_line_2
     75                              {
     76                                  line[pos++] = (char)ch;
   \   0000001A   0x5528             STRB     R0,[R5, R4]
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
     77                                  out_char((char)ch);
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       out_char
     78                              }
     79                          }
     80                          break;
     81                  }
     82                  ch = (int)in_char();
   \                     ??get_line_2:
   \                     ??get_line_3:
   \   00000024   0x.... 0x....      BL       in_char
   \                     ??get_line_0:
   \   00000028   0x280D             CMP      R0,#+13
   \   0000002A   0xD015             BEQ.N    ??get_line_4
   \   0000002C   0x280A             CMP      R0,#+10
   \   0000002E   0xD013             BEQ.N    ??get_line_4
   \   00000030   0x2D50             CMP      R5,#+80
   \   00000032   0xDA11             BGE.N    ??get_line_4
   \   00000034   0x0001             MOVS     R1,R0
   \   00000036   0x2908             CMP      R1,#+8
   \   00000038   0xD001             BEQ.N    ??get_line_5
   \   0000003A   0x297F             CMP      R1,#+127
   \   0000003C   0xD1E6             BNE.N    ??get_line_1
   \                     ??get_line_5:
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xDB09             BLT.N    ??get_line_6
   \   00000042   0x1E6D             SUBS     R5,R5,#+1
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x.... 0x....      BL       out_char
   \   0000004A   0x2020             MOVS     R0,#+32
   \   0000004C   0x.... 0x....      BL       out_char
   \   00000050   0x2008             MOVS     R0,#+8
   \   00000052   0x.... 0x....      BL       out_char
   \                     ??get_line_6:
   \   00000056   0xE7E5             B.N      ??get_line_3
     83              }
     84              line[pos] = '\0';
   \                     ??get_line_4:
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x5528             STRB     R0,[R5, R4]
     85              out_char(0x0D);    /* CR */
   \   0000005C   0x200D             MOVS     R0,#+13
   \   0000005E   0x.... 0x....      BL       out_char
     86              out_char(0x0A);    /* LF */
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0x.... 0x....      BL       out_char
     87          
     88              return line;
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     89          }
     90          
     91          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          int
     93          make_argv (char *cmdline, char *argv[])
     94          {
   \                     make_argv:
   \   00000000   0xB430             PUSH     {R4,R5}
     95              int argc, i, in_text;
     96          
     97              /* 
     98               * Break cmdline into strings and argv
     99               * It is permissible for argv to be NULL, in which case
    100               * the purpose of this routine becomes to count args
    101               */
    102              argc = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    103              i = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    104              in_text = FALSE;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0xE005             B.N      ??make_argv_0
    105              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    106              {
    107                  if (((cmdline[i] == ' ')   ||
    108                       (cmdline[i] == '\t')) )
    109                  {
    110                      if (in_text)
   \                     ??make_argv_1:
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD002             BEQ.N    ??make_argv_2
    111                      {
    112                          /* end of command line argument */
    113                          cmdline[i] = '\0';
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x541C             STRB     R4,[R3, R0]
    114                          in_text = FALSE;
   \   00000012   0x2400             MOVS     R4,#+0
    115                      }
    116                      else
    117                      {
    118                          /* still looking for next argument */
    119                          
    120                      }
    121                  }
    122                  else
    123                  {
    124                      /* got non-whitespace character */
    125                      if (in_text)
    126                      {
    127                      }
    128                      else
    129                      {
    130                          /* start of an argument */
    131                          in_text = TRUE;
    132                          if (argc < UIF_MAX_ARGS)
    133                          {
    134                              if (argv != NULL)
    135                                  argv[argc] = &cmdline[i];
    136                              argc++;
    137                          }
    138                          else
    139                              /*return argc;*/
    140                              break;
    141                      }
    142          
    143                  }
    144                  i++;    /* proceed to next character */
   \                     ??make_argv_2:
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \                     ??make_argv_0:
   \   00000016   0x5C1D             LDRB     R5,[R3, R0]
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD011             BEQ.N    ??make_argv_3
   \   0000001C   0x5C1D             LDRB     R5,[R3, R0]
   \   0000001E   0x2D20             CMP      R5,#+32
   \   00000020   0xD0F3             BEQ.N    ??make_argv_1
   \   00000022   0x5C1D             LDRB     R5,[R3, R0]
   \   00000024   0x2D09             CMP      R5,#+9
   \   00000026   0xD0F0             BEQ.N    ??make_argv_1
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD1F3             BNE.N    ??make_argv_2
   \   0000002C   0x2401             MOVS     R4,#+1
   \   0000002E   0x2A0A             CMP      R2,#+10
   \   00000030   0xDA06             BGE.N    ??make_argv_4
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD002             BEQ.N    ??make_argv_5
   \   00000036   0x181D             ADDS     R5,R3,R0
   \   00000038   0xF841 0x5022      STR      R5,[R1, R2, LSL #+2]
   \                     ??make_argv_5:
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   \   0000003E   0xE7E9             B.N      ??make_argv_2
    145              }
    146              if (argv != NULL)
   \                     ??make_argv_4:
   \                     ??make_argv_3:
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD002             BEQ.N    ??make_argv_6
    147                  argv[argc] = NULL;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    148              return argc;
   \                     ??make_argv_6:
   \   0000004A   0x0010             MOVS     R0,R2
   \   0000004C   0xBC30             POP      {R4,R5}
   \   0000004E   0x4770             BX       LR               ;; return
    149          }
    150          
    151          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    152          void
    153          run_cmd (void)
    154          {
   \                     run_cmd:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    155              /*
    156               * Global array of pointers to emulate C argc,argv interface
    157               */
    158              int argc;
    159              char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    160          
    161              get_line(cmdline1);
   \   00000004   0x....             LDR.N    R0,??DataTable3_3
   \   00000006   0x.... 0x....      BL       get_line
    162          
    163              if (!(argc = make_argv(cmdline1,argv)))
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x....             LDR.N    R0,??DataTable3_3
   \   0000000E   0x.... 0x....      BL       make_argv
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD108             BNE.N    ??run_cmd_0
    164              {
    165                  /* no command entered, just a blank line */
    166                  strcpy(cmdline1,cmdline2);
   \   00000018   0x....             LDR.N    R1,??DataTable3_4
   \   0000001A   0x....             LDR.N    R0,??DataTable3_3
   \   0000001C   0x.... 0x....      BL       strcpy
    167                  argc = make_argv(cmdline1,argv);
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x....             LDR.N    R0,??DataTable3_3
   \   00000024   0x.... 0x....      BL       make_argv
   \   00000028   0x0004             MOVS     R4,R0
    168              }
    169              cmdline2[0] = '\0';
   \                     ??run_cmd_0:
   \   0000002A   0x....             LDR.N    R0,??DataTable3_4
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    170          
    171              if (argc)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD040             BEQ.N    ??run_cmd_1
    172              {
    173                  int i;
    174                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE000             B.N      ??run_cmd_2
   \                     ??run_cmd_3:
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??run_cmd_2:
   \   0000003A   0x....             LDR.N    R0,??DataTable3_5
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xDA32             BGE.N    ??run_cmd_4
    175                  {
    176                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x201C             MOVS     R0,#+28
   \   00000046   0x....             LDR.N    R2,??DataTable3_6
   \   00000048   0xFB00 0x2005      MLA      R0,R0,R5,R2
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       strcasecmp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1F0             BNE.N    ??run_cmd_3
    177                      {
    178                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    179                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   00000056   0x1E60             SUBS     R0,R4,#+1
   \   00000058   0x211C             MOVS     R1,#+28
   \   0000005A   0x....             LDR.N    R2,??DataTable3_6
   \   0000005C   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   00000060   0x6849             LDR      R1,[R1, #+4]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xDB1B             BLT.N    ??run_cmd_5
   \   00000066   0x201C             MOVS     R0,#+28
   \   00000068   0x....             LDR.N    R1,??DataTable3_6
   \   0000006A   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000006E   0x6880             LDR      R0,[R0, #+8]
   \   00000070   0x1E61             SUBS     R1,R4,#+1
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xDB13             BLT.N    ??run_cmd_5
    180                          {
    181                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   00000076   0x201C             MOVS     R0,#+28
   \   00000078   0x....             LDR.N    R1,??DataTable3_6
   \   0000007A   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000007E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000080   0x07C0             LSLS     R0,R0,#+31
   \   00000082   0xD503             BPL.N    ??run_cmd_6
    182                              {
    183                                  strcpy(cmdline2,argv[0]);
   \   00000084   0x9900             LDR      R1,[SP, #+0]
   \   00000086   0x....             LDR.N    R0,??DataTable3_4
   \   00000088   0x.... 0x....      BL       strcpy
    184                              }
    185                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6:
   \   0000008C   0xA900             ADD      R1,SP,#+0
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x221C             MOVS     R2,#+28
   \   00000092   0x....             LDR.N    R3,??DataTable3_6
   \   00000094   0xFB02 0x3205      MLA      R2,R2,R5,R3
   \   00000098   0x6912             LDR      R2,[R2, #+16]
   \   0000009A   0x4790             BLX      R2
    186                              return;
   \   0000009C   0xE00B             B.N      ??run_cmd_7
    187                          }
    188                          else
    189                          {
    190                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5:
   \   0000009E   0x9900             LDR      R1,[SP, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable3_7
   \   000000A2   0x.... 0x....      BL       printf
    191                              return;
   \   000000A6   0xE006             B.N      ??run_cmd_7
    192                          }
    193                      }
    194                  }
    195                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4:
   \   000000A8   0x9900             LDR      R1,[SP, #+0]
   \   000000AA   0x....             LDR.N    R0,??DataTable3_8
   \   000000AC   0x.... 0x....      BL       printf
    196                  printf(HELPMSG);
   \   000000B0   0x....             LDR.N    R0,??DataTable3_9
   \   000000B2   0x.... 0x....      BL       printf
    197              }
    198          }
   \                     ??run_cmd_1:
   \                     ??run_cmd_7:
   \   000000B6   0xB00B             ADD      SP,SP,#+44
   \   000000B8   0xBD30             POP      {R4,R5,PC}       ;; return
    199          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    200          uint32
    201          get_value (char *s, int *success, int base)
    202          {
   \                     get_value:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    203              uint32 value;
    204              char *p;
    205          
    206              value = strtoul(s,&p,base);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       strtoul
    207              if ((value == 0) && (p == s))
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD106             BNE.N    ??get_value_0
   \   00000012   0x9900             LDR      R1,[SP, #+0]
   \   00000014   0x42A1             CMP      R1,R4
   \   00000016   0xD103             BNE.N    ??get_value_0
    208              {
    209                  *success = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    210                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE001             B.N      ??get_value_1
    211              }
    212              else
    213              {
    214                  *success = TRUE;
   \                     ??get_value_0:
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x6029             STR      R1,[R5, #+0]
    215                  return value;
   \                     ??get_value_1:
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    216              }
    217          }
    218          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    219          void
    220          uif_cmd_help (int argc, char **argv)
    221          {
   \                     uif_cmd_help:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    222              int index;
    223              
    224              (void)argc;
    225              (void)argv;
    226              
    227              printf("\n");
   \   00000004   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000006   0x.... 0x....      BL       printf
    228              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xE018             B.N      ??uif_cmd_help_0
    229              {
    230                  printf(HELPFORMAT,
    231                      UIF_CMDTAB[index].cmd,
    232                      UIF_CMDTAB[index].description,
    233                      UIF_CMDTAB[index].cmd,
    234                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1:
   \   0000000E   0x201C             MOVS     R0,#+28
   \   00000010   0x....             LDR.N    R1,??DataTable3_6
   \   00000012   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x201C             MOVS     R0,#+28
   \   0000001C   0x....             LDR.N    R1,??DataTable3_6
   \   0000001E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0x201C             MOVS     R0,#+28
   \   00000026   0x....             LDR.N    R1,??DataTable3_6
   \   00000028   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002C   0x6942             LDR      R2,[R0, #+20]
   \   0000002E   0x201C             MOVS     R0,#+28
   \   00000030   0x....             LDR.N    R1,??DataTable3_6
   \   00000032   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x....             LDR.N    R0,??DataTable3_10
   \   0000003A   0x.... 0x....      BL       printf
    235              }
   \   0000003E   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_help_0:
   \   00000040   0x....             LDR.N    R0,??DataTable3_5
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xDBE2             BLT.N    ??uif_cmd_help_1
    236              printf("\n");
   \   00000048   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000004A   0x.... 0x....      BL       printf
    237          }
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    238          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    239          void
    240          uif_cmd_set (int argc, char **argv)
    241          {
   \                     uif_cmd_set:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
    242              int index;
    243          
    244              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    245              if (argc == 1)
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD11D             BNE.N    ??uif_cmd_set_0
    246              {
    247                  printf("Valid 'set' options:\n");
   \   00000010   0x....             LDR.N    R0,??DataTable3_11
   \   00000012   0x.... 0x....      BL       printf
    248                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0xE010             B.N      ??uif_cmd_set_1
    249                  {
    250                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2:
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0x....             LDR.N    R1,??DataTable3_12
   \   0000001E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x....             LDR.N    R0,??DataTable3_13
   \   00000026   0x.... 0x....      BL       printf
    251                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   0000002A   0x2014             MOVS     R0,#+20
   \   0000002C   0x....             LDR.N    R1,??DataTable3_12
   \   0000002E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000032   0x6901             LDR      R1,[R0, #+16]
   \   00000034   0x....             ADR.N    R0,??DataTable3_1  ;; "%s\n"
   \   00000036   0x.... 0x....      BL       printf
    252                  }
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_1:
   \   0000003C   0x....             LDR.N    R0,??DataTable3_14
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xDBEA             BLT.N    ??uif_cmd_set_2
    253                  printf("\n");
   \   00000044   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000046   0x.... 0x....      BL       printf
    254                  return;
   \   0000004A   0xE038             B.N      ??uif_cmd_set_3
    255              }
    256          
    257              if (argc != 3)
   \                     ??uif_cmd_set_0:
   \   0000004C   0x2D03             CMP      R5,#+3
   \   0000004E   0xD003             BEQ.N    ??uif_cmd_set_4
    258              {
    259                  printf("Error: Invalid argument list\n");
   \   00000050   0x....             LDR.N    R0,??DataTable3_15
   \   00000052   0x.... 0x....      BL       printf
    260                  return;
   \   00000056   0xE032             B.N      ??uif_cmd_set_3
    261              }
    262          
    263              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4:
   \   00000058   0x2400             MOVS     R4,#+0
   \   0000005A   0xE000             B.N      ??uif_cmd_set_5
   \                     ??uif_cmd_set_6:
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_5:
   \   0000005E   0x....             LDR.N    R0,??DataTable3_14
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xDA27             BGE.N    ??uif_cmd_set_7
    264              {
    265                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000066   0x6871             LDR      R1,[R6, #+4]
   \   00000068   0x2014             MOVS     R0,#+20
   \   0000006A   0x....             LDR.N    R2,??DataTable3_12
   \   0000006C   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x.... 0x....      BL       strcasecmp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD1F0             BNE.N    ??uif_cmd_set_6
    266                  {
    267                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    268                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   0000007A   0x1EA8             SUBS     R0,R5,#+2
   \   0000007C   0x2114             MOVS     R1,#+20
   \   0000007E   0x....             LDR.N    R2,??DataTable3_12
   \   00000080   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000084   0x6849             LDR      R1,[R1, #+4]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDB10             BLT.N    ??uif_cmd_set_8
   \   0000008A   0x2014             MOVS     R0,#+20
   \   0000008C   0x....             LDR.N    R1,??DataTable3_12
   \   0000008E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000092   0x6880             LDR      R0,[R0, #+8]
   \   00000094   0x1EA9             SUBS     R1,R5,#+2
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xDB08             BLT.N    ??uif_cmd_set_8
    269                      {
    270                          UIF_SETCMDTAB[index].func(argc,argv);
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x2214             MOVS     R2,#+20
   \   000000A0   0x....             LDR.N    R3,??DataTable3_12
   \   000000A2   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   000000A6   0x68D2             LDR      R2,[R2, #+12]
   \   000000A8   0x4790             BLX      R2
    271                          return;
   \   000000AA   0xE008             B.N      ??uif_cmd_set_3
    272                      }
    273                      else
    274                      {
    275                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8:
   \   000000AC   0x6871             LDR      R1,[R6, #+4]
   \   000000AE   0x....             LDR.N    R0,??DataTable3_16
   \   000000B0   0x.... 0x....      BL       printf
    276                          return;
   \   000000B4   0xE003             B.N      ??uif_cmd_set_3
    277                      }
    278                  }
    279              }
    280              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7:
   \   000000B6   0x6871             LDR      R1,[R6, #+4]
   \   000000B8   0x....             LDR.N    R0,??DataTable3_17
   \   000000BA   0x.... 0x....      BL       printf
    281          }
   \                     ??uif_cmd_set_3:
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
    282          
    283          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    284          void
    285          uif_cmd_show (int argc, char **argv)
    286          {
   \                     uif_cmd_show:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    287              int index;
    288          
    289              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    290              if (argc == 1)
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD120             BNE.N    ??uif_cmd_show_0
    291              {
    292                  /*
    293                   * Show all Option settings
    294                   */
    295                  argc = 2;
   \   00000010   0x2502             MOVS     R5,#+2
    296                  argv[2] = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    297                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0xE013             B.N      ??uif_cmd_show_1
    298                  {
    299                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2:
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0x....             LDR.N    R1,??DataTable3_12
   \   0000001E   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x....             LDR.N    R0,??DataTable3_13
   \   00000026   0x.... 0x....      BL       printf
    300                      UIF_SETCMDTAB[index].func(argc,argv);
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x2214             MOVS     R2,#+20
   \   00000030   0x....             LDR.N    R3,??DataTable3_12
   \   00000032   0xFB02 0x3206      MLA      R2,R2,R6,R3
   \   00000036   0x68D2             LDR      R2,[R2, #+12]
   \   00000038   0x4790             BLX      R2
    301                      printf("\n");
   \   0000003A   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000003C   0x.... 0x....      BL       printf
    302                  }
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_1:
   \   00000042   0x....             LDR.N    R0,??DataTable3_14
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x4286             CMP      R6,R0
   \   00000048   0xDBE7             BLT.N    ??uif_cmd_show_2
    303                  printf("\n");
   \   0000004A   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000004C   0x.... 0x....      BL       printf
    304                  return;
   \   00000050   0xE03D             B.N      ??uif_cmd_show_3
    305              }
    306          
    307              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0:
   \   00000052   0x2600             MOVS     R6,#+0
   \   00000054   0xE000             B.N      ??uif_cmd_show_4
   \                     ??uif_cmd_show_5:
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_4:
   \   00000058   0x....             LDR.N    R0,??DataTable3_14
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x4286             CMP      R6,R0
   \   0000005E   0xDA32             BGE.N    ??uif_cmd_show_6
    308              {
    309                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000060   0x6861             LDR      R1,[R4, #+4]
   \   00000062   0x2014             MOVS     R0,#+20
   \   00000064   0x....             LDR.N    R2,??DataTable3_12
   \   00000066   0xFB00 0x2006      MLA      R0,R0,R6,R2
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       strcasecmp
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1F0             BNE.N    ??uif_cmd_show_5
    310                  {
    311                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    312                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000074   0x1EA8             SUBS     R0,R5,#+2
   \   00000076   0x2114             MOVS     R1,#+20
   \   00000078   0x....             LDR.N    R2,??DataTable3_12
   \   0000007A   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   0000007E   0x6849             LDR      R1,[R1, #+4]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xDB1B             BLT.N    ??uif_cmd_show_7
   \   00000084   0x2014             MOVS     R0,#+20
   \   00000086   0x....             LDR.N    R1,??DataTable3_12
   \   00000088   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000008C   0x6880             LDR      R0,[R0, #+8]
   \   0000008E   0x1EA9             SUBS     R1,R5,#+2
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xDB13             BLT.N    ??uif_cmd_show_7
    313                      {
    314                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000094   0x2014             MOVS     R0,#+20
   \   00000096   0x....             LDR.N    R1,??DataTable3_12
   \   00000098   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0x....             LDR.N    R0,??DataTable3_13
   \   000000A0   0x.... 0x....      BL       printf
    315                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000A4   0x0021             MOVS     R1,R4
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0x2214             MOVS     R2,#+20
   \   000000AA   0x....             LDR.N    R3,??DataTable3_12
   \   000000AC   0xFB02 0x3206      MLA      R2,R2,R6,R3
   \   000000B0   0x68D2             LDR      R2,[R2, #+12]
   \   000000B2   0x4790             BLX      R2
    316                          printf("\n\n");
   \   000000B4   0x....             ADR.N    R0,??DataTable3_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000B6   0x.... 0x....      BL       printf
    317                          return;
   \   000000BA   0xE008             B.N      ??uif_cmd_show_3
    318                      }
    319                      else
    320                      {
    321                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7:
   \   000000BC   0x6861             LDR      R1,[R4, #+4]
   \   000000BE   0x....             LDR.N    R0,??DataTable3_16
   \   000000C0   0x.... 0x....      BL       printf
    322                          return;
   \   000000C4   0xE003             B.N      ??uif_cmd_show_3
    323                      }
    324                  }
    325              }
    326              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6:
   \   000000C6   0x6861             LDR      R1,[R4, #+4]
   \   000000C8   0x....             LDR.N    R0,??DataTable3_17
   \   000000CA   0x.... 0x....      BL       printf
    327          }
   \                     ??uif_cmd_show_3:
   \   000000CE   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     `?<Constant "Valid \\'set\\' options:\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x........         DC32     `?<Constant "Error: Invalid argume...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x........         DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x........         DC32     INVOPT

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     `?<Constant "Valid \\'set\\' options:\\n">`:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Error: Invalid argume...">`:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    328          
    329          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  get_line
             16 -> in_char
             16 -> out_char
       16  get_value
             16 -> strtoul
        8  make_argv
       56  run_cmd
             56 -- Indirect call
             56 -> get_line
             56 -> make_argv
             56 -> printf
             56 -> strcasecmp
             56 -> strcpy
       16  uif_cmd_help
             16 -> printf
       16  uif_cmd_set
             16 -- Indirect call
             16 -> printf
             16 -> strcasecmp
       16  uif_cmd_show
             16 -- Indirect call
             16 -> printf
             16 -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "%s\n">
      32  ?<Constant "Error: Invalid argume...">
      24  ?<Constant "Valid \'set\' options:\n">
       2  ?<Constant "\n">
       4  ?<Constant "\n\n">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     108  get_line
      38  get_value
      80  make_argv
     186  run_cmd
      80  uif_cmd_help
     192  uif_cmd_set
     208  uif_cmd_show

 
 160 bytes in section .bss
 278 bytes in section .rodata
 964 bytes in section .text
 
 964 bytes of CODE  memory
 278 bytes of CONST memory
 160 bytes of DATA  memory

Errors: none
Warnings: none
