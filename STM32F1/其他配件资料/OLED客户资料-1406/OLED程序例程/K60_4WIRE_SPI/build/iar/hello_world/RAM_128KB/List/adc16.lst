###############################################################################
#                                                                             #
#                                                       07/May/2014  16:38:56 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\adc16\adc16.c                         #
#    Command line =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\adc16\adc16.c -D IAR -D TWR_K60N512   #
#                    -lCN C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\RAM_128KB\List\ -lB    #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -o          #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\ --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.0           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\projects\hello #
#                    _world\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kin #
#                    etisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\com #
#                    mon\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\headers #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\a #
#                    dc16\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kinet #
#                    isK60_Demo_OLED\build\iar\hello_world\..\..\..\src\drive #
#                    rs\enet\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Ki #
#                    netisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\dr #
#                    ivers\pmc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\ #
#                    KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\ #
#                    drivers\rtc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³ #
#                    Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\sr #
#                    c\drivers\lptmr\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐ #
#                    òÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\. #
#                    .\src\drivers\uart\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\ #
#                    ³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\. #
#                    .\..\src\drivers\mcg\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁ #
#                    Ï\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\.. #
#                    \..\..\src\drivers\wdog\ -I                              #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\platforms\ -I  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\drivers\ftm\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\SPI #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\O #
#                    LED\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\ -On             #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\adc16.lst    #
#    Object file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\adc16.o       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\src\drivers\adc16\adc16.c
      1          /*
      2           * File:		a16dc.c
      3           * Purpose:		Simple Driver or API for AdC16/PGA
      4           * This file contains the following two functions:
      5           *  1. ADC_Cal: calibrates the ADC
      6           *  2. ADC_Config_Alt: Simply configures an ADC per a structure
      7           *
      8           * Typical usage: Fill the structure with the ADC and PGA register contents 
      9           * needed for the ADC usage.
     10          
     11           * a) Call the ADC_Config_Alt function to configure an ADC, (ADC0 or ADC1)
     12           * b) Call the ADC_Cal function to calibrate that ADC
     13           * c) Call the ADC_Config_Alt function again to restore desired configuation
     14           *    after a calibration
     15           *
     16           *
     17           */
     18          
     19          #include "common.h"
     20          #include "adc16.h"
     21          
     22          
     23          
     24          
     25          /******************************************************************************
     26          Function 1. Name	AUTO CAL ROUTINE   
     27          
     28          Parameters		ADC module pointer points to adc0 or adc1 register map 
     29                                   base address.
     30          Returns			Zero indicates success.
     31          Notes         		Calibrates the ADC16. Required to meet specifications 
     32                                  after reset and before a conversion is initiated.
     33          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     34          uint8 ADC_Cal(ADC_MemMapPtr adcmap)
     35          {
   \                     ADC_Cal:
   \   00000000   0x0001             MOVS     R1,R0
     36          
     37            unsigned short cal_var;
     38            
     39            ADC_SC2_REG(adcmap) &=  ~ADC_SC2_ADTRG_MASK ; // Enable Software Conversion Trigger for Calibration Process    - ADC0_SC2 = ADC0_SC2 | ADC_SC2_ADTRGW(0);   
   \   00000002   0x6A08             LDR      R0,[R1, #+32]
   \   00000004   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000008   0x6208             STR      R0,[R1, #+32]
     40            ADC_SC3_REG(adcmap) &= ( ~ADC_SC3_ADCO_MASK & ~ADC_SC3_AVGS_MASK ); // set single conversion, clear avgs bitfield for next writing
   \   0000000A   0x6A48             LDR      R0,[R1, #+36]
   \   0000000C   0xF030 0x000B      BICS     R0,R0,#0xB
   \   00000010   0x6248             STR      R0,[R1, #+36]
     41            ADC_SC3_REG(adcmap) |= ( ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(AVGS_32) );  // Turn averaging ON and set at max value ( 32 )
   \   00000012   0x6A48             LDR      R0,[R1, #+36]
   \   00000014   0xF050 0x0007      ORRS     R0,R0,#0x7
   \   00000018   0x6248             STR      R0,[R1, #+36]
     42            
     43            
     44            ADC_SC3_REG(adcmap) |= ADC_SC3_CAL_MASK ;      // Start CAL
   \   0000001A   0x6A48             LDR      R0,[R1, #+36]
   \   0000001C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000020   0x6248             STR      R0,[R1, #+36]
     45            while ( (ADC_SC1_REG(adcmap,A) & ADC_SC1_COCO_MASK ) == COCO_NOT ); // Wait calibration end
   \                     ??ADC_Cal_0:
   \   00000022   0x6808             LDR      R0,[R1, #+0]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xD5FC             BPL.N    ??ADC_Cal_0
     46            	
     47            if ((ADC_SC3_REG(adcmap)& ADC_SC3_CALF_MASK) == CALF_FAIL )
   \   00000028   0x6A48             LDR      R0,[R1, #+36]
   \   0000002A   0x0640             LSLS     R0,R0,#+25
   \   0000002C   0xD501             BPL.N    ??ADC_Cal_1
     48            {  
     49             return(1);    // Check for Calibration fail error and return 
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE030             B.N      ??ADC_Cal_2
     50            }
     51            // Calculate plus-side calibration
     52            cal_var = 0x00;
   \                     ??ADC_Cal_1:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0002             MOVS     R2,R0
     53            
     54            cal_var =  ADC_CLP0_REG(adcmap); 
   \   00000036   0x6CC8             LDR      R0,[R1, #+76]
   \   00000038   0x0002             MOVS     R2,R0
     55            cal_var += ADC_CLP1_REG(adcmap);
   \   0000003A   0x6C88             LDR      R0,[R1, #+72]
   \   0000003C   0x1882             ADDS     R2,R0,R2
     56            cal_var += ADC_CLP2_REG(adcmap);
   \   0000003E   0x6C48             LDR      R0,[R1, #+68]
   \   00000040   0x1882             ADDS     R2,R0,R2
     57            cal_var += ADC_CLP3_REG(adcmap);
   \   00000042   0x6C08             LDR      R0,[R1, #+64]
   \   00000044   0x1882             ADDS     R2,R0,R2
     58            cal_var += ADC_CLP4_REG(adcmap);
   \   00000046   0x6BC8             LDR      R0,[R1, #+60]
   \   00000048   0x1882             ADDS     R2,R0,R2
     59            cal_var += ADC_CLPS_REG(adcmap);
   \   0000004A   0x6B88             LDR      R0,[R1, #+56]
   \   0000004C   0x1882             ADDS     R2,R0,R2
     60          
     61            cal_var = cal_var/2;
   \   0000004E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0xFB92 0xF2F0      SDIV     R2,R2,R0
     62            cal_var |= 0x8000; // Set MSB
   \   00000056   0xF452 0x4200      ORRS     R2,R2,#0x8000
     63          
     64            ADC_PG_REG(adcmap) = ADC_PG_PG(cal_var);
   \   0000005A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005C   0x62CA             STR      R2,[R1, #+44]
     65           
     66          
     67            // Calculate minus-side calibration
     68            cal_var = 0x00;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x0002             MOVS     R2,R0
     69          
     70            cal_var =  ADC_CLM0_REG(adcmap); 
   \   00000062   0x6EC8             LDR      R0,[R1, #+108]
   \   00000064   0x0002             MOVS     R2,R0
     71            cal_var += ADC_CLM1_REG(adcmap);
   \   00000066   0x6E88             LDR      R0,[R1, #+104]
   \   00000068   0x1882             ADDS     R2,R0,R2
     72            cal_var += ADC_CLM2_REG(adcmap);
   \   0000006A   0x6E48             LDR      R0,[R1, #+100]
   \   0000006C   0x1882             ADDS     R2,R0,R2
     73            cal_var += ADC_CLM3_REG(adcmap);
   \   0000006E   0x6E08             LDR      R0,[R1, #+96]
   \   00000070   0x1882             ADDS     R2,R0,R2
     74            cal_var += ADC_CLM4_REG(adcmap);
   \   00000072   0x6DC8             LDR      R0,[R1, #+92]
   \   00000074   0x1882             ADDS     R2,R0,R2
     75            cal_var += ADC_CLMS_REG(adcmap);
   \   00000076   0x6D88             LDR      R0,[R1, #+88]
   \   00000078   0x1882             ADDS     R2,R0,R2
     76          
     77            cal_var = cal_var/2;
   \   0000007A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0xFB92 0xF2F0      SDIV     R2,R2,R0
     78          
     79            cal_var |= 0x8000; // Set MSB
   \   00000082   0xF452 0x4200      ORRS     R2,R2,#0x8000
     80          
     81            ADC_MG_REG(adcmap) = ADC_MG_MG(cal_var); 
   \   00000086   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000088   0x630A             STR      R2,[R1, #+48]
     82            
     83            ADC_SC3_REG(adcmap) &= ~ADC_SC3_CAL_MASK ; /* Clear CAL bit */
   \   0000008A   0x6A48             LDR      R0,[R1, #+36]
   \   0000008C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000090   0x6248             STR      R0,[R1, #+36]
     84          
     85            return(0);
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??ADC_Cal_2:
   \   00000094   0x4770             BX       LR               ;; return
     86          }
     87          
     88          
     89          
     90          
     91          /******************************************************************************
     92          Function 2 Name 	ADC_Config_Alt 
     93          Parameters		the register values to be set in the adc in a structure
     94          Returns			NONE
     95          Notes         		Configures ADC0 or ADC1 depending on adcmap
     96                                  Prior to calling this function populate the structure
     97                                  elements with the desired ADC configuration.
     98          ******************************************************************************/
     99          
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void ADC_Config_Alt(ADC_MemMapPtr adcmap, tADC_ConfigPtr ADC_CfgPtr)
    102          {
    103           ADC_CFG1_REG(adcmap) = ADC_CfgPtr->CONFIG1;
   \                     ADC_Config_Alt:
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x6082             STR      R2,[R0, #+8]
    104           ADC_CFG2_REG(adcmap) = ADC_CfgPtr->CONFIG2;
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
    105           ADC_CV1_REG(adcmap)  = ADC_CfgPtr->COMPARE1; 
   \   00000008   0x884A             LDRH     R2,[R1, #+2]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
    106           ADC_CV2_REG(adcmap)  = ADC_CfgPtr->COMPARE2;
   \   0000000C   0x888A             LDRH     R2,[R1, #+4]
   \   0000000E   0x61C2             STR      R2,[R0, #+28]
    107           ADC_SC2_REG(adcmap)  = ADC_CfgPtr->STATUS2;
   \   00000010   0x798A             LDRB     R2,[R1, #+6]
   \   00000012   0x6202             STR      R2,[R0, #+32]
    108           ADC_SC3_REG(adcmap)  = ADC_CfgPtr->STATUS3;
   \   00000014   0x79CA             LDRB     R2,[R1, #+7]
   \   00000016   0x6242             STR      R2,[R0, #+36]
    109           ADC_PGA_REG(adcmap)  = ADC_CfgPtr->PGA;
   \   00000018   0x68CA             LDR      R2,[R1, #+12]
   \   0000001A   0x6502             STR      R2,[R0, #+80]
    110           ADC_SC1_REG(adcmap,A)= ADC_CfgPtr->STATUS1A;       
   \   0000001C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    111           ADC_SC1_REG(adcmap,B)= ADC_CfgPtr->STATUS1B;
   \   00000020   0x7A4A             LDRB     R2,[R1, #+9]
   \   00000022   0x6042             STR      R2,[R0, #+4]
    112          }
   \   00000024   0x4770             BX       LR               ;; return
    113          
    114          

   \                                 In section .text, align 2, keep-with-next
    115          void ADC_Read_Cal(ADC_MemMapPtr adcmap, tADC_Cal_Blk *blk)
    116          {
    117            blk->OFS  = ADC_OFS_REG(adcmap);
   \                     ADC_Read_Cal:
   \   00000000   0x6A82             LDR      R2,[R0, #+40]
   \   00000002   0x800A             STRH     R2,[R1, #+0]
    118            blk->PG   = ADC_PG_REG(adcmap); 
   \   00000004   0x6AC2             LDR      R2,[R0, #+44]
   \   00000006   0x804A             STRH     R2,[R1, #+2]
    119            blk->MG   = ADC_MG_REG(adcmap); 
   \   00000008   0x6B02             LDR      R2,[R0, #+48]
   \   0000000A   0x808A             STRH     R2,[R1, #+4]
    120            blk->CLPD = ADC_CLPD_REG(adcmap); 
   \   0000000C   0x6B42             LDR      R2,[R0, #+52]
   \   0000000E   0x718A             STRB     R2,[R1, #+6]
    121            blk->CLPS = ADC_CLPS_REG(adcmap); 
   \   00000010   0x6B82             LDR      R2,[R0, #+56]
   \   00000012   0x71CA             STRB     R2,[R1, #+7]
    122            blk->CLP4 = ADC_CLP4_REG(adcmap);
   \   00000014   0x6BC2             LDR      R2,[R0, #+60]
   \   00000016   0x810A             STRH     R2,[R1, #+8]
    123            blk->CLP3 = ADC_CLP3_REG(adcmap); 
   \   00000018   0x6C02             LDR      R2,[R0, #+64]
   \   0000001A   0x814A             STRH     R2,[R1, #+10]
    124            blk->CLP2 = ADC_CLP2_REG(adcmap); 
   \   0000001C   0x6C42             LDR      R2,[R0, #+68]
   \   0000001E   0x730A             STRB     R2,[R1, #+12]
    125            blk->CLP1 = ADC_CLP1_REG(adcmap);
   \   00000020   0x6C82             LDR      R2,[R0, #+72]
   \   00000022   0x734A             STRB     R2,[R1, #+13]
    126            blk->CLP0 = ADC_CLP0_REG(adcmap);
   \   00000024   0x6CC2             LDR      R2,[R0, #+76]
   \   00000026   0x738A             STRB     R2,[R1, #+14]
    127            blk->CLMD = ADC_CLMD_REG(adcmap); 
   \   00000028   0x6D42             LDR      R2,[R0, #+84]
   \   0000002A   0x740A             STRB     R2,[R1, #+16]
    128            blk->CLMS = ADC_CLMS_REG(adcmap); 
   \   0000002C   0x6D82             LDR      R2,[R0, #+88]
   \   0000002E   0x744A             STRB     R2,[R1, #+17]
    129            blk->CLM4 = ADC_CLM4_REG(adcmap);
   \   00000030   0x6DC2             LDR      R2,[R0, #+92]
   \   00000032   0x824A             STRH     R2,[R1, #+18]
    130            blk->CLM3 = ADC_CLM3_REG(adcmap); 
   \   00000034   0x6E02             LDR      R2,[R0, #+96]
   \   00000036   0x828A             STRH     R2,[R1, #+20]
    131            blk->CLM2 = ADC_CLM2_REG(adcmap); 
   \   00000038   0x6E42             LDR      R2,[R0, #+100]
   \   0000003A   0x758A             STRB     R2,[R1, #+22]
    132            blk->CLM1 = ADC_CLM1_REG(adcmap);
   \   0000003C   0x6E82             LDR      R2,[R0, #+104]
   \   0000003E   0x75CA             STRB     R2,[R1, #+23]
    133            blk->CLM0 = ADC_CLM0_REG(adcmap);
   \   00000040   0x6EC2             LDR      R2,[R0, #+108]
   \   00000042   0x760A             STRB     R2,[R1, #+24]
    134            
    135          }
   \   00000044   0x4770             BX       LR               ;; return
    136          
    137          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC_Cal
        0  ADC_Config_Alt
        0  ADC_Read_Cal


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     150  ADC_Cal
      38  ADC_Config_Alt
      70  ADC_Read_Cal

 
 258 bytes in section .text
 
 258 bytes of CODE memory

Errors: none
Warnings: none
