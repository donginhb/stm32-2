###############################################################################
#                                                                             #
#                                                       08/Jul/2014  15:37:34 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\dri #
#                    vers\SPI\SPI_FLASH.c                                     #
#    Command line =  "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\dri #
#                    vers\SPI\SPI_FLASH.c" -D IAR -D TWR_K60N512 -lCN         #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -lB             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -o              #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\" --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config              #
#                    C:\IAR\arm\INC\c\DLib_Config_Normal.h -I                 #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\projects\hello_world\" -I    #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\common\" -I                  #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\" -I                     #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\headers\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\adc16\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\enet\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\pmc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\rtc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\lptmr\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\uart\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\mcg\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\wdog\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\platforms\" -I               #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\ftm\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\SPI\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\OLED\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\" -Ol --use_c++_inline                 #
#    List file    =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\SPI_FLASH.lst     #
#    Object file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\SPI_FLASH.o        #
#                                                                             #
#                                                                             #
###############################################################################

E:\完成设计的产品\K60资料\OLED资料 (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\drivers\SPI\SPI_FLASH.c
      1          
      2          /*************************************************************************
      3          
      4          SPI驱动程序：W25X/Q32的驱动程序
      5          
      6          //4Kbytes为一个Sector
      7          //16个扇区为1个Block
      8          //W25X16
      9          //容量为2M字节,共有32个Block,512个Sector
     10          
     11          
     12          
     13          *************************************************************************/
     14          
     15          #include "SPI_FLASH.H"
     16          
     17          #include "uart.h"
     18          
     19          
     20          /*************************************************
     21          函数功能：硬件SPI口发送或者接收一个字节数据
     22          
     23          *************************************************/
     24          
     25          //SPIx 读写一个字节
     26          //TxData:要写入的字节
     27          //返回值:读取到的字节

   \                                 In section .text, align 2, keep-with-next
     28          unsigned char SPIx_ReadWriteByte(unsigned char TxData)
     29          {		
   \                     SPIx_ReadWriteByte:
   \   00000000   0xB580             PUSH     {R7,LR}
     30          	
     31            unsigned char i;
     32            
     33            i= SPI_Master_WriteRead(SPI0,TxData,SPI_PCS4,SPI_PCS_ASSERTED);
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       SPI_Master_WriteRead
     34            
     35             return  i;
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
     36          
     37          }
     38          
     39          
     40          //读取SPI_FLASH的状态寄存器
     41          //BIT7  6   5   4   3   2   1   0
     42          //SPR   RV  TB BP2 BP1 BP0 WEL BUSY
     43          //SPR:默认0,状态寄存器保护位,配合WP使用
     44          //TB,BP2,BP1,BP0:FLASH区域写保护设置
     45          //WEL:写使能锁定
     46          //BUSY:忙标记位(1,忙;0,空闲)
     47          //默认:0x00

   \                                 In section .text, align 2, keep-with-next
     48          unsigned char SPI_Flash_ReadSR(void)   
     49          {  
   \                     SPI_Flash_ReadSR:
   \   00000000   0xB510             PUSH     {R4,LR}
     50            
     51          	unsigned char byte=0;   
   \   00000002   0x2400             MOVS     R4,#+0
     52                  
     53          	SPI_FLASH_CS_LOW(); 
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
     54                  //使能器件   
     55          	SPIx_ReadWriteByte(W25X_ReadStatusReg);    //发送读取状态寄存器命令
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
     56                  
     57          	byte=SPIx_ReadWriteByte(0Xff);             //读取一个字节
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000024   0x0004             MOVS     R4,R0
     58           
     59          	SPI_FLASH_CS_HIGH();                            //取消片选
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000036   0x6889             LDR      R1,[R1, #+8]
   \   00000038   0x6008             STR      R0,[R1, #+0]
     60                  
     61          	return byte;   
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
     62          
     63          
     64          } 
     65          //写SPI_FLASH状态寄存器
     66          //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!

   \                                 In section .text, align 2, keep-with-next
     67          void SPI_FLASH_Write_SR(unsigned char sr)   
     68          { 
   \                     SPI_FLASH_Write_SR:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     69          
     70          
     71          	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
     72          	SPIx_ReadWriteByte(W25X_WriteStatusReg);   //发送写取状态寄存器命令    
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
     73          	SPIx_ReadWriteByte(sr);               //写入一个字节  
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       SPIx_ReadWriteByte
     74          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000036   0x6889             LDR      R1,[R1, #+8]
   \   00000038   0x6008             STR      R0,[R1, #+0]
     75          
     76          
     77          }   
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
     78          //SPI_FLASH写使能	
     79          //将WEL置位   

   \                                 In section .text, align 2, keep-with-next
     80          void SPI_FLASH_Write_Enable(void)   
     81          {
   \                     SPI_FLASH_Write_Enable:
   \   00000000   0xB580             PUSH     {R7,LR}
     82          	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000012   0x6889             LDR      R1,[R1, #+8]
   \   00000014   0x6008             STR      R0,[R1, #+0]
     83              SPIx_ReadWriteByte(W25X_WriteEnable);      //发送写使能  
   \   00000016   0x2006             MOVS     R0,#+6
   \   00000018   0x.... 0x....      BL       SPIx_ReadWriteByte
     84          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     85          } 
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
     86          //SPI_FLASH写禁止	
     87          //将WEL清零  

   \                                 In section .text, align 2, keep-with-next
     88          void SPI_FLASH_Write_Disable(void)   
     89          {  
   \                     SPI_FLASH_Write_Disable:
   \   00000000   0xB580             PUSH     {R7,LR}
     90          	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000012   0x6889             LDR      R1,[R1, #+8]
   \   00000014   0x6008             STR      R0,[R1, #+0]
     91              SPIx_ReadWriteByte(W25X_WriteDisable);     //发送写禁止指令    
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       SPIx_ReadWriteByte
     92          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     93          } 			    
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
     94          //读取芯片ID W25X16的ID:0XEF14

   \                                 In section .text, align 2, keep-with-next
     95          unsigned short int SPI_Flash_ReadID(void)
     96          {
   \                     SPI_Flash_ReadID:
   \   00000000   0xB510             PUSH     {R4,LR}
     97          	unsigned short int Temp = 0;	  
   \   00000002   0x2400             MOVS     R4,#+0
     98          	SPI_FLASH_CS_LOW();				    
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
     99          	SPIx_ReadWriteByte(0x90);//发送读取ID命令	    
   \   00000018   0x2090             MOVS     R0,#+144
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
    100          	SPIx_ReadWriteByte(0x00); 	    
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       SPIx_ReadWriteByte
    101          	SPIx_ReadWriteByte(0x00); 	    
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       SPIx_ReadWriteByte
    102          	SPIx_ReadWriteByte(0x00); 	 			   
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       SPIx_ReadWriteByte
    103          	Temp|=SPIx_ReadWriteByte(0x00)<<8;  
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000036   0xEA54 0x2400      ORRS     R4,R4,R0, LSL #+8
    104          	Temp|=SPIx_ReadWriteByte(0xFF);	 
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000040   0x4304             ORRS     R4,R0,R4
    105          	SPI_FLASH_CS_HIGH();				    
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000046   0x6880             LDR      R0,[R0, #+8]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000052   0x6889             LDR      R1,[R1, #+8]
   \   00000054   0x6008             STR      R0,[R1, #+0]
    106          	return Temp;
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    107          } 
    108          

   \                                 In section .text, align 2, keep-with-next
    109          unsigned int  SPI_Flash_ReadDeviceID(void)  	    //读取FLASH ID
    110          
    111          {
   \                     SPI_Flash_ReadDeviceID:
   \   00000000   0xB510             PUSH     {R4,LR}
    112          	unsigned int Temp = 0;	  
   \   00000002   0x2400             MOVS     R4,#+0
    113          	SPI_FLASH_CS_LOW();				    
   \   00000004   0x....             LDR.N    R0,??DataTable13
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable13
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0x6008             STR      R0,[R1, #+0]
    114          	SPIx_ReadWriteByte(0x9F);//发送读取ID命令	    
   \   00000014   0x209F             MOVS     R0,#+159
   \   00000016   0x.... 0x....      BL       SPIx_ReadWriteByte
    115          	//SPIx_ReadWriteByte(0x00); 	    
    116          	//SPIx_ReadWriteByte(0x00); 	    
    117          	//SPIx_ReadWriteByte(0x00); 	 			   
    118          	Temp|=SPIx_ReadWriteByte(0xFF)<<16;  
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000020   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
    119          	Temp|=SPIx_ReadWriteByte(0xFF)<<8;
   \   00000024   0x20FF             MOVS     R0,#+255
   \   00000026   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   0000002A   0xEA54 0x2400      ORRS     R4,R4,R0, LSL #+8
    120          	Temp|=SPIx_ReadWriteByte(0xFF);	 
   \   0000002E   0x20FF             MOVS     R0,#+255
   \   00000030   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000034   0x4304             ORRS     R4,R0,R4
    121          	SPI_FLASH_CS_HIGH();
   \   00000036   0x....             LDR.N    R0,??DataTable13
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000040   0x....             LDR.N    R1,??DataTable13
   \   00000042   0x6889             LDR      R1,[R1, #+8]
   \   00000044   0x6008             STR      R0,[R1, #+0]
    122          					    
    123          	return Temp;
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    124          } 
    125          
    126            		    
    127          //读取SPI FLASH  
    128          //在指定地址开始读取指定长度的数据
    129          //pBuffer:数据存储区
    130          //ReadAddr:开始读取的地址(24bit)
    131          //NumByteToRead:要读取的字节数(最大65535)

   \                                 In section .text, align 2, keep-with-next
    132          void SPI_Flash_Read(unsigned char* pBuffer,unsigned int ReadAddr,unsigned short int NumByteToRead)//读取SPI FLASH 在指定地址开始读取指定长度的数据   
    133          { 
   \                     SPI_Flash_Read:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    134           	unsigned short int i;    												    
    135          	SPI_FLASH_CS_LOW();                            			//使能器件   
   \   00000008   0x....             LDR.N    R0,??DataTable13
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0840             LSRS     R0,R0,#+1
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
    136              SPIx_ReadWriteByte(W25X_ReadData);         				//发送读取命令   
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
    137              SPIx_ReadWriteByte((unsigned char)((ReadAddr)>>16));    //发送24bit地址    
   \   0000001E   0x0C30             LSRS     R0,R6,#+16
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       SPIx_ReadWriteByte
    138              SPIx_ReadWriteByte((unsigned char)((ReadAddr)>>8));   
   \   00000026   0x0A30             LSRS     R0,R6,#+8
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       SPIx_ReadWriteByte
    139              SPIx_ReadWriteByte((unsigned char)ReadAddr);   
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       SPIx_ReadWriteByte
    140              for(i=0;i<NumByteToRead;i++)
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE005             B.N      ??SPI_Flash_Read_0
    141          	{ 
    142                  pBuffer[i]=SPIx_ReadWriteByte(0XFF);   				//循环读数  
   \                     ??SPI_Flash_Read_1:
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000040   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000042   0x5530             STRB     R0,[R6, R4]
    143              }
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \                     ??SPI_Flash_Read_0:
   \   00000046   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x42AE             CMP      R6,R5
   \   0000004C   0xD3F5             BCC.N    ??SPI_Flash_Read_1
    144          	SPI_FLASH_CS_HIGH();                            		//取消片选     	      
   \   0000004E   0x....             LDR.N    R0,??DataTable13
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000058   0x....             LDR.N    R1,??DataTable13
   \   0000005A   0x6889             LDR      R1,[R1, #+8]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    145          }  
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
    146          //SPI在一页(0~65535)内写入少于256个字节的数据
    147          //在指定地址开始写入最大256字节的数据
    148          //pBuffer:数据存储区
    149          //WriteAddr:开始写入的地址(24bit)
    150          //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 

   \                                 In section .text, align 2, keep-with-next
    151          void SPI_Flash_Write_Page(unsigned char* pBuffer,unsigned int WriteAddr,unsigned short int NumByteToWrite)//SPI在一页(0~65535)内写入少于256个字节的数据
    152          {
   \                     SPI_Flash_Write_Page:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    153           	unsigned short int i;  
    154              SPI_FLASH_Write_Enable();                  					//SET WEL 
   \   00000008   0x.... 0x....      BL       SPI_FLASH_Write_Enable
    155          	SPI_FLASH_CS_LOW();                            				//使能器件   
   \   0000000C   0x....             LDR.N    R0,??DataTable13
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0840             LSRS     R0,R0,#+1
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable13
   \   00000018   0x6889             LDR      R1,[R1, #+8]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    156              SPIx_ReadWriteByte(W25X_PageProgram);      					//发送写页命令   
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       SPIx_ReadWriteByte
    157              SPIx_ReadWriteByte((unsigned char)((WriteAddr)>>16)); 		//发送24bit地址    
   \   00000022   0x0C30             LSRS     R0,R6,#+16
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       SPIx_ReadWriteByte
    158              SPIx_ReadWriteByte((unsigned char)((WriteAddr)>>8));   
   \   0000002A   0x0A30             LSRS     R0,R6,#+8
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       SPIx_ReadWriteByte
    159              SPIx_ReadWriteByte((unsigned char)WriteAddr);   
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       SPIx_ReadWriteByte
    160              for(i=0;i<NumByteToWrite;i++)SPIx_ReadWriteByte(pBuffer[i]);//循环写数  
   \   0000003A   0x2600             MOVS     R6,#+0
   \   0000003C   0xE004             B.N      ??SPI_Flash_Write_Page_0
   \                     ??SPI_Flash_Write_Page_1:
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0x5D30             LDRB     R0,[R6, R4]
   \   00000042   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \                     ??SPI_Flash_Write_Page_0:
   \   00000048   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x42AE             CMP      R6,R5
   \   0000004E   0xD3F6             BCC.N    ??SPI_Flash_Write_Page_1
    161          	SPI_FLASH_CS_HIGH();                            			//取消片选 
   \   00000050   0x....             LDR.N    R0,??DataTable13
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005A   0x....             LDR.N    R1,??DataTable13
   \   0000005C   0x6889             LDR      R1,[R1, #+8]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    162          	SPI_Flash_Wait_Busy();					   					//等待写入结束
   \   00000060   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    163          } 
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    164          //无检验写SPI FLASH 
    165          //必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!
    166          //具有自动换页功能 
    167          //在指定地址开始写入指定长度的数据,但是要确保地址不越界!
    168          //pBuffer:数据存储区
    169          //WriteAddr:开始写入的地址(24bit)
    170          //NumByteToWrite:要写入的字节数(最大65535)
    171          //CHECK OK

   \                                 In section .text, align 2, keep-with-next
    172          void SPI_Flash_Write_NoCheck(unsigned char* pBuffer,unsigned int WriteAddr,unsigned short int NumByteToWrite)   
    173          { 			 		 
   \                     SPI_Flash_Write_NoCheck:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    174          	unsigned short int pageremain;	   
    175          	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
   \   00000008   0xF44F 0x7080      MOV      R0,#+256
   \   0000000C   0xF44F 0x7180      MOV      R1,#+256
   \   00000010   0xFBB5 0xF2F1      UDIV     R2,R5,R1
   \   00000014   0xFB02 0x5211      MLS      R2,R2,R1,R5
   \   00000018   0x1A87             SUBS     R7,R0,R2
    176          	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节
   \   0000001A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x42B7             CMP      R7,R6
   \   00000020   0xD303             BCC.N    ??SPI_Flash_Write_NoCheck_0
   \   00000022   0x0037             MOVS     R7,R6
   \   00000024   0xE001             B.N      ??SPI_Flash_Write_NoCheck_0
    177          	while(1)
    178          	{	   
    179          		SPI_Flash_Write_Page(pBuffer,WriteAddr,pageremain);
    180          		if(NumByteToWrite==pageremain)break;//写入结束了
    181          	 	else //NumByteToWrite>pageremain
    182          		{
    183          			pBuffer+=pageremain;
    184          			WriteAddr+=pageremain;	
    185          
    186          			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数
    187          			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节
   \                     ??SPI_Flash_Write_NoCheck_1:
   \   00000026   0xF44F 0x7780      MOV      R7,#+256
   \                     ??SPI_Flash_Write_NoCheck_0:
   \   0000002A   0x003A             MOVS     R2,R7
   \   0000002C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       SPI_Flash_Write_Page
   \   00000036   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000038   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003A   0x42BE             CMP      R6,R7
   \   0000003C   0xD100             BNE.N    ??SPI_Flash_Write_NoCheck_2
    188          			else pageremain=NumByteToWrite; 	  //不够256个字节了
    189          		}
    190          	};	    
    191          } 
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??SPI_Flash_Write_NoCheck_2:
   \   00000040   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000042   0x193C             ADDS     R4,R7,R4
   \   00000044   0xFA15 0xF587      UXTAH    R5,R5,R7
   \   00000048   0x1BF6             SUBS     R6,R6,R7
   \   0000004A   0xF240 0x1001      MOVW     R0,#+257
   \   0000004E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000050   0x4286             CMP      R6,R0
   \   00000052   0xD2E8             BCS.N    ??SPI_Flash_Write_NoCheck_1
   \   00000054   0x0037             MOVS     R7,R6
   \   00000056   0xE7E8             B.N      ??SPI_Flash_Write_NoCheck_0
    192          //写SPI FLASH  
    193          //在指定地址开始写入指定长度的数据
    194          //该函数带擦除操作!
    195          //pBuffer:数据存储区
    196          //WriteAddr:开始写入的地址(24bit)
    197          //NumByteToWrite:要写入的字节数(最大65535)  		   
    198          

   \                                 In section .bss, align 4
    199          unsigned char SPI_FLASH_BUF[4096];
   \                     SPI_FLASH_BUF:
   \   00000000                      DS8 4096
    200          

   \                                 In section .text, align 2, keep-with-next
    201          void SPI_Flash_Write(unsigned char* pBuffer,unsigned int WriteAddr,unsigned short int NumByteToWrite)   
    202          { 
   \                     SPI_Flash_Write:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    203          	unsigned int secpos;
    204          	unsigned short int secoff;
    205          	unsigned short int secremain;	   
    206           	unsigned short int i;    
    207          	
    208          
    209          
    210          	secpos=WriteAddr/4096;//扇区地址 0~511 for w25x16
   \   0000000A   0x0B2F             LSRS     R7,R5,#+12
    211          	secoff=WriteAddr%4096;//在扇区内的偏移
   \   0000000C   0xF44F 0x5080      MOV      R0,#+4096
   \   00000010   0xFBB5 0xF8F0      UDIV     R8,R5,R0
   \   00000014   0xFB08 0x5810      MLS      R8,R8,R0,R5
    212          	secremain=4096-secoff;//扇区剩余空间大小   
   \   00000018   0xF5D8 0x5980      RSBS     R9,R8,#+4096
    213          
    214          	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节
   \   0000001C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x45B1             CMP      R9,R6
   \   00000024   0xD303             BCC.N    ??SPI_Flash_Write_0
   \   00000026   0x46B1             MOV      R9,R6
   \   00000028   0xE001             B.N      ??SPI_Flash_Write_0
    215          	while(1) 
    216          	{	
    217          		SPI_Flash_Read(SPI_FLASH_BUF,secpos*4096,4096);//读出整个扇区的内容
    218          		for(i=0;i<secremain;i++)//校验数据
    219          		{
    220          			if(SPI_FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
    221          		}
    222          		if(i<secremain)//需要擦除
    223          		{
    224          			SPI_Flash_Erase_Sector(secpos);//擦除这个扇区
    225          			for(i=0;i<secremain;i++)	   //复制
    226          			{
    227          				SPI_FLASH_BUF[i+secoff]=pBuffer[i];	  
    228          			}
    229          			SPI_Flash_Write_NoCheck(SPI_FLASH_BUF,secpos*4096,4096);//写入整个扇区  
    230          
    231          		}else SPI_Flash_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
    232          		if(NumByteToWrite==secremain)break;//写入结束了
    233          		else//写入未结束
    234          		{
    235          			secpos++;//扇区地址增1
    236          			secoff=0;//偏移位置为0 	 
    237          
    238          		   	pBuffer+=secremain;  //指针偏移
    239          			WriteAddr+=secremain;//写地址偏移	   
    240          		   	NumByteToWrite-=secremain;				//字节数递减
    241          			if(NumByteToWrite>4096)secremain=4096;	//下一个扇区还是写不完
   \                     ??SPI_Flash_Write_1:
   \   0000002A   0xF44F 0x5980      MOV      R9,#+4096
   \                     ??SPI_Flash_Write_0:
   \   0000002E   0xF44F 0x5280      MOV      R2,#+4096
   \   00000032   0xF44F 0x5080      MOV      R0,#+4096
   \   00000036   0xFB00 0xF107      MUL      R1,R0,R7
   \   0000003A   0x....             LDR.N    R0,??DataTable13_1
   \   0000003C   0x.... 0x....      BL       SPI_Flash_Read
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE000             B.N      ??SPI_Flash_Write_2
   \                     ??SPI_Flash_Write_3:
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \                     ??SPI_Flash_Write_2:
   \   00000046   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000048   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000004C   0x4548             CMP      R0,R9
   \   0000004E   0xD206             BCS.N    ??SPI_Flash_Write_4
   \   00000050   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000052   0xFA10 0xF188      UXTAH    R1,R0,R8
   \   00000056   0x....             LDR.N    R2,??DataTable13_1
   \   00000058   0x5C89             LDRB     R1,[R1, R2]
   \   0000005A   0x29FF             CMP      R1,#+255
   \   0000005C   0xD0F2             BEQ.N    ??SPI_Flash_Write_3
   \                     ??SPI_Flash_Write_4:
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000064   0x4548             CMP      R0,R9
   \   00000066   0xD21C             BCS.N    ??SPI_Flash_Write_5
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x.... 0x....      BL       SPI_Flash_Erase_Sector
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE008             B.N      ??SPI_Flash_Write_6
   \                     ??SPI_Flash_Write_7:
   \   00000072   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000076   0xFA18 0xF180      UXTAH    R1,R8,R0
   \   0000007A   0x....             LDR.N    R2,??DataTable13_1
   \   0000007C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007E   0x5D03             LDRB     R3,[R0, R4]
   \   00000080   0x548B             STRB     R3,[R1, R2]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \                     ??SPI_Flash_Write_6:
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000008A   0x4548             CMP      R0,R9
   \   0000008C   0xD3F1             BCC.N    ??SPI_Flash_Write_7
   \   0000008E   0xF44F 0x5280      MOV      R2,#+4096
   \   00000092   0xF44F 0x5080      MOV      R0,#+4096
   \   00000096   0xFB00 0xF107      MUL      R1,R0,R7
   \   0000009A   0x....             LDR.N    R0,??DataTable13_1
   \   0000009C   0x.... 0x....      BL       SPI_Flash_Write_NoCheck
   \   000000A0   0xE005             B.N      ??SPI_Flash_Write_8
   \                     ??SPI_Flash_Write_5:
   \   000000A2   0x464A             MOV      R2,R9
   \   000000A4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A6   0x0029             MOVS     R1,R5
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       SPI_Flash_Write_NoCheck
   \                     ??SPI_Flash_Write_8:
   \   000000AE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B0   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000B4   0x454E             CMP      R6,R9
   \   000000B6   0xD101             BNE.N    ??SPI_Flash_Write_9
    242          			else secremain=NumByteToWrite;			//下一个扇区可以写完了
    243          		}	 
    244          	};	 	 
    245          }
   \   000000B8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??SPI_Flash_Write_9:
   \   000000BC   0x1C7F             ADDS     R7,R7,#+1
   \   000000BE   0xF05F 0x0800      MOVS     R8,#+0
   \   000000C2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000C6   0xEB19 0x0404      ADDS     R4,R9,R4
   \   000000CA   0xFA15 0xF589      UXTAH    R5,R5,R9
   \   000000CE   0xEBB6 0x0609      SUBS     R6,R6,R9
   \   000000D2   0xF241 0x0001      MOVW     R0,#+4097
   \   000000D6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D8   0x4286             CMP      R6,R0
   \   000000DA   0xD2A6             BCS.N    ??SPI_Flash_Write_1
   \   000000DC   0x46B1             MOV      R9,R6
   \   000000DE   0xE7A6             B.N      ??SPI_Flash_Write_0
    246          //擦除整个芯片
    247          //整片擦除时间:
    248          //W25X16:25s 
    249          //W25X32:40s 
    250          //W25X64:40s 
    251          //等待时间超长...

   \                                 In section .text, align 2, keep-with-next
    252          void SPI_Flash_Erase_Chip(void)   
    253          {                                             
   \                     SPI_Flash_Erase_Chip:
   \   00000000   0xB580             PUSH     {R7,LR}
    254              SPI_FLASH_Write_Enable();                  //SET WEL 
   \   00000002   0x.... 0x....      BL       SPI_FLASH_Write_Enable
    255              SPI_Flash_Wait_Busy();   
   \   00000006   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    256            	SPI_FLASH_CS_LOW();                        //使能器件   
   \   0000000A   0x....             LDR.N    R0,??DataTable13
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0840             LSRS     R0,R0,#+1
   \   00000012   0x0040             LSLS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable13
   \   00000016   0x6889             LDR      R1,[R1, #+8]
   \   00000018   0x6008             STR      R0,[R1, #+0]
    257              SPIx_ReadWriteByte(W25X_ChipErase);        //发送片擦除命令  
   \   0000001A   0x20C7             MOVS     R0,#+199
   \   0000001C   0x.... 0x....      BL       SPIx_ReadWriteByte
    258          	SPI_FLASH_CS_HIGH();                       //取消片选     	      
   \   00000020   0x....             LDR.N    R0,??DataTable13
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002A   0x....             LDR.N    R1,??DataTable13
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    259          	SPI_Flash_Wait_Busy();   				   //等待芯片擦除结束
   \   00000030   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    260          }   
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    261          //擦除一个扇区
    262          //Dst_Addr:扇区地址 0~511 for w25x16
    263          //擦除一个扇区的最少时间:150ms

   \                                 In section .text, align 2, keep-with-next
    264          void SPI_Flash_Erase_Sector(unsigned int Dst_Addr)   
    265          {   
   \                     SPI_Flash_Erase_Sector:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266          	Dst_Addr*=4096;
   \   00000004   0xF44F 0x5080      MOV      R0,#+4096
   \   00000008   0x4344             MULS     R4,R0,R4
    267              SPI_FLASH_Write_Enable();                  //SET WEL 	 
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_Write_Enable
    268              SPI_Flash_Wait_Busy();   
   \   0000000E   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    269            	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000012   0x....             LDR.N    R0,??DataTable13
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0840             LSRS     R0,R0,#+1
   \   0000001A   0x0040             LSLS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable13
   \   0000001E   0x6889             LDR      R1,[R1, #+8]
   \   00000020   0x6008             STR      R0,[R1, #+0]
    270              SPIx_ReadWriteByte(W25X_SectorErase);      //发送扇区擦除指令 
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0x.... 0x....      BL       SPIx_ReadWriteByte
    271              SPIx_ReadWriteByte((unsigned char)((Dst_Addr)>>16));  //发送24bit地址    
   \   00000028   0x0C20             LSRS     R0,R4,#+16
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       SPIx_ReadWriteByte
    272              SPIx_ReadWriteByte((unsigned char)((Dst_Addr)>>8));   
   \   00000030   0x0A20             LSRS     R0,R4,#+8
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       SPIx_ReadWriteByte
    273              SPIx_ReadWriteByte((unsigned char)Dst_Addr);  
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       SPIx_ReadWriteByte
    274          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000040   0x....             LDR.N    R0,??DataTable13
   \   00000042   0x6880             LDR      R0,[R0, #+8]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004A   0x....             LDR.N    R1,??DataTable13
   \   0000004C   0x6889             LDR      R1,[R1, #+8]
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    275              SPI_Flash_Wait_Busy();   				   //等待擦除完成
   \   00000050   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    276          }  
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    277          //等待空闲

   \                                 In section .text, align 2, keep-with-next
    278          void SPI_Flash_Wait_Busy(void)   
    279          {   
   \                     SPI_Flash_Wait_Busy:
   \   00000000   0xB580             PUSH     {R7,LR}
    280          	
    281          	while ((SPI_Flash_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
   \                     ??SPI_Flash_Wait_Busy_0:
   \   00000002   0x.... 0x....      BL       SPI_Flash_ReadSR
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD4FB             BMI.N    ??SPI_Flash_Wait_Busy_0
    282          
    283          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    284          
    285            
    286          //进入掉电模式

   \                                 In section .text, align 2, keep-with-next
    287          void SPI_Flash_PowerDown(void)   
    288          { 
   \                     SPI_Flash_PowerDown:
   \   00000000   0xB580             PUSH     {R7,LR}
    289            	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x....             LDR.N    R0,??DataTable13
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0840             LSRS     R0,R0,#+1
   \   0000000A   0x0040             LSLS     R0,R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable13
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6008             STR      R0,[R1, #+0]
    290              SPIx_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
   \   00000012   0x20B9             MOVS     R0,#+185
   \   00000014   0x.... 0x....      BL       SPIx_ReadWriteByte
    291          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000018   0x....             LDR.N    R0,??DataTable13
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x....             LDR.N    R1,??DataTable13
   \   00000024   0x6889             LDR      R1,[R1, #+8]
   \   00000026   0x6008             STR      R0,[R1, #+0]
    292              delay_ms(1);                               //等待TPD  
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       delay_ms
    293          }   
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    294          //唤醒

   \                                 In section .text, align 2, keep-with-next
    295          void SPI_Flash_WAKEUP(void)   
    296          {  
   \                     SPI_Flash_WAKEUP:
   \   00000000   0xB580             PUSH     {R7,LR}
    297            	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x....             LDR.N    R0,??DataTable13
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0840             LSRS     R0,R0,#+1
   \   0000000A   0x0040             LSLS     R0,R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable13
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6008             STR      R0,[R1, #+0]
    298              SPIx_ReadWriteByte(W25X_ReleasePowerDown);   //  send W25X_PowerDown command 0xAB    
   \   00000012   0x20AB             MOVS     R0,#+171
   \   00000014   0x.... 0x....      BL       SPIx_ReadWriteByte
    299          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000018   0x....             LDR.N    R0,??DataTable13
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x....             LDR.N    R1,??DataTable13
   \   00000024   0x6889             LDR      R1,[R1, #+8]
   \   00000026   0x6008             STR      R0,[R1, #+0]
    300              delay_ms(1);                               //等待TRES1
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       delay_ms
    301          }   
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    302          
    303          
    304          //使用SysTick的普通计数模式对延迟进行管理
    305          //包括delay_us,delay_ms
    306          //2010/5/27

   \                                 In section .bss, align 4
    307          static unsigned int TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
    308          
    309          
    310           /**
    311            * @brief  Inserts a delay time.
    312            * @param nTime: specifies the delay time length, in milliseconds.
    313            * @retval : None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void delay_ms(unsigned int nTime)
    316          { 
    317           while(--nTime);
   \                     delay_ms:
   \                     ??delay_ms_0:
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD1FC             BNE.N    ??delay_ms_0
    318          
    319           
    320          }
   \   00000006   0x4770             BX       LR               ;; return
    321          
    322          /**
    323            * @brief  Decrements the TimingDelay variable.
    324            * @param  None
    325            * @retval : None
    326            */
    327          
    328          
    329          

   \                                 In section .text, align 2, keep-with-next
    330          void TimingDelay_Decrement(void)
    331          {
    332            if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement:
   \   00000000   0x....             LDR.N    R0,??DataTable13_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??TimingDelay_Decrement_0
    333            { 
    334              TimingDelay--;
   \   00000008   0x....             LDR.N    R0,??DataTable13_2
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable13_2
   \   00000010   0x6008             STR      R0,[R1, #+0]
    335            }
    336          }
   \                     ??TimingDelay_Decrement_0:
   \   00000012   0x4770             BX       LR               ;; return
    337          
    338          
    339          
    340          
    341          
    342           /**********************************初始化缓冲区为0x0或者0xFF**********************************/ 
    343           

   \                                 In section .text, align 2, keep-with-next
    344          void Init_Buffer (unsigned char *P,unsigned int Count,unsigned char Type) 
    345          
    346          {
    347            unsigned int i;
    348            
    349             if(Type==0)
   \                     Init_Buffer:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD107             BNE.N    ??Init_Buffer_0
    350             {
    351             
    352               for(i=0;i<Count;i++)*P++=0x0;
   \   00000006   0x2200             MOVS     R2,#+0
   \                     ??Init_Buffer_1:
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xD20C             BCS.N    ??Init_Buffer_2
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x7003             STRB     R3,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \   00000014   0xE7F8             B.N      ??Init_Buffer_1
    353             
    354             }
    355             else
    356             {
    357               for(i=0;i<Count;i++)*P++=0xFF;
   \                     ??Init_Buffer_0:
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xE003             B.N      ??Init_Buffer_3
   \                     ??Init_Buffer_4:
   \   0000001A   0x23FF             MOVS     R3,#+255
   \   0000001C   0x7003             STRB     R3,[R0, #+0]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \                     ??Init_Buffer_3:
   \   00000022   0x428A             CMP      R2,R1
   \   00000024   0xD3F9             BCC.N    ??Init_Buffer_4
    358          
    359             }
    360          
    361          }
   \                     ??Init_Buffer_2:
   \   00000026   0x4770             BX       LR               ;; return
    362          
    363          
    364          
    365          
    366          /**************************************************************************************
    367            函数功能：内存拷贝函数
    368          
    369          **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    370          void Copy_Mem (unsigned char *P1, const unsigned char *P2,unsigned int Count)
    371          {
   \                     Copy_Mem:
   \   00000000   0xB410             PUSH     {R4}
    372             
    373             unsigned int i ;
    374             for(i=0;i<Count;i++)*P1++=*P2++;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE004             B.N      ??Copy_Mem_0
   \                     ??Copy_Mem_1:
   \   00000006   0x780C             LDRB     R4,[R1, #+0]
   \   00000008   0x7004             STRB     R4,[R0, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Copy_Mem_0:
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD3F8             BCC.N    ??Copy_Mem_1
    375          
    376            
    377          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    378          
    379          
    380          /**************************************************************************************
    381            函数功能：内存拷贝函数
    382          
    383          **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    384          void Copy_Char (unsigned char *P1, unsigned char *P2,unsigned int Count)
    385          {
   \                     Copy_Char:
   \   00000000   0xB410             PUSH     {R4}
    386             
    387             unsigned int i ;
    388             for(i=0;i<Count;i++)*P1++=*P2++;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE004             B.N      ??Copy_Char_0
   \                     ??Copy_Char_1:
   \   00000006   0x780C             LDRB     R4,[R1, #+0]
   \   00000008   0x7004             STRB     R4,[R0, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Copy_Char_0:
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD3F8             BCC.N    ??Copy_Char_1
    389          
    390            
    391          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    392          
    393          
    394          
    395          
    396          /**************************************************************************************
    397            函数功能：内存比较函数函数
    398            比较指针指向的两个缓冲区的数据是否一样
    399            一样返回值为：  0
    400            不一样返回值为：1
    401          
    402          ***************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    403          unsigned char Compare_Mem (unsigned char *P1,unsigned char *P2,unsigned int Count)
    404          {
   \                     Compare_Mem:
   \   00000000   0xB430             PUSH     {R4,R5}
    405             
    406             unsigned int i ;
    407             
    408             for(i=0;i<Count;i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE002             B.N      ??Compare_Mem_0
    409             {
    410              
    411               if(*P1==*P2)
    412               {
    413                 
    414                 P1++;
   \                     ??Compare_Mem_1:
   \   00000006   0x1C40             ADDS     R0,R0,#+1
    415                 
    416                 P2++;
   \   00000008   0x1C49             ADDS     R1,R1,#+1
    417                 
    418               }
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Compare_Mem_0:
   \   0000000C   0x4293             CMP      R3,R2
   \   0000000E   0xD205             BCS.N    ??Compare_Mem_2
   \   00000010   0x7804             LDRB     R4,[R0, #+0]
   \   00000012   0x780D             LDRB     R5,[R1, #+0]
   \   00000014   0x42AC             CMP      R4,R5
   \   00000016   0xD0F6             BEQ.N    ??Compare_Mem_1
    419               else
    420               {
    421                 return 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??Compare_Mem_3
    422                      
    423               }
    424               
    425             };
    426              return 0;
   \                     ??Compare_Mem_2:
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??Compare_Mem_3:
   \   0000001E   0xBC30             POP      {R4,R5}
   \   00000020   0x4770             BX       LR               ;; return
    427            
    428          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     GPIOx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     SPI_FLASH_BUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     TimingDelay
    429          
    430          
    431          
    432          
    433          
    434          
    435          
    436          
    437          
    438          
    439          
    440          
    441          
    442          
    443          
    444          
    445          
    446          
    447          
    448          
    449          
    450          
    451          
    452          
    453          
    454          
    455          
    456          
    457          
    458          
    459          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  Compare_Mem
        4  Copy_Char
        4  Copy_Mem
        0  Init_Buffer
        8  SPI_FLASH_Write_Disable
              8 -> SPIx_ReadWriteByte
        8  SPI_FLASH_Write_Enable
              8 -> SPIx_ReadWriteByte
        8  SPI_FLASH_Write_SR
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_Erase_Chip
              8 -> SPI_FLASH_Write_Enable
              8 -> SPI_Flash_Wait_Busy
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_Erase_Sector
              8 -> SPI_FLASH_Write_Enable
              8 -> SPI_Flash_Wait_Busy
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_PowerDown
              8 -> SPIx_ReadWriteByte
              8 -> delay_ms
       16  SPI_Flash_Read
             16 -> SPIx_ReadWriteByte
        8  SPI_Flash_ReadDeviceID
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_ReadID
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_ReadSR
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_WAKEUP
              8 -> SPIx_ReadWriteByte
              8 -> delay_ms
        8  SPI_Flash_Wait_Busy
              8 -> SPI_Flash_ReadSR
       32  SPI_Flash_Write
             32 -> SPI_Flash_Erase_Sector
             32 -> SPI_Flash_Read
             32 -> SPI_Flash_Write_NoCheck
       24  SPI_Flash_Write_NoCheck
             24 -> SPI_Flash_Write_Page
       16  SPI_Flash_Write_Page
             16 -> SPI_FLASH_Write_Enable
             16 -> SPI_Flash_Wait_Busy
             16 -> SPIx_ReadWriteByte
        8  SPIx_ReadWriteByte
              8 -> SPI_Master_WriteRead
        0  TimingDelay_Decrement
        0  delay_ms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
      34  Compare_Mem
      24  Copy_Char
      24  Copy_Mem
      40  Init_Buffer
    4096  SPI_FLASH_BUF
      50  SPI_FLASH_Write_Disable
      50  SPI_FLASH_Write_Enable
      60  SPI_FLASH_Write_SR
      54  SPI_Flash_Erase_Chip
      86  SPI_Flash_Erase_Sector
      48  SPI_Flash_PowerDown
      96  SPI_Flash_Read
      74  SPI_Flash_ReadDeviceID
      92  SPI_Flash_ReadID
      64  SPI_Flash_ReadSR
      48  SPI_Flash_WAKEUP
      12  SPI_Flash_Wait_Busy
     224  SPI_Flash_Write
      88  SPI_Flash_Write_NoCheck
     102  SPI_Flash_Write_Page
      20  SPIx_ReadWriteByte
       4  TimingDelay
      20  TimingDelay_Decrement
       8  delay_ms

 
 4 100 bytes in section .bss
 1 330 bytes in section .text
 
 1 330 bytes of CODE memory
 4 100 bytes of DATA memory

Errors: none
Warnings: none
