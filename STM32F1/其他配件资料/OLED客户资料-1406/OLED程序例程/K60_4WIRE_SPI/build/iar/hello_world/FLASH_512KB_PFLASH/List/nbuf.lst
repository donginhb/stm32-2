###############################################################################
#                                                                             #
#                                                       08/Jul/2014  15:37:36 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\dri #
#                    vers\enet\nbuf.c                                         #
#    Command line =  "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\dri #
#                    vers\enet\nbuf.c" -D IAR -D TWR_K60N512 -lCN             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -lB             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\" -o              #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\" --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config              #
#                    C:\IAR\arm\INC\c\DLib_Config_Normal.h -I                 #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\projects\hello_world\" -I    #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\common\" -I                  #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\" -I                     #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\cpu\headers\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\adc16\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\enet\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\pmc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\rtc\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\lptmr\" -I           #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\uart\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\mcg\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\wdog\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\platforms\" -I               #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\ftm\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\SPI\" -I             #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\..\..\src\drivers\OLED\" -I            #
#                    "E:\完成设计的产品\K60资料\OLED资料                      #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\..\" -Ol --use_c++_inline                 #
#    List file    =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\List\nbuf.lst          #
#    Object file  =  E:\完成设计的产品\K60资料\OLED资料                       #
#                    (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\build\i #
#                    ar\hello_world\FLASH_512KB_PFLASH\Obj\nbuf.o             #
#                                                                             #
#                                                                             #
###############################################################################

E:\完成设计的产品\K60资料\OLED资料 (1)\OLED客户资料-1406\OLED程序例程\K60_4WIRE_SPI\src\drivers\enet\nbuf.c
      1          /* Buffer Descriptors -- must be aligned on a 4-byte boundary but a 
      2           * 16-byte boundary is recommended. To avoid playing games with the 
      3           * various compilers and their different extension to ANSI C, these 
      4           * buffers are aligned by allocating an extra line of data and 
      5           * adjusting the pointers in nbuf_init().
      6           */
      7          
      8          #include "common.h"
      9          #include "nbuf.h"
     10          
     11          /*FSL: to avoid overlapping, buffers must be declared at the beggining of file*/
     12          /*then pointers can access them correctly*/
     13          
     14          /* Data Buffers -- must be aligned on a 16-byte boundary. To avoid 
     15           * playing games with the various compilers and their different 
     16           * extension to ANSI C, these buffers are aligned by allocating an 
     17           * extra line of data and adjusting the pointers in nbuf_init().
     18           */

   \                                 In section .bss, align 4
     19          static uint8_t unaligned_txbd[(sizeof(NBUF) * NUM_TXBDS) + 16];
   \                     unaligned_txbd:
   \   00000000                      DS8 656

   \                                 In section .bss, align 4
     20          static uint8_t unaligned_rxbd[(sizeof(NBUF) * NUM_RXBDS) + 16];
   \                     unaligned_rxbd:
   \   00000000                      DS8 656
     21          #ifdef USE_DEDICATED_TX_BUFFERS
     22          static uint8_t unaligned_txbuffer[(TX_BUFFER_SIZE * NUM_TXBDS) + 16];
     23          #endif

   \                                 In section .bss, align 4
     24          static uint8_t unaligned_rxbuffer[(RX_BUFFER_SIZE * NUM_RXBDS) + 16];
   \                     unaligned_rxbuffer:
   \   00000000                      DS8 5136
     25          
     26          /* Pointers to alligned buffer descriptors */

   \                                 In section .bss, align 4
     27          static NBUF *TxNBUF;
   \                     TxNBUF:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     28          static NBUF *RxNBUF;
   \                     RxNBUF:
   \   00000000                      DS8 4
     29          
     30          /* Pointers to alligned Tx/Rx data buffers */
     31          #ifdef USE_DEDICATED_TX_BUFFERS
     32          static uint8_t *TxBuffer;
     33          #endif

   \                                 In section .bss, align 4
     34          static uint8_t *RxBuffer;
   \                     RxBuffer:
   \   00000000                      DS8 4
     35          
     36          /* Next BD indicators for static BD queue */ 

   \                                 In section .bss, align 4
     37          static int next_txbd;
   \                     next_txbd:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     38          static int next_rxbd;
   \                     next_rxbd:
   \   00000000                      DS8 4
     39          
     40          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     41          void 
     42          nbuf_alloc(int ch)
     43          {
     44          	int i;
     45          	//uint32_t *temp;
     46          
     47                  next_txbd = 0;
   \                     nbuf_alloc:
   \   00000000   0x....             LDR.N    R0,??DataTable6
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
     48                  next_rxbd = 0;
   \   00000006   0x....             LDR.N    R0,??DataTable6_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
     49          
     50          	TxNBUF = (NBUF *)(((uint32_t)(unaligned_txbd)) & 0xFFFFFFF0);
   \   0000000C   0x....             LDR.N    R0,??DataTable6_2
   \   0000000E   0x....             LDR.N    R1,??DataTable6_3
   \   00000010   0x0909             LSRS     R1,R1,#+4
   \   00000012   0x0109             LSLS     R1,R1,#+4
   \   00000014   0x6001             STR      R1,[R0, #+0]
     51          	RxNBUF = (NBUF *)(((uint32_t)(unaligned_rxbd)) & 0xFFFFFFF0);
   \   00000016   0x....             LDR.N    R0,??DataTable6_4
   \   00000018   0x....             LDR.N    R1,??DataTable6_5
   \   0000001A   0x0909             LSRS     R1,R1,#+4
   \   0000001C   0x0109             LSLS     R1,R1,#+4
   \   0000001E   0x6001             STR      R1,[R0, #+0]
     52          
     53          	RxBuffer = (uint8_t *)(((uint32_t)(unaligned_rxbuffer)) & 0xFFFFFFF0);
   \   00000020   0x....             LDR.N    R0,??DataTable6_6
   \   00000022   0x....             LDR.N    R1,??DataTable6_7
   \   00000024   0x0909             LSRS     R1,R1,#+4
   \   00000026   0x0109             LSLS     R1,R1,#+4
   \   00000028   0x6001             STR      R1,[R0, #+0]
     54          #ifdef USE_DEDICATED_TX_BUFFERS
     55          	TxBuffer = (uint8_t *)(((uint32_t)(unaligned_txbuffer)) & 0xFFFFFFF0);
     56          #endif
     57          	// Initialize transmit descriptor ring
     58          	for (i = 0; i < NUM_TXBDS; i++)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE011             B.N      ??nbuf_alloc_0
     59          	{
     60          		TxNBUF[i].status = 0x0000;
   \                     ??nbuf_alloc_1:
   \   0000002E   0x0141             LSLS     R1,R0,#+5
   \   00000030   0x....             LDR.N    R2,??DataTable6_2
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x528B             STRH     R3,[R1, R2]
     61          		TxNBUF[i].length = 0;		
   \   00000038   0x....             LDR.N    R1,??DataTable6_2
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x804A             STRH     R2,[R1, #+2]
     62          	        #ifdef USE_DEDICATED_TX_BUFFERS
     63          	           #ifdef NBUF_LITTLE_ENDIAN 
     64          	           TxNBUF[i].data = (uint8_t *)__REV((uint32_t)&TxBuffer[i * TX_BUFFER_SIZE]);
     65                             #else
     66                             TxNBUF[i].data = (uint8_t *)(uint32_t)&TxBuffer[i * TX_BUFFER_SIZE];
     67                             #endif
     68                          #endif
     69                  
     70                          #ifdef ENHANCED_BD
     71                             TxNBUF[i].ebd_status = TX_BD_IINS | TX_BD_PINS;
   \   00000044   0x....             LDR.N    R1,??DataTable6_2
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   0000004C   0x2218             MOVS     R2,#+24
   \   0000004E   0x608A             STR      R2,[R1, #+8]
     72                          #endif
     73          	}
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \                     ??nbuf_alloc_0:
   \   00000052   0x2814             CMP      R0,#+20
   \   00000054   0xDBEB             BLT.N    ??nbuf_alloc_1
     74          
     75          	// Initialize receive descriptor ring
     76          	for (i = 0; i < NUM_RXBDS; i++)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE024             B.N      ??nbuf_alloc_2
     77          	{
     78          		RxNBUF[i].status = RX_BD_E;
   \                     ??nbuf_alloc_3:
   \   0000005A   0x0141             LSLS     R1,R0,#+5
   \   0000005C   0x....             LDR.N    R2,??DataTable6_4
   \   0000005E   0x6812             LDR      R2,[R2, #+0]
   \   00000060   0x2380             MOVS     R3,#+128
   \   00000062   0x528B             STRH     R3,[R1, R2]
     79          		RxNBUF[i].length = 0;
   \   00000064   0x....             LDR.N    R1,??DataTable6_4
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x804A             STRH     R2,[R1, #+2]
     80                          #ifdef NBUF_LITTLE_ENDIAN
     81          		RxNBUF[i].data = (uint8_t *)__REV((uint32_t)&RxBuffer[i * RX_BUFFER_SIZE]);
   \   00000070   0xF44F 0x7180      MOV      R1,#+256
   \   00000074   0x....             LDR.N    R2,??DataTable6_6
   \   00000076   0x6812             LDR      R2,[R2, #+0]
   \   00000078   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000007C   0xBA09             REV      R1,R1
   \   0000007E   0x....             LDR.N    R2,??DataTable6_4
   \   00000080   0x6812             LDR      R2,[R2, #+0]
   \   00000082   0xEB12 0x1240      ADDS     R2,R2,R0, LSL #+5
   \   00000086   0x6051             STR      R1,[R2, #+4]
     82                          #else
     83                          RxNBUF[i].data = (uint8_t *)(uint32_t)&RxBuffer[i * RX_BUFFER_SIZE];
     84                          #endif
     85          
     86                          #ifdef ENHANCED_BD
     87          	        RxNBUF[i].bdu = 0x00000000;
   \   00000088   0x....             LDR.N    R1,??DataTable6_4
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x610A             STR      R2,[R1, #+16]
     88          	        RxNBUF[i].ebd_status = RX_BD_INT;
   \   00000094   0x....             LDR.N    R1,??DataTable6_4
   \   00000096   0x6809             LDR      R1,[R1, #+0]
   \   00000098   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   0000009C   0xF44F 0x4200      MOV      R2,#+32768
   \   000000A0   0x608A             STR      R2,[R1, #+8]
     89                          #endif               
     90          	}
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \                     ??nbuf_alloc_2:
   \   000000A4   0x2814             CMP      R0,#+20
   \   000000A6   0xDBD8             BLT.N    ??nbuf_alloc_3
     91                  
     92          	// Set the Wrap bit on the last one in the ring
     93          	RxNBUF[NUM_RXBDS - 1].status |= RX_BD_W;
   \   000000A8   0x....             LDR.N    R0,??DataTable6_4
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF8B0 0x0260      LDRH     R0,[R0, #+608]
   \   000000B0   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000B4   0x....             LDR.N    R1,??DataTable6_4
   \   000000B6   0x6809             LDR      R1,[R1, #+0]
   \   000000B8   0xF8A1 0x0260      STRH     R0,[R1, #+608]
     94          	TxNBUF[NUM_TXBDS - 1].status |= TX_BD_W;
   \   000000BC   0x....             LDR.N    R0,??DataTable6_2
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF8B0 0x0260      LDRH     R0,[R0, #+608]
   \   000000C4   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C8   0x....             LDR.N    R1,??DataTable6_2
   \   000000CA   0x6809             LDR      R1,[R1, #+0]
   \   000000CC   0xF8A1 0x0260      STRH     R0,[R1, #+608]
     95          }
   \   000000D0   0x4770             BX       LR               ;; return
     96          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     97          void 
     98          nbuf_flush(int ch)
     99          {
    100          	int i;
    101          
    102          	next_txbd = 0;
   \                     nbuf_flush:
   \   00000000   0x....             LDR.N    R0,??DataTable6
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    103          	next_rxbd = 0;
   \   00000006   0x....             LDR.N    R0,??DataTable6_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    104          	
    105          	// Reset enet hardware bd pointers also ??
    106          
    107          	// Reset receive descriptor ring
    108          	for (i = 0; i < NUM_RXBDS; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE017             B.N      ??nbuf_flush_0
    109          	{
    110          		RxNBUF[i].status = RX_BD_E;
   \                     ??nbuf_flush_1:
   \   00000010   0x0141             LSLS     R1,R0,#+5
   \   00000012   0x....             LDR.N    R2,??DataTable6_4
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x2380             MOVS     R3,#+128
   \   00000018   0x528B             STRH     R3,[R1, R2]
    111          		RxNBUF[i].length = 0;
   \   0000001A   0x....             LDR.N    R1,??DataTable6_4
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x804A             STRH     R2,[R1, #+2]
    112          	        #ifdef NBUF_LITTLE_ENDIAN	
    113          		RxNBUF[i].data = (uint8_t *)__REV((uint32_t)&RxBuffer[i * RX_BUFFER_SIZE]);
   \   00000026   0xF44F 0x7180      MOV      R1,#+256
   \   0000002A   0x....             LDR.N    R2,??DataTable6_6
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000032   0xBA09             REV      R1,R1
   \   00000034   0x....             LDR.N    R2,??DataTable6_4
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0xEB12 0x1240      ADDS     R2,R2,R0, LSL #+5
   \   0000003C   0x6051             STR      R1,[R2, #+4]
    114          	        #else
    115          	        RxNBUF[i].data = (uint8_t *)(uint32_t)&RxBuffer[i * RX_BUFFER_SIZE];
    116          	        #endif	
    117          	}
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \                     ??nbuf_flush_0:
   \   00000040   0x2814             CMP      R0,#+20
   \   00000042   0xDBE5             BLT.N    ??nbuf_flush_1
    118          
    119          	// Reset transmit descriptor ring
    120          	for (i = 0; i < NUM_TXBDS; i++)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE00B             B.N      ??nbuf_flush_2
    121          	{
    122          		TxNBUF[i].status = 0x0000;
   \                     ??nbuf_flush_3:
   \   00000048   0x0141             LSLS     R1,R0,#+5
   \   0000004A   0x....             LDR.N    R2,??DataTable6_2
   \   0000004C   0x6812             LDR      R2,[R2, #+0]
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x528B             STRH     R3,[R1, R2]
    123          		TxNBUF[i].length = 0;
   \   00000052   0x....             LDR.N    R1,??DataTable6_2
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x804A             STRH     R2,[R1, #+2]
    124          	}
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \                     ??nbuf_flush_2:
   \   00000060   0x2814             CMP      R0,#+20
   \   00000062   0xDBF1             BLT.N    ??nbuf_flush_3
    125          
    126          	// Set the Wrap bit on the last one in the ring
    127          	RxNBUF[NUM_RXBDS - 1].status |= RX_BD_W;
   \   00000064   0x....             LDR.N    R0,??DataTable6_4
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF8B0 0x0260      LDRH     R0,[R0, #+608]
   \   0000006C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000070   0x....             LDR.N    R1,??DataTable6_4
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0xF8A1 0x0260      STRH     R0,[R1, #+608]
    128          	TxNBUF[NUM_TXBDS - 1].status |= TX_BD_W;
   \   00000078   0x....             LDR.N    R0,??DataTable6_2
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF8B0 0x0260      LDRH     R0,[R0, #+608]
   \   00000080   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000084   0x....             LDR.N    R1,??DataTable6_2
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0xF8A1 0x0260      STRH     R0,[R1, #+608]
    129          }
   \   0000008C   0x4770             BX       LR               ;; return
    130          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          void 
    132          nbuf_init(int ch)
    133          {
    134          	// Set Receive Buffer Size
    135          	ENET_MRBR/*(ch)*/ = (uint16_t)RX_BUFFER_SIZE;  
   \                     nbuf_init:
   \   00000000   0x....             LDR.N    R0,??DataTable6_8  ;; 0x400c0188
   \   00000002   0xF44F 0x7180      MOV      R1,#+256
   \   00000006   0x6001             STR      R1,[R0, #+0]
    136            
    137           	// Point to the start of the Tx buffer descriptor queue
    138          	ENET_TDSR/*(ch)*/ = (uint32_t)TxNBUF;
   \   00000008   0x....             LDR.N    R0,??DataTable6_9  ;; 0x400c0184
   \   0000000A   0x....             LDR.N    R1,??DataTable6_2
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    139          	// Point to the start of the circular Rx buffer descriptor queue
    140          	ENET_RDSR/*(ch)*/ = (uint32_t)RxNBUF;
   \   00000010   0x....             LDR.N    R0,??DataTable6_10  ;; 0x400c0180
   \   00000012   0x....             LDR.N    R1,??DataTable6_4
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x6001             STR      R1,[R0, #+0]
    141          }
   \   00000018   0x4770             BX       LR               ;; return
    142          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    143          void 
    144          nbuf_start_rx(int ch)
    145          {
    146                  // Indicate Empty buffers have been produced
    147          	ENET_RDAR/*(ch)*/ = ENET_RDAR_RDAR_MASK;
   \                     nbuf_start_rx:
   \   00000000   0x....             LDR.N    R0,??DataTable6_11  ;; 0x400c0010
   \   00000002   0xF05F 0x7180      MOVS     R1,#+16777216
   \   00000006   0x6001             STR      R1,[R0, #+0]
    148          
    149                  while( !ENET_RDAR )
   \                     ??nbuf_start_rx_0:
   \   00000008   0x....             LDR.N    R0,??DataTable6_11  ;; 0x400c0010
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD0FB             BEQ.N    ??nbuf_start_rx_0
    150                  {
    151                    //If RDAR cannot be test,  
    152                    //printf("Error with internal ENET DMA engine\n");
    153                  }
    154          }
   \   00000010   0x4770             BX       LR               ;; return
    155          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    156          void 
    157          enet_get_received_packet(int ch, NBUF * rx_packet)
    158          {
   \                     enet_get_received_packet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    159          	int last_buffer;
    160          	uint16_t status;
    161          	int index_rxbd;
    162          
    163          	last_buffer = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    164          	rx_packet->length = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x804B             STRH     R3,[R1, #+2]
    165          	
    166          	index_rxbd = next_rxbd;
   \   00000008   0x....             LDR.N    R3,??DataTable6_1
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
    167              
    168          	if(RxNBUF[index_rxbd].status & RX_BD_E)
   \   0000000C   0x015C             LSLS     R4,R3,#+5
   \   0000000E   0x....             LDR.N    R5,??DataTable6_4
   \   00000010   0x682D             LDR      R5,[R5, #+0]
   \   00000012   0x5D64             LDRB     R4,[R4, R5]
   \   00000014   0x0624             LSLS     R4,R4,#+24
   \   00000016   0xD503             BPL.N    ??enet_get_received_packet_0
    169          	{
    170          		printf("Under processing. SHouldnt be here\n");
   \   00000018   0x....             LDR.N    R0,??DataTable6_12
   \   0000001A   0x.... 0x....      BL       printf
    171          		return;	
   \   0000001E   0xE047             B.N      ??enet_get_received_packet_1
    172          	}
    173                  #ifdef NBUF_LITTLE_ENDIAN
    174                  rx_packet->data = (uint8_t *)__REV((uint32_t)RxNBUF[index_rxbd].data);
   \                     ??enet_get_received_packet_0:
   \   00000020   0x....             LDR.N    R4,??DataTable6_4
   \   00000022   0x6824             LDR      R4,[R4, #+0]
   \   00000024   0xEB14 0x1443      ADDS     R4,R4,R3, LSL #+5
   \   00000028   0x6864             LDR      R4,[R4, #+4]
   \   0000002A   0xBA24             REV      R4,R4
   \   0000002C   0x604C             STR      R4,[R1, #+4]
   \   0000002E   0xE005             B.N      ??enet_get_received_packet_2
    175                  #else
    176                  rx_packet->data = (uint8_t *)(uint32_t)RxNBUF[index_rxbd].data;
    177                  #endif
    178          	// Update next_rxbd pointer and mark buffers as empty again
    179          	while(!last_buffer)
    180          	{
    181          		status = RxNBUF[index_rxbd].status;
    182          	        #ifdef NBUF_LITTLE_ENDIAN	
    183          		rx_packet->length = __REVSH(RxNBUF[index_rxbd].length);
    184                          #else
    185                          rx_packet->length = RxNBUF[index_rxbd].length;
    186                          #endif
    187                          #ifdef ENHANCED_BD
    188          		rx_packet->ebd_status = RxNBUF[index_rxbd].ebd_status;
    189          	            #ifdef NBUF_LITTLE_ENDIAN	
    190          		    rx_packet->timestamp = __REV(RxNBUF[index_rxbd].timestamp);
    191          		    rx_packet->length_proto_type = __REVSH(RxNBUF[index_rxbd].length_proto_type);
    192          		    rx_packet->payload_checksum = __REVSH(RxNBUF[index_rxbd].payload_checksum);
    193                              #else
    194          		    rx_packet->timestamp = RxNBUF[index_rxbd].timestamp;
    195          		    rx_packet->length_proto_type = RxNBUF[index_rxbd].length_proto_type;
    196          		    rx_packet->payload_checksum = RxNBUF[index_rxbd].payload_checksum;
    197                              #endif
    198                          #endif
    199          
    200          		last_buffer = (status & RX_BD_L);
    201          		if(status & RX_BD_W)
    202          		{
    203          			RxNBUF[index_rxbd].status = (RX_BD_W | RX_BD_E);
   \                     ??enet_get_received_packet_3:
   \   00000030   0x015B             LSLS     R3,R3,#+5
   \   00000032   0x....             LDR.N    R4,??DataTable6_4
   \   00000034   0x6824             LDR      R4,[R4, #+0]
   \   00000036   0x25A0             MOVS     R5,#+160
   \   00000038   0x531D             STRH     R5,[R3, R4]
    204          			index_rxbd = 0;
   \   0000003A   0x2300             MOVS     R3,#+0
    205          		}
   \                     ??enet_get_received_packet_2:
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD134             BNE.N    ??enet_get_received_packet_4
   \   00000040   0x0158             LSLS     R0,R3,#+5
   \   00000042   0x....             LDR.N    R2,??DataTable6_4
   \   00000044   0x6812             LDR      R2,[R2, #+0]
   \   00000046   0x5A82             LDRH     R2,[R0, R2]
   \   00000048   0x....             LDR.N    R0,??DataTable6_4
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xEB10 0x1043      ADDS     R0,R0,R3, LSL #+5
   \   00000050   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000054   0xBAC0             REVSH    R0,R0
   \   00000056   0x8048             STRH     R0,[R1, #+2]
   \   00000058   0x....             LDR.N    R0,??DataTable6_4
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xEB10 0x1043      ADDS     R0,R0,R3, LSL #+5
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0x6088             STR      R0,[R1, #+8]
   \   00000064   0x....             LDR.N    R0,??DataTable6_4
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xEB10 0x1043      ADDS     R0,R0,R3, LSL #+5
   \   0000006C   0x6940             LDR      R0,[R0, #+20]
   \   0000006E   0xBA00             REV      R0,R0
   \   00000070   0x6148             STR      R0,[R1, #+20]
   \   00000072   0x....             LDR.N    R0,??DataTable6_4
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xEB10 0x1043      ADDS     R0,R0,R3, LSL #+5
   \   0000007A   0xF9B0 0x000C      LDRSH    R0,[R0, #+12]
   \   0000007E   0xBAC0             REVSH    R0,R0
   \   00000080   0x8188             STRH     R0,[R1, #+12]
   \   00000082   0x....             LDR.N    R0,??DataTable6_4
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xEB10 0x1043      ADDS     R0,R0,R3, LSL #+5
   \   0000008A   0xF9B0 0x000E      LDRSH    R0,[R0, #+14]
   \   0000008E   0xBAC0             REVSH    R0,R0
   \   00000090   0x81C8             STRH     R0,[R1, #+14]
   \   00000092   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000094   0xF012 0x0008      ANDS     R0,R2,#0x8
   \   00000098   0x0694             LSLS     R4,R2,#+26
   \   0000009A   0xD4C9             BMI.N    ??enet_get_received_packet_3
    206          		else
    207          		{
    208          			RxNBUF[index_rxbd].status = RX_BD_E;
   \   0000009C   0x015C             LSLS     R4,R3,#+5
   \   0000009E   0x....             LDR.N    R5,??DataTable6_4
   \   000000A0   0x682D             LDR      R5,[R5, #+0]
   \   000000A2   0x2680             MOVS     R6,#+128
   \   000000A4   0x5366             STRH     R6,[R4, R5]
    209          			index_rxbd++;
   \   000000A6   0x1C5B             ADDS     R3,R3,#+1
   \   000000A8   0xE7C8             B.N      ??enet_get_received_packet_2
    210          		}
    211          	}
    212          	
    213          	// Update the global rxbd index
    214          	next_rxbd = index_rxbd;
   \                     ??enet_get_received_packet_4:
   \   000000AA   0x....             LDR.N    R0,??DataTable6_1
   \   000000AC   0x6003             STR      R3,[R0, #+0]
    215          	
    216          	// Put the last BD status in rx_packet->status as MISS flags and more 
    217          	// are updated in last BD
    218          	rx_packet->status = status;
   \   000000AE   0x800A             STRH     R2,[R1, #+0]
    219          }
   \                     ??enet_get_received_packet_1:
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return
    220          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    221          void enet_fill_txbds(int ch, NBUF * tx_packet)
    222          {
   \                     enet_fill_txbds:
   \   00000000   0xB470             PUSH     {R4-R6}
    223          	int num_txbds, i;
    224          	int index_txbd;
    225          
    226          	num_txbds = (tx_packet->length/TX_BUFFER_SIZE);
   \   00000002   0x8848             LDRH     R0,[R1, #+2]
   \   00000004   0xF44F 0x7280      MOV      R2,#+256
   \   00000008   0xFB90 0xF0F2      SDIV     R0,R0,R2
    227          	
    228          	index_txbd = next_txbd;
   \   0000000C   0x....             LDR.N    R2,??DataTable6
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
    229          	
    230          	if((num_txbds * TX_BUFFER_SIZE) < tx_packet->length)
   \   00000010   0xF44F 0x7380      MOV      R3,#+256
   \   00000014   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000018   0x884C             LDRH     R4,[R1, #+2]
   \   0000001A   0x42A3             CMP      R3,R4
   \   0000001C   0xDA00             BGE.N    ??enet_fill_txbds_0
    231          	{
    232          		num_txbds = num_txbds + 1;
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
    233          	}
    234              
    235          	// Fill Descriptors
    236          	for (i = 0; i < num_txbds; i++)
   \                     ??enet_fill_txbds_0:
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0xE01F             B.N      ??enet_fill_txbds_1
    237          	{
    238          		
    239          		TxNBUF[index_txbd].status = TX_BD_TC | TX_BD_R;
    240                          #ifdef ENHANCED_BD
    241          		TxNBUF[index_txbd].bdu = 0x00000000;
    242          		TxNBUF[index_txbd].ebd_status = TX_BD_INT | TX_BD_TS;// | TX_BD_IINS | TX_BD_PINS;
    243                          #endif
    244          
    245          		if(i == num_txbds - 1)
    246          		{
    247          		    #ifdef NBUF_LITTLE_ENDIAN 
    248          		    TxNBUF[index_txbd].length = __REVSH((tx_packet->length - (i*TX_BUFFER_SIZE)));
    249                              #else
    250                              TxNBUF[index_txbd].length = (tx_packet->length - (i*TX_BUFFER_SIZE));
    251                              #endif
    252          		    // Set the Last bit on the last BD
    253          		    TxNBUF[index_txbd].status |= TX_BD_L;		 
    254          		}
    255          		else
    256          		{
    257          		    #ifdef NBUF_LITTLE_ENDIAN 
    258          		    TxNBUF[index_txbd].length = __REVSH(TX_BUFFER_SIZE);
   \                     ??enet_fill_txbds_2:
   \   00000024   0x....             LDR.N    R4,??DataTable6_2
   \   00000026   0x6824             LDR      R4,[R4, #+0]
   \   00000028   0xEB14 0x1442      ADDS     R4,R4,R2, LSL #+5
   \   0000002C   0x2501             MOVS     R5,#+1
   \   0000002E   0x8065             STRH     R5,[R4, #+2]
    259          		    #else
    260          		    TxNBUF[index_txbd].length = TX_BUFFER_SIZE;
    261          		    #endif
    262          		}
    263          		
    264          		#ifdef USE_DEDICATED_TX_BUFFERS
    265          		  #ifdef NBUF_LITTLE_ENDIAN
    266          		  //Copy data to Tx buffers
    267                             memcpy((void *)__REV((uint32_t)TxNBUF[index_txbd].data), (void *)(((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE)),
    268                                    __REVSH(TxNBUF[index_txbd].length));  
    269                            #else
    270          		  // Copy data to Tx buffers
    271                            memcpy((void *)(uint32_t)TxNBUF[index_txbd].data, (void *)(((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE)),
    272                                    TxNBUF[index_txbd].length);         
    273                            #endif
    274                          #else
    275                            // Just update data pointer as data is aready there
    276                            #ifdef NBUF_LITTLE_ENDIAN 
    277                            TxNBUF[index_txbd].data = (uint8_t *)__REV((((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE)));
   \                     ??enet_fill_txbds_3:
   \   00000030   0x684C             LDR      R4,[R1, #+4]
   \   00000032   0xF44F 0x7580      MOV      R5,#+256
   \   00000036   0xFB05 0x4403      MLA      R4,R5,R3,R4
   \   0000003A   0xBA24             REV      R4,R4
   \   0000003C   0x....             LDR.N    R5,??DataTable6_2
   \   0000003E   0x682D             LDR      R5,[R5, #+0]
   \   00000040   0xEB15 0x1542      ADDS     R5,R5,R2, LSL #+5
   \   00000044   0x606C             STR      R4,[R5, #+4]
    278                            #else
    279                            TxNBUF[index_txbd].data = (uint8_t *)(((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE));
    280                            #endif 
    281                          #endif
    282          
    283          		// Wrap if this was last TxBD
    284          		if(++index_txbd == NUM_TXBDS)
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \   00000048   0x2A14             CMP      R2,#+20
   \   0000004A   0xD10A             BNE.N    ??enet_fill_txbds_4
    285          		{
    286          			TxNBUF[NUM_TXBDS - 1].status |= TX_BD_W;
   \   0000004C   0x....             LDR.N    R2,??DataTable6_2
   \   0000004E   0x6812             LDR      R2,[R2, #+0]
   \   00000050   0xF8B2 0x2260      LDRH     R2,[R2, #+608]
   \   00000054   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   00000058   0x....             LDR.N    R4,??DataTable6_2
   \   0000005A   0x6824             LDR      R4,[R4, #+0]
   \   0000005C   0xF8A4 0x2260      STRH     R2,[R4, #+608]
    287          			index_txbd = 0;
   \   00000060   0x2200             MOVS     R2,#+0
    288          		}
   \                     ??enet_fill_txbds_4:
   \   00000062   0x1C5B             ADDS     R3,R3,#+1
   \                     ??enet_fill_txbds_1:
   \   00000064   0x4283             CMP      R3,R0
   \   00000066   0xDA29             BGE.N    ??enet_fill_txbds_5
   \   00000068   0x0154             LSLS     R4,R2,#+5
   \   0000006A   0x....             LDR.N    R5,??DataTable6_2
   \   0000006C   0x682D             LDR      R5,[R5, #+0]
   \   0000006E   0x2684             MOVS     R6,#+132
   \   00000070   0x5366             STRH     R6,[R4, R5]
   \   00000072   0x....             LDR.N    R4,??DataTable6_2
   \   00000074   0x6824             LDR      R4,[R4, #+0]
   \   00000076   0xEB14 0x1442      ADDS     R4,R4,R2, LSL #+5
   \   0000007A   0x2500             MOVS     R5,#+0
   \   0000007C   0x6125             STR      R5,[R4, #+16]
   \   0000007E   0x....             LDR.N    R4,??DataTable6_2
   \   00000080   0x6824             LDR      R4,[R4, #+0]
   \   00000082   0xEB14 0x1442      ADDS     R4,R4,R2, LSL #+5
   \   00000086   0x2560             MOVS     R5,#+96
   \   00000088   0x60A5             STR      R5,[R4, #+8]
   \   0000008A   0x1E44             SUBS     R4,R0,#+1
   \   0000008C   0x42A3             CMP      R3,R4
   \   0000008E   0xD1C9             BNE.N    ??enet_fill_txbds_2
   \   00000090   0x884C             LDRH     R4,[R1, #+2]
   \   00000092   0xF44F 0x7580      MOV      R5,#+256
   \   00000096   0xFB05 0x4413      MLS      R4,R5,R3,R4
   \   0000009A   0xBAE4             REVSH    R4,R4
   \   0000009C   0x....             LDR.N    R5,??DataTable6_2
   \   0000009E   0x682D             LDR      R5,[R5, #+0]
   \   000000A0   0xEB15 0x1542      ADDS     R5,R5,R2, LSL #+5
   \   000000A4   0x806C             STRH     R4,[R5, #+2]
   \   000000A6   0x0154             LSLS     R4,R2,#+5
   \   000000A8   0x....             LDR.N    R5,??DataTable6_2
   \   000000AA   0x682D             LDR      R5,[R5, #+0]
   \   000000AC   0x5B64             LDRH     R4,[R4, R5]
   \   000000AE   0xF054 0x0408      ORRS     R4,R4,#0x8
   \   000000B2   0x0155             LSLS     R5,R2,#+5
   \   000000B4   0x....             LDR.N    R6,??DataTable6_2
   \   000000B6   0x6836             LDR      R6,[R6, #+0]
   \   000000B8   0x53AC             STRH     R4,[R5, R6]
   \   000000BA   0xE7B9             B.N      ??enet_fill_txbds_3
    289          	}
    290          	
    291          	// Update the global txbd index
    292          	next_txbd = index_txbd;
   \                     ??enet_fill_txbds_5:
   \   000000BC   0x....             LDR.N    R0,??DataTable6
   \   000000BE   0x6002             STR      R2,[R0, #+0]
    293          }
   \   000000C0   0xBC70             POP      {R4-R6}
   \   000000C2   0x4770             BX       LR               ;; return
    294          

   \                                 In section .text, align 2, keep-with-next
    295          void 
    296          enet_transmit_packet(int ch, NBUF * tx_packet)
    297          {
   \                     enet_transmit_packet:
   \   00000000   0xB580             PUSH     {R7,LR}
    298          	enet_fill_txbds(ch,tx_packet);
   \   00000002   0x.... 0x....      BL       enet_fill_txbds
    299          	
    300          	// Indicate that Descriptors are ready to transmit 
    301          	ENET_TDAR/*(ch)*/ = ENET_TDAR_TDAR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable6_13  ;; 0x400c0014
   \   00000008   0xF05F 0x7180      MOVS     R1,#+16777216
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    302          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     next_txbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     next_rxbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     TxNBUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     unaligned_txbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     RxNBUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     unaligned_rxbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     unaligned_rxbuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x400C0188         DC32     0x400c0188

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x400C0184         DC32     0x400c0184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x400C0180         DC32     0x400c0180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x400C0010         DC32     0x400c0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     `?<Constant "Under processing. SHo...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x400C0014         DC32     0x400c0014

   \                                 In section .rodata, align 4
   \                     `?<Constant "Under processing. SHo...">`:
   \   00000000   0x55 0x6E          DC8 "Under processing. SHouldnt be here\012"
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x70 0x72    
   \              0x6F 0x63    
   \              0x65 0x73    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x2E 0x20    
   \              0x53 0x48    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x6E 0x74    
   \              0x20 0x62    
   \              0x65 0x20    
   \              0x68 0x65    
   \              0x72 0x65    
   \              0x0A 0x00    
    303          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       12  enet_fill_txbds
       16  enet_get_received_packet
             16 -> printf
        8  enet_transmit_packet
              8 -> enet_fill_txbds
        0  nbuf_alloc
        0  nbuf_flush
        0  nbuf_init
        0  nbuf_start_rx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      36  ?<Constant "Under processing. SHo...">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  RxBuffer
       4  RxNBUF
       4  TxNBUF
     196  enet_fill_txbds
     178  enet_get_received_packet
      16  enet_transmit_packet
     210  nbuf_alloc
     142  nbuf_flush
      26  nbuf_init
      18  nbuf_start_rx
       4  next_rxbd
       4  next_txbd
     656  unaligned_rxbd
    5136  unaligned_rxbuffer
     656  unaligned_txbd

 
 6 468 bytes in section .bss
    36 bytes in section .rodata
   842 bytes in section .text
 
   842 bytes of CODE  memory
    36 bytes of CONST memory
 6 468 bytes of DATA  memory

Errors: none
Warnings: none
