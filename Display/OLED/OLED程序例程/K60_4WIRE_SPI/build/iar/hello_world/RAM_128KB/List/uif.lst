###############################################################################
#                                                                             #
#                                                       07/May/2014  16:39:06 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\common\uif.c                                  #
#    Command line =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\common\uif.c -D IAR -D TWR_K60N512 -lCN       #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -lB         #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -o          #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\ --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.0           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\projects\hello #
#                    _world\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kin #
#                    etisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\com #
#                    mon\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\headers #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\a #
#                    dc16\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kinet #
#                    isK60_Demo_OLED\build\iar\hello_world\..\..\..\src\drive #
#                    rs\enet\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Ki #
#                    netisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\dr #
#                    ivers\pmc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\ #
#                    KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\ #
#                    drivers\rtc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³ #
#                    Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\sr #
#                    c\drivers\lptmr\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐ #
#                    òÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\. #
#                    .\src\drivers\uart\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\ #
#                    ³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\. #
#                    .\..\src\drivers\mcg\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁ #
#                    Ï\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\.. #
#                    \..\..\src\drivers\wdog\ -I                              #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\platforms\ -I  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\drivers\ftm\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\SPI #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\O #
#                    LED\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\ -On             #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\uif.lst      #
#    Object file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\uif.o         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\src\common\uif.c
      1          /*
      2           * File:    uif.c
      3           * Purpose: Provide an interactive user interface
      4           *              
      5           * Notes:   The commands, set/show parameters, and prompt are configured 
      6           *          at the project level
      7           */
      8          
      9          #include "common.h"
     10          #include "uif.h"
     11          
     12          /********************************************************************/
     13          /*
     14           * Global messages -- constant strings
     15           */

   \                                 In section .rodata, align 4
     16          const char HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     17              "Enter 'help' for help.\n";
     18          

   \                                 In section .rodata, align 4
     19          const char INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     20              "Error: Invalid argument: %s\n";
     21          

   \                                 In section .rodata, align 4
     22          const char INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     23              "Error: Invalid value: %s\n";
     24          
     25          /*
     26           * Strings used by this file only
     27           */

   \                                 In section .rodata, align 4
     28          static const char INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     29              "Error: No such command: %s\n";
     30          

   \                                 In section .rodata, align 4
     31          static const char HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     32              "%8s  %-25s %s %s\n";
     33          

   \                                 In section .rodata, align 4
     34          static const char SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     35              "Error: Invalid syntax for: %s\n";
     36          

   \                                 In section .rodata, align 4
     37          static const char INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     38              "Error:  Invalid set/show option: %s\n";
     39          

   \                                 In section .rodata, align 4
     40          static const char OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     41              "%12s: ";
     42          

   \                                 In section .bss, align 4
     43          static char cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
     44          static char cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
     45          
     46          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     47          char *
     48          get_line (char *line)
     49          {
   \                     get_line:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     50              int pos;
     51              int ch;
     52          
     53              pos = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
     54              ch = (int)in_char();
   \   00000008   0x.... 0x....      BL       in_char
   \   0000000C   0x0006             MOVS     R6,R0
     55              while ( (ch != 0x0D /* CR */) &&
     56                      (ch != 0x0A /* LF/NL */) &&
     57                      (pos < UIF_MAX_LINE))
   \                     ??get_line_0:
   \   0000000E   0x2E0D             CMP      R6,#+13
   \   00000010   0xD026             BEQ.N    ??get_line_1
   \   00000012   0x2E0A             CMP      R6,#+10
   \   00000014   0xD024             BEQ.N    ??get_line_1
   \   00000016   0x2D50             CMP      R5,#+80
   \   00000018   0xDA22             BGE.N    ??get_line_1
     58              {
     59                  switch (ch)
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x2808             CMP      R0,#+8
   \   0000001E   0xD001             BEQ.N    ??get_line_2
   \   00000020   0x287F             CMP      R0,#+127
   \   00000022   0xD10C             BNE.N    ??get_line_3
     60                  {
     61                      case 0x08:      /* Backspace */
     62                      case 0x7F:      /* Delete */
     63                          if (pos > 0)
   \                     ??get_line_2:
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xDB09             BLT.N    ??get_line_4
     64                          {
     65                              pos -= 1;
   \   00000028   0x1E6D             SUBS     R5,R5,#+1
     66                              out_char(0x08);    /* backspace */
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0x.... 0x....      BL       out_char
     67                              out_char(' ');
   \   00000030   0x2020             MOVS     R0,#+32
   \   00000032   0x.... 0x....      BL       out_char
     68                              out_char(0x08);    /* backspace */
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x.... 0x....      BL       out_char
     69                          }
     70                          break;
   \                     ??get_line_4:
   \   0000003C   0xE00C             B.N      ??get_line_5
     71                      default:
     72                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_3:
   \   0000003E   0x1C68             ADDS     R0,R5,#+1
   \   00000040   0x2850             CMP      R0,#+80
   \   00000042   0xDA09             BGE.N    ??get_line_6
     73                          {
     74                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000044   0x2E20             CMP      R6,#+32
   \   00000046   0xDB07             BLT.N    ??get_line_6
   \   00000048   0x2E80             CMP      R6,#+128
   \   0000004A   0xDA05             BGE.N    ??get_line_6
     75                              {
     76                                  line[pos++] = (char)ch;
   \   0000004C   0x552E             STRB     R6,[R5, R4]
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
     77                                  out_char((char)ch);
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x.... 0x....      BL       out_char
     78                              }
     79                          }
     80                          break;
     81                  }
     82                  ch = (int)in_char();
   \                     ??get_line_6:
   \                     ??get_line_5:
   \   00000058   0x.... 0x....      BL       in_char
   \   0000005C   0x0006             MOVS     R6,R0
   \   0000005E   0xE7D6             B.N      ??get_line_0
     83              }
     84              line[pos] = '\0';
   \                     ??get_line_1:
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x5528             STRB     R0,[R5, R4]
     85              out_char(0x0D);    /* CR */
   \   00000064   0x200D             MOVS     R0,#+13
   \   00000066   0x.... 0x....      BL       out_char
     86              out_char(0x0A);    /* LF */
   \   0000006A   0x200A             MOVS     R0,#+10
   \   0000006C   0x.... 0x....      BL       out_char
     87          
     88              return line;
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
     89          }
     90          
     91          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          int
     93          make_argv (char *cmdline, char *argv[])
     94          {
   \                     make_argv:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
     95              int argc, i, in_text;
     96          
     97              /* 
     98               * Break cmdline into strings and argv
     99               * It is permissible for argv to be NULL, in which case
    100               * the purpose of this routine becomes to count args
    101               */
    102              argc = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x0028             MOVS     R0,R5
    103              i = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x002B             MOVS     R3,R5
    104              in_text = FALSE;
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x002C             MOVS     R4,R5
    105              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
   \                     ??make_argv_0:
   \   00000010   0x5C9D             LDRB     R5,[R3, R2]
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD01C             BEQ.N    ??make_argv_1
    106              {
    107                  if (((cmdline[i] == ' ')   ||
    108                       (cmdline[i] == '\t')) )
   \   00000016   0x5C9D             LDRB     R5,[R3, R2]
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD002             BEQ.N    ??make_argv_2
   \   0000001C   0x5C9D             LDRB     R5,[R3, R2]
   \   0000001E   0x2D09             CMP      R5,#+9
   \   00000020   0xD106             BNE.N    ??make_argv_3
    109                  {
    110                      if (in_text)
   \                     ??make_argv_2:
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD012             BEQ.N    ??make_argv_4
    111                      {
    112                          /* end of command line argument */
    113                          cmdline[i] = '\0';
   \   00000026   0x2500             MOVS     R5,#+0
   \   00000028   0x549D             STRB     R5,[R3, R2]
    114                          in_text = FALSE;
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x002C             MOVS     R4,R5
   \   0000002E   0xE00D             B.N      ??make_argv_4
    115                      }
    116                      else
    117                      {
    118                          /* still looking for next argument */
    119                          
    120                      }
    121                  }
    122                  else
    123                  {
    124                      /* got non-whitespace character */
    125                      if (in_text)
   \                     ??make_argv_3:
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD10B             BNE.N    ??make_argv_4
    126                      {
    127                      }
    128                      else
    129                      {
    130                          /* start of an argument */
    131                          in_text = TRUE;
   \   00000034   0x2501             MOVS     R5,#+1
   \   00000036   0x002C             MOVS     R4,R5
    132                          if (argc < UIF_MAX_ARGS)
   \   00000038   0x280A             CMP      R0,#+10
   \   0000003A   0xDA06             BGE.N    ??make_argv_5
    133                          {
    134                              if (argv != NULL)
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD002             BEQ.N    ??make_argv_6
    135                                  argv[argc] = &cmdline[i];
   \   00000040   0x189D             ADDS     R5,R3,R2
   \   00000042   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
    136                              argc++;
   \                     ??make_argv_6:
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xE000             B.N      ??make_argv_4
    137                          }
    138                          else
    139                              /*return argc;*/
    140                              break;
   \                     ??make_argv_5:
   \   0000004A   0xE001             B.N      ??make_argv_1
    141                      }
    142          
    143                  }
    144                  i++;    /* proceed to next character */
   \                     ??make_argv_4:
   \   0000004C   0x1C5B             ADDS     R3,R3,#+1
   \   0000004E   0xE7DF             B.N      ??make_argv_0
    145              }
    146              if (argv != NULL)
   \                     ??make_argv_1:
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD002             BEQ.N    ??make_argv_7
    147                  argv[argc] = NULL;
   \   00000054   0x2500             MOVS     R5,#+0
   \   00000056   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
    148              return argc;
   \                     ??make_argv_7:
   \   0000005A   0xBC30             POP      {R4,R5}
   \   0000005C   0x4770             BX       LR               ;; return
    149          }
    150          
    151          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    152          void
    153          run_cmd (void)
    154          {
   \                     run_cmd:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    155              /*
    156               * Global array of pointers to emulate C argc,argv interface
    157               */
    158              int argc;
    159              char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    160          
    161              get_line(cmdline1);
   \   00000004   0x....             LDR.N    R0,??DataTable3_3
   \   00000006   0x.... 0x....      BL       get_line
    162          
    163              if (!(argc = make_argv(cmdline1,argv)))
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x....             LDR.N    R0,??DataTable3_3
   \   0000000E   0x.... 0x....      BL       make_argv
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD108             BNE.N    ??run_cmd_0
    164              {
    165                  /* no command entered, just a blank line */
    166                  strcpy(cmdline1,cmdline2);
   \   00000018   0x....             LDR.N    R1,??DataTable3_4
   \   0000001A   0x....             LDR.N    R0,??DataTable3_3
   \   0000001C   0x.... 0x....      BL       strcpy
    167                  argc = make_argv(cmdline1,argv);
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x....             LDR.N    R0,??DataTable3_3
   \   00000024   0x.... 0x....      BL       make_argv
   \   00000028   0x0004             MOVS     R4,R0
    168              }
    169              cmdline2[0] = '\0';
   \                     ??run_cmd_0:
   \   0000002A   0x....             LDR.N    R0,??DataTable3_4
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    170          
    171              if (argc)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD041             BEQ.N    ??run_cmd_1
    172              {
    173                  int i;
    174                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x0005             MOVS     R5,R0
   \                     ??run_cmd_2:
   \   00000038   0x....             LDR.N    R0,??DataTable3_5
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xDA34             BGE.N    ??run_cmd_3
    175                  {
    176                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000040   0x9900             LDR      R1,[SP, #+0]
   \   00000042   0x201C             MOVS     R0,#+28
   \   00000044   0x....             LDR.N    R2,??DataTable3_6
   \   00000046   0xFB00 0x2005      MLA      R0,R0,R5,R2
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      BL       strcasecmp
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD128             BNE.N    ??run_cmd_4
    177                      {
    178                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    179                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   00000054   0x1E60             SUBS     R0,R4,#+1
   \   00000056   0x211C             MOVS     R1,#+28
   \   00000058   0x....             LDR.N    R2,??DataTable3_6
   \   0000005A   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   0000005E   0x6849             LDR      R1,[R1, #+4]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xDB1B             BLT.N    ??run_cmd_5
   \   00000064   0x201C             MOVS     R0,#+28
   \   00000066   0x....             LDR.N    R1,??DataTable3_6
   \   00000068   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000006C   0x6880             LDR      R0,[R0, #+8]
   \   0000006E   0x1E61             SUBS     R1,R4,#+1
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xDB13             BLT.N    ??run_cmd_5
    180                          {
    181                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   00000074   0x201C             MOVS     R0,#+28
   \   00000076   0x....             LDR.N    R1,??DataTable3_6
   \   00000078   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000007C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000007E   0x07C0             LSLS     R0,R0,#+31
   \   00000080   0xD503             BPL.N    ??run_cmd_6
    182                              {
    183                                  strcpy(cmdline2,argv[0]);
   \   00000082   0x9900             LDR      R1,[SP, #+0]
   \   00000084   0x....             LDR.N    R0,??DataTable3_4
   \   00000086   0x.... 0x....      BL       strcpy
    184                              }
    185                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6:
   \   0000008A   0xA900             ADD      R1,SP,#+0
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x221C             MOVS     R2,#+28
   \   00000090   0x....             LDR.N    R3,??DataTable3_6
   \   00000092   0xFB02 0x3205      MLA      R2,R2,R5,R3
   \   00000096   0x6912             LDR      R2,[R2, #+16]
   \   00000098   0x4790             BLX      R2
    186                              return;
   \   0000009A   0xE00D             B.N      ??run_cmd_7
    187                          }
    188                          else
    189                          {
    190                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5:
   \   0000009C   0x9900             LDR      R1,[SP, #+0]
   \   0000009E   0x....             LDR.N    R0,??DataTable3_7
   \   000000A0   0x.... 0x....      BL       printf
    191                              return;
   \   000000A4   0xE008             B.N      ??run_cmd_7
    192                          }
    193                      }
    194                  }
   \                     ??run_cmd_4:
   \   000000A6   0x1C6D             ADDS     R5,R5,#+1
   \   000000A8   0xE7C6             B.N      ??run_cmd_2
    195                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_3:
   \   000000AA   0x9900             LDR      R1,[SP, #+0]
   \   000000AC   0x....             LDR.N    R0,??DataTable3_8
   \   000000AE   0x.... 0x....      BL       printf
    196                  printf(HELPMSG);
   \   000000B2   0x....             LDR.N    R0,??DataTable3_9
   \   000000B4   0x.... 0x....      BL       printf
    197              }
    198          }
   \                     ??run_cmd_1:
   \                     ??run_cmd_7:
   \   000000B8   0xB00B             ADD      SP,SP,#+44
   \   000000BA   0xBD30             POP      {R4,R5,PC}       ;; return
    199          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    200          uint32
    201          get_value (char *s, int *success, int base)
    202          {
   \                     get_value:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    203              uint32 value;
    204              char *p;
    205          
    206              value = strtoul(s,&p,base);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       strtoul
   \   00000012   0x0007             MOVS     R7,R0
    207              if ((value == 0) && (p == s))
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD106             BNE.N    ??get_value_0
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD103             BNE.N    ??get_value_0
    208              {
    209                  *success = FALSE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6028             STR      R0,[R5, #+0]
    210                  return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE002             B.N      ??get_value_1
    211              }
    212              else
    213              {
    214                  *success = TRUE;
   \                     ??get_value_0:
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x6028             STR      R0,[R5, #+0]
    215                  return value;
   \   0000002A   0x0038             MOVS     R0,R7
   \                     ??get_value_1:
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    216              }
    217          }
    218          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    219          void
    220          uif_cmd_help (int argc, char **argv)
    221          {
   \                     uif_cmd_help:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    222              int index;
    223              
    224              (void)argc;
    225              (void)argv;
    226              
    227              printf("\n");
   \   00000008   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000000A   0x.... 0x....      BL       printf
    228              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0006             MOVS     R6,R0
   \                     ??uif_cmd_help_0:
   \   00000012   0x....             LDR.N    R0,??DataTable3_5
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xDA19             BGE.N    ??uif_cmd_help_1
    229              {
    230                  printf(HELPFORMAT,
    231                      UIF_CMDTAB[index].cmd,
    232                      UIF_CMDTAB[index].description,
    233                      UIF_CMDTAB[index].cmd,
    234                      UIF_CMDTAB[index].syntax);
   \   0000001A   0x201C             MOVS     R0,#+28
   \   0000001C   0x....             LDR.N    R1,??DataTable3_6
   \   0000001E   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x201C             MOVS     R0,#+28
   \   00000028   0x....             LDR.N    R1,??DataTable3_6
   \   0000002A   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000002E   0x6803             LDR      R3,[R0, #+0]
   \   00000030   0x201C             MOVS     R0,#+28
   \   00000032   0x....             LDR.N    R1,??DataTable3_6
   \   00000034   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000038   0x6942             LDR      R2,[R0, #+20]
   \   0000003A   0x201C             MOVS     R0,#+28
   \   0000003C   0x....             LDR.N    R1,??DataTable3_6
   \   0000003E   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x....             LDR.N    R0,??DataTable3_10
   \   00000046   0x.... 0x....      BL       printf
    235              }
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \   0000004C   0xE7E1             B.N      ??uif_cmd_help_0
    236              printf("\n");
   \                     ??uif_cmd_help_1:
   \   0000004E   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000050   0x.... 0x....      BL       printf
    237          }
   \   00000054   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    238          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    239          void
    240          uif_cmd_set (int argc, char **argv)
    241          {
   \                     uif_cmd_set:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    242              int index;
    243          
    244              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    245              if (argc == 1)
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD11E             BNE.N    ??uif_cmd_set_0
    246              {
    247                  printf("Valid 'set' options:\n");
   \   00000010   0x....             LDR.N    R0,??DataTable3_11
   \   00000012   0x.... 0x....      BL       printf
    248                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0006             MOVS     R6,R0
   \                     ??uif_cmd_set_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable3_12
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x4286             CMP      R6,R0
   \   00000020   0xDA11             BGE.N    ??uif_cmd_set_2
    249                  {
    250                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000022   0x2014             MOVS     R0,#+20
   \   00000024   0x....             LDR.N    R1,??DataTable3_13
   \   00000026   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x....             LDR.N    R0,??DataTable3_14
   \   0000002E   0x.... 0x....      BL       printf
    251                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   00000032   0x2014             MOVS     R0,#+20
   \   00000034   0x....             LDR.N    R1,??DataTable3_13
   \   00000036   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000003A   0x6901             LDR      R1,[R0, #+16]
   \   0000003C   0x....             ADR.N    R0,??DataTable3_1  ;; "%s\n"
   \   0000003E   0x.... 0x....      BL       printf
    252                  }
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \   00000044   0xE7E9             B.N      ??uif_cmd_set_1
    253                  printf("\n");
   \                     ??uif_cmd_set_2:
   \   00000046   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000048   0x.... 0x....      BL       printf
    254                  return;
   \   0000004C   0xE039             B.N      ??uif_cmd_set_3
    255              }
    256          
    257              if (argc != 3)
   \                     ??uif_cmd_set_0:
   \   0000004E   0x2C03             CMP      R4,#+3
   \   00000050   0xD003             BEQ.N    ??uif_cmd_set_4
    258              {
    259                  printf("Error: Invalid argument list\n");
   \   00000052   0x....             LDR.N    R0,??DataTable3_15
   \   00000054   0x.... 0x....      BL       printf
    260                  return;
   \   00000058   0xE033             B.N      ??uif_cmd_set_3
    261              }
    262          
    263              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4:
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0006             MOVS     R6,R0
   \                     ??uif_cmd_set_5:
   \   0000005E   0x....             LDR.N    R0,??DataTable3_12
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x4286             CMP      R6,R0
   \   00000064   0xDA29             BGE.N    ??uif_cmd_set_6
    264              {
    265                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000066   0x6869             LDR      R1,[R5, #+4]
   \   00000068   0x2014             MOVS     R0,#+20
   \   0000006A   0x....             LDR.N    R2,??DataTable3_13
   \   0000006C   0xFB00 0x2006      MLA      R0,R0,R6,R2
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x.... 0x....      BL       strcasecmp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD11D             BNE.N    ??uif_cmd_set_7
    266                  {
    267                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    268                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   0000007A   0x1EA0             SUBS     R0,R4,#+2
   \   0000007C   0x2114             MOVS     R1,#+20
   \   0000007E   0x....             LDR.N    R2,??DataTable3_13
   \   00000080   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   00000084   0x6849             LDR      R1,[R1, #+4]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDB10             BLT.N    ??uif_cmd_set_8
   \   0000008A   0x2014             MOVS     R0,#+20
   \   0000008C   0x....             LDR.N    R1,??DataTable3_13
   \   0000008E   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000092   0x6880             LDR      R0,[R0, #+8]
   \   00000094   0x1EA1             SUBS     R1,R4,#+2
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xDB08             BLT.N    ??uif_cmd_set_8
    269                      {
    270                          UIF_SETCMDTAB[index].func(argc,argv);
   \   0000009A   0x0029             MOVS     R1,R5
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x2214             MOVS     R2,#+20
   \   000000A0   0x....             LDR.N    R3,??DataTable3_13
   \   000000A2   0xFB02 0x3206      MLA      R2,R2,R6,R3
   \   000000A6   0x68D2             LDR      R2,[R2, #+12]
   \   000000A8   0x4790             BLX      R2
    271                          return;
   \   000000AA   0xE00A             B.N      ??uif_cmd_set_3
    272                      }
    273                      else
    274                      {
    275                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8:
   \   000000AC   0x6869             LDR      R1,[R5, #+4]
   \   000000AE   0x....             LDR.N    R0,??DataTable3_16
   \   000000B0   0x.... 0x....      BL       printf
    276                          return;
   \   000000B4   0xE005             B.N      ??uif_cmd_set_3
    277                      }
    278                  }
    279              }
   \                     ??uif_cmd_set_7:
   \   000000B6   0x1C76             ADDS     R6,R6,#+1
   \   000000B8   0xE7D1             B.N      ??uif_cmd_set_5
    280              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_6:
   \   000000BA   0x6869             LDR      R1,[R5, #+4]
   \   000000BC   0x....             LDR.N    R0,??DataTable3_17
   \   000000BE   0x.... 0x....      BL       printf
    281          }
   \                     ??uif_cmd_set_3:
   \   000000C2   0xBD70             POP      {R4-R6,PC}       ;; return
    282          
    283          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    284          void
    285          uif_cmd_show (int argc, char **argv)
    286          {
   \                     uif_cmd_show:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    287              int index;
    288          
    289              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    290              if (argc == 1)
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD122             BNE.N    ??uif_cmd_show_0
    291              {
    292                  /*
    293                   * Show all Option settings
    294                   */
    295                  argc = 2;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x0004             MOVS     R4,R0
    296                  argv[2] = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x60A8             STR      R0,[R5, #+8]
    297                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0006             MOVS     R6,R0
   \                     ??uif_cmd_show_1:
   \   0000001C   0x....             LDR.N    R0,??DataTable3_12
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4286             CMP      R6,R0
   \   00000022   0xDA14             BGE.N    ??uif_cmd_show_2
    298                  {
    299                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000024   0x2014             MOVS     R0,#+20
   \   00000026   0x....             LDR.N    R1,??DataTable3_13
   \   00000028   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x....             LDR.N    R0,??DataTable3_14
   \   00000030   0x.... 0x....      BL       printf
    300                      UIF_SETCMDTAB[index].func(argc,argv);
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x2214             MOVS     R2,#+20
   \   0000003A   0x....             LDR.N    R3,??DataTable3_13
   \   0000003C   0xFB02 0x3206      MLA      R2,R2,R6,R3
   \   00000040   0x68D2             LDR      R2,[R2, #+12]
   \   00000042   0x4790             BLX      R2
    301                      printf("\n");
   \   00000044   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000046   0x.... 0x....      BL       printf
    302                  }
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \   0000004C   0xE7E6             B.N      ??uif_cmd_show_1
    303                  printf("\n");
   \                     ??uif_cmd_show_2:
   \   0000004E   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000050   0x.... 0x....      BL       printf
    304                  return;
   \   00000054   0xE03E             B.N      ??uif_cmd_show_3
    305              }
    306          
    307              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0006             MOVS     R6,R0
   \                     ??uif_cmd_show_4:
   \   0000005A   0x....             LDR.N    R0,??DataTable3_12
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x4286             CMP      R6,R0
   \   00000060   0xDA34             BGE.N    ??uif_cmd_show_5
    308              {
    309                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000062   0x6869             LDR      R1,[R5, #+4]
   \   00000064   0x2014             MOVS     R0,#+20
   \   00000066   0x....             LDR.N    R2,??DataTable3_13
   \   00000068   0xFB00 0x2006      MLA      R0,R0,R6,R2
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       strcasecmp
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD128             BNE.N    ??uif_cmd_show_6
    310                  {
    311                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    312                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000076   0x1EA0             SUBS     R0,R4,#+2
   \   00000078   0x2114             MOVS     R1,#+20
   \   0000007A   0x....             LDR.N    R2,??DataTable3_13
   \   0000007C   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   00000080   0x6849             LDR      R1,[R1, #+4]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xDB1B             BLT.N    ??uif_cmd_show_7
   \   00000086   0x2014             MOVS     R0,#+20
   \   00000088   0x....             LDR.N    R1,??DataTable3_13
   \   0000008A   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000008E   0x6880             LDR      R0,[R0, #+8]
   \   00000090   0x1EA1             SUBS     R1,R4,#+2
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xDB13             BLT.N    ??uif_cmd_show_7
    313                      {
    314                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000096   0x2014             MOVS     R0,#+20
   \   00000098   0x....             LDR.N    R1,??DataTable3_13
   \   0000009A   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000009E   0x6801             LDR      R1,[R0, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable3_14
   \   000000A2   0x.... 0x....      BL       printf
    315                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000A6   0x0029             MOVS     R1,R5
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x2214             MOVS     R2,#+20
   \   000000AC   0x....             LDR.N    R3,??DataTable3_13
   \   000000AE   0xFB02 0x3206      MLA      R2,R2,R6,R3
   \   000000B2   0x68D2             LDR      R2,[R2, #+12]
   \   000000B4   0x4790             BLX      R2
    316                          printf("\n\n");
   \   000000B6   0x....             ADR.N    R0,??DataTable3_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000B8   0x.... 0x....      BL       printf
    317                          return;
   \   000000BC   0xE00A             B.N      ??uif_cmd_show_3
    318                      }
    319                      else
    320                      {
    321                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7:
   \   000000BE   0x6869             LDR      R1,[R5, #+4]
   \   000000C0   0x....             LDR.N    R0,??DataTable3_16
   \   000000C2   0x.... 0x....      BL       printf
    322                          return;
   \   000000C6   0xE005             B.N      ??uif_cmd_show_3
    323                      }
    324                  }
    325              }
   \                     ??uif_cmd_show_6:
   \   000000C8   0x1C76             ADDS     R6,R6,#+1
   \   000000CA   0xE7C6             B.N      ??uif_cmd_show_4
    326              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_5:
   \   000000CC   0x6869             LDR      R1,[R5, #+4]
   \   000000CE   0x....             LDR.N    R0,??DataTable3_17
   \   000000D0   0x.... 0x....      BL       printf
    327          }
   \                     ??uif_cmd_show_3:
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     `?<Constant "Valid \\'set\\' options:\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x........         DC32     `?<Constant "Error: Invalid argume...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x........         DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x........         DC32     INVOPT

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     `?<Constant "Valid \\'set\\' options:\\n">`:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Error: Invalid argume...">`:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    328          
    329          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  get_line
             16 -> in_char
             16 -> out_char
       24  get_value
             24 -> strtoul
        8  make_argv
       56  run_cmd
             56 -- Indirect call
             56 -> get_line
             56 -> make_argv
             56 -> printf
             56 -> strcasecmp
             56 -> strcpy
       24  uif_cmd_help
             24 -> printf
       16  uif_cmd_set
             16 -- Indirect call
             16 -> printf
             16 -> strcasecmp
       16  uif_cmd_show
             16 -- Indirect call
             16 -> printf
             16 -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "%s\n">
      32  ?<Constant "Error: Invalid argume...">
      24  ?<Constant "Valid \'set\' options:\n">
       2  ?<Constant "\n">
       4  ?<Constant "\n\n">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     116  get_line
      46  get_value
      94  make_argv
     188  run_cmd
      86  uif_cmd_help
     196  uif_cmd_set
     214  uif_cmd_show

 
   160 bytes in section .bss
   278 bytes in section .rodata
 1 012 bytes in section .text
 
 1 012 bytes of CODE  memory
   278 bytes of CONST memory
   160 bytes of DATA  memory

Errors: none
Warnings: none
