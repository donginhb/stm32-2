###############################################################################
#                                                                             #
#                                                       07/May/2014  16:39:01 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\enet\nbuf.c                           #
#    Command line =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\enet\nbuf.c -D IAR -D TWR_K60N512     #
#                    -lCN C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\RAM_128KB\List\ -lB    #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -o          #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\ --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.0           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\projects\hello #
#                    _world\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kin #
#                    etisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\com #
#                    mon\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\headers #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\a #
#                    dc16\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kinet #
#                    isK60_Demo_OLED\build\iar\hello_world\..\..\..\src\drive #
#                    rs\enet\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Ki #
#                    netisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\dr #
#                    ivers\pmc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\ #
#                    KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\ #
#                    drivers\rtc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³ #
#                    Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\sr #
#                    c\drivers\lptmr\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐ #
#                    òÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\. #
#                    .\src\drivers\uart\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\ #
#                    ³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\. #
#                    .\..\src\drivers\mcg\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁ #
#                    Ï\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\.. #
#                    \..\..\src\drivers\wdog\ -I                              #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\platforms\ -I  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\drivers\ftm\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\SPI #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\O #
#                    LED\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\ -On             #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\nbuf.lst     #
#    Object file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\nbuf.o        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\src\drivers\enet\nbuf.c
      1          /* Buffer Descriptors -- must be aligned on a 4-byte boundary but a 
      2           * 16-byte boundary is recommended. To avoid playing games with the 
      3           * various compilers and their different extension to ANSI C, these 
      4           * buffers are aligned by allocating an extra line of data and 
      5           * adjusting the pointers in nbuf_init().
      6           */
      7          
      8          #include "common.h"
      9          #include "nbuf.h"
     10          
     11          /*FSL: to avoid overlapping, buffers must be declared at the beggining of file*/
     12          /*then pointers can access them correctly*/
     13          
     14          /* Data Buffers -- must be aligned on a 16-byte boundary. To avoid 
     15           * playing games with the various compilers and their different 
     16           * extension to ANSI C, these buffers are aligned by allocating an 
     17           * extra line of data and adjusting the pointers in nbuf_init().
     18           */

   \                                 In section .bss, align 4
     19          static uint8_t unaligned_txbd[(sizeof(NBUF) * NUM_TXBDS) + 16];
   \                     unaligned_txbd:
   \   00000000                      DS8 656

   \                                 In section .bss, align 4
     20          static uint8_t unaligned_rxbd[(sizeof(NBUF) * NUM_RXBDS) + 16];
   \                     unaligned_rxbd:
   \   00000000                      DS8 656
     21          #ifdef USE_DEDICATED_TX_BUFFERS
     22          static uint8_t unaligned_txbuffer[(TX_BUFFER_SIZE * NUM_TXBDS) + 16];
     23          #endif

   \                                 In section .bss, align 4
     24          static uint8_t unaligned_rxbuffer[(RX_BUFFER_SIZE * NUM_RXBDS) + 16];
   \                     unaligned_rxbuffer:
   \   00000000                      DS8 5136
     25          
     26          /* Pointers to alligned buffer descriptors */

   \                                 In section .bss, align 4
     27          static NBUF *TxNBUF;
   \                     TxNBUF:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     28          static NBUF *RxNBUF;
   \                     RxNBUF:
   \   00000000                      DS8 4
     29          
     30          /* Pointers to alligned Tx/Rx data buffers */
     31          #ifdef USE_DEDICATED_TX_BUFFERS
     32          static uint8_t *TxBuffer;
     33          #endif

   \                                 In section .bss, align 4
     34          static uint8_t *RxBuffer;
   \                     RxBuffer:
   \   00000000                      DS8 4
     35          
     36          /* Next BD indicators for static BD queue */ 

   \                                 In section .bss, align 4
     37          static int next_txbd;
   \                     next_txbd:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     38          static int next_rxbd;
   \                     next_rxbd:
   \   00000000                      DS8 4
     39          
     40          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     41          void 
     42          nbuf_alloc(int ch)
     43          {
   \                     nbuf_alloc:
   \   00000000   0xB410             PUSH     {R4}
     44          	int i;
     45          	//uint32_t *temp;
     46          
     47                  next_txbd = 0;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable6
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x6013             STR      R3,[R2, #+0]
     48                  next_rxbd = 0;
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable6_1
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x6013             STR      R3,[R2, #+0]
     49          
     50          	TxNBUF = (NBUF *)(((uint32_t)(unaligned_txbd)) & 0xFFFFFFF0);
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable6_2
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable6_3
   \   0000001A   0x091B             LSRS     R3,R3,#+4
   \   0000001C   0x011B             LSLS     R3,R3,#+4
   \   0000001E   0x6013             STR      R3,[R2, #+0]
     51          	RxNBUF = (NBUF *)(((uint32_t)(unaligned_rxbd)) & 0xFFFFFFF0);
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable6_4
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable6_5
   \   00000028   0x091B             LSRS     R3,R3,#+4
   \   0000002A   0x011B             LSLS     R3,R3,#+4
   \   0000002C   0x6013             STR      R3,[R2, #+0]
     52          
     53          	RxBuffer = (uint8_t *)(((uint32_t)(unaligned_rxbuffer)) & 0xFFFFFFF0);
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable6_6
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable6_7
   \   00000036   0x091B             LSRS     R3,R3,#+4
   \   00000038   0x011B             LSLS     R3,R3,#+4
   \   0000003A   0x6013             STR      R3,[R2, #+0]
     54          #ifdef USE_DEDICATED_TX_BUFFERS
     55          	TxBuffer = (uint8_t *)(((uint32_t)(unaligned_txbuffer)) & 0xFFFFFFF0);
     56          #endif
     57          	// Initialize transmit descriptor ring
     58          	for (i = 0; i < NUM_TXBDS; i++)
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x0011             MOVS     R1,R2
   \                     ??nbuf_alloc_0:
   \   00000040   0x2914             CMP      R1,#+20
   \   00000042   0xDA12             BGE.N    ??nbuf_alloc_1
     59          	{
     60          		TxNBUF[i].status = 0x0000;
   \   00000044   0x014A             LSLS     R2,R1,#+5
   \   00000046   0x....             LDR.N    R3,??DataTable6_2
   \   00000048   0x681B             LDR      R3,[R3, #+0]
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0x52D4             STRH     R4,[R2, R3]
     61          		TxNBUF[i].length = 0;		
   \   0000004E   0x....             LDR.N    R2,??DataTable6_2
   \   00000050   0x6812             LDR      R2,[R2, #+0]
   \   00000052   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x8053             STRH     R3,[R2, #+2]
     62          	        #ifdef USE_DEDICATED_TX_BUFFERS
     63          	           #ifdef NBUF_LITTLE_ENDIAN 
     64          	           TxNBUF[i].data = (uint8_t *)__REV((uint32_t)&TxBuffer[i * TX_BUFFER_SIZE]);
     65                             #else
     66                             TxNBUF[i].data = (uint8_t *)(uint32_t)&TxBuffer[i * TX_BUFFER_SIZE];
     67                             #endif
     68                          #endif
     69                  
     70                          #ifdef ENHANCED_BD
     71                             TxNBUF[i].ebd_status = TX_BD_IINS | TX_BD_PINS;
   \   0000005A   0x....             LDR.N    R2,??DataTable6_2
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000062   0x2318             MOVS     R3,#+24
   \   00000064   0x6093             STR      R3,[R2, #+8]
     72                          #endif
     73          	}
   \   00000066   0x1C49             ADDS     R1,R1,#+1
   \   00000068   0xE7EA             B.N      ??nbuf_alloc_0
     74          
     75          	// Initialize receive descriptor ring
     76          	for (i = 0; i < NUM_RXBDS; i++)
   \                     ??nbuf_alloc_1:
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x0011             MOVS     R1,R2
   \                     ??nbuf_alloc_2:
   \   0000006E   0x2914             CMP      R1,#+20
   \   00000070   0xDA25             BGE.N    ??nbuf_alloc_3
     77          	{
     78          		RxNBUF[i].status = RX_BD_E;
   \   00000072   0x014A             LSLS     R2,R1,#+5
   \   00000074   0x....             LDR.N    R3,??DataTable6_4
   \   00000076   0x681B             LDR      R3,[R3, #+0]
   \   00000078   0x2480             MOVS     R4,#+128
   \   0000007A   0x52D4             STRH     R4,[R2, R3]
     79          		RxNBUF[i].length = 0;
   \   0000007C   0x....             LDR.N    R2,??DataTable6_4
   \   0000007E   0x6812             LDR      R2,[R2, #+0]
   \   00000080   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x8053             STRH     R3,[R2, #+2]
     80                          #ifdef NBUF_LITTLE_ENDIAN
     81          		RxNBUF[i].data = (uint8_t *)__REV((uint32_t)&RxBuffer[i * RX_BUFFER_SIZE]);
   \   00000088   0xF44F 0x7280      MOV      R2,#+256
   \   0000008C   0x....             LDR.N    R3,??DataTable6_6
   \   0000008E   0x681B             LDR      R3,[R3, #+0]
   \   00000090   0xFB02 0x3201      MLA      R2,R2,R1,R3
   \   00000094   0xBA12             REV      R2,R2
   \   00000096   0x....             LDR.N    R3,??DataTable6_4
   \   00000098   0x681B             LDR      R3,[R3, #+0]
   \   0000009A   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   0000009E   0x605A             STR      R2,[R3, #+4]
     82                          #else
     83                          RxNBUF[i].data = (uint8_t *)(uint32_t)&RxBuffer[i * RX_BUFFER_SIZE];
     84                          #endif
     85          
     86                          #ifdef ENHANCED_BD
     87          	        RxNBUF[i].bdu = 0x00000000;
   \   000000A0   0x....             LDR.N    R2,??DataTable6_4
   \   000000A2   0x6812             LDR      R2,[R2, #+0]
   \   000000A4   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   000000A8   0x2300             MOVS     R3,#+0
   \   000000AA   0x6113             STR      R3,[R2, #+16]
     88          	        RxNBUF[i].ebd_status = RX_BD_INT;
   \   000000AC   0x....             LDR.N    R2,??DataTable6_4
   \   000000AE   0x6812             LDR      R2,[R2, #+0]
   \   000000B0   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   000000B4   0xF44F 0x4300      MOV      R3,#+32768
   \   000000B8   0x6093             STR      R3,[R2, #+8]
     89                          #endif               
     90          	}
   \   000000BA   0x1C49             ADDS     R1,R1,#+1
   \   000000BC   0xE7D7             B.N      ??nbuf_alloc_2
     91                  
     92          	// Set the Wrap bit on the last one in the ring
     93          	RxNBUF[NUM_RXBDS - 1].status |= RX_BD_W;
   \                     ??nbuf_alloc_3:
   \   000000BE   0x....             LDR.N    R2,??DataTable6_4
   \   000000C0   0x6812             LDR      R2,[R2, #+0]
   \   000000C2   0xF8B2 0x2260      LDRH     R2,[R2, #+608]
   \   000000C6   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   000000CA   0x....             LDR.N    R3,??DataTable6_4
   \   000000CC   0x681B             LDR      R3,[R3, #+0]
   \   000000CE   0xF8A3 0x2260      STRH     R2,[R3, #+608]
     94          	TxNBUF[NUM_TXBDS - 1].status |= TX_BD_W;
   \   000000D2   0x....             LDR.N    R2,??DataTable6_2
   \   000000D4   0x6812             LDR      R2,[R2, #+0]
   \   000000D6   0xF8B2 0x2260      LDRH     R2,[R2, #+608]
   \   000000DA   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   000000DE   0x....             LDR.N    R3,??DataTable6_2
   \   000000E0   0x681B             LDR      R3,[R3, #+0]
   \   000000E2   0xF8A3 0x2260      STRH     R2,[R3, #+608]
     95          }
   \   000000E6   0xBC10             POP      {R4}
   \   000000E8   0x4770             BX       LR               ;; return
     96          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     97          void 
     98          nbuf_flush(int ch)
     99          {
   \                     nbuf_flush:
   \   00000000   0xB410             PUSH     {R4}
    100          	int i;
    101          
    102          	next_txbd = 0;
   \   00000002   0x....             LDR.N    R2,??DataTable6
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x6013             STR      R3,[R2, #+0]
    103          	next_rxbd = 0;
   \   00000008   0x....             LDR.N    R2,??DataTable6_1
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x6013             STR      R3,[R2, #+0]
    104          	
    105          	// Reset enet hardware bd pointers also ??
    106          
    107          	// Reset receive descriptor ring
    108          	for (i = 0; i < NUM_RXBDS; i++)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0011             MOVS     R1,R2
   \                     ??nbuf_flush_0:
   \   00000012   0x2914             CMP      R1,#+20
   \   00000014   0xDA18             BGE.N    ??nbuf_flush_1
    109          	{
    110          		RxNBUF[i].status = RX_BD_E;
   \   00000016   0x014A             LSLS     R2,R1,#+5
   \   00000018   0x....             LDR.N    R3,??DataTable6_4
   \   0000001A   0x681B             LDR      R3,[R3, #+0]
   \   0000001C   0x2480             MOVS     R4,#+128
   \   0000001E   0x52D4             STRH     R4,[R2, R3]
    111          		RxNBUF[i].length = 0;
   \   00000020   0x....             LDR.N    R2,??DataTable6_4
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x8053             STRH     R3,[R2, #+2]
    112          	        #ifdef NBUF_LITTLE_ENDIAN	
    113          		RxNBUF[i].data = (uint8_t *)__REV((uint32_t)&RxBuffer[i * RX_BUFFER_SIZE]);
   \   0000002C   0xF44F 0x7280      MOV      R2,#+256
   \   00000030   0x....             LDR.N    R3,??DataTable6_6
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0xFB02 0x3201      MLA      R2,R2,R1,R3
   \   00000038   0xBA12             REV      R2,R2
   \   0000003A   0x....             LDR.N    R3,??DataTable6_4
   \   0000003C   0x681B             LDR      R3,[R3, #+0]
   \   0000003E   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000042   0x605A             STR      R2,[R3, #+4]
    114          	        #else
    115          	        RxNBUF[i].data = (uint8_t *)(uint32_t)&RxBuffer[i * RX_BUFFER_SIZE];
    116          	        #endif	
    117          	}
   \   00000044   0x1C49             ADDS     R1,R1,#+1
   \   00000046   0xE7E4             B.N      ??nbuf_flush_0
    118          
    119          	// Reset transmit descriptor ring
    120          	for (i = 0; i < NUM_TXBDS; i++)
   \                     ??nbuf_flush_1:
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x0011             MOVS     R1,R2
   \                     ??nbuf_flush_2:
   \   0000004C   0x2914             CMP      R1,#+20
   \   0000004E   0xDA0C             BGE.N    ??nbuf_flush_3
    121          	{
    122          		TxNBUF[i].status = 0x0000;
   \   00000050   0x014A             LSLS     R2,R1,#+5
   \   00000052   0x....             LDR.N    R3,??DataTable6_2
   \   00000054   0x681B             LDR      R3,[R3, #+0]
   \   00000056   0x2400             MOVS     R4,#+0
   \   00000058   0x52D4             STRH     R4,[R2, R3]
    123          		TxNBUF[i].length = 0;
   \   0000005A   0x....             LDR.N    R2,??DataTable6_2
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000062   0x2300             MOVS     R3,#+0
   \   00000064   0x8053             STRH     R3,[R2, #+2]
    124          	}
   \   00000066   0x1C49             ADDS     R1,R1,#+1
   \   00000068   0xE7F0             B.N      ??nbuf_flush_2
    125          
    126          	// Set the Wrap bit on the last one in the ring
    127          	RxNBUF[NUM_RXBDS - 1].status |= RX_BD_W;
   \                     ??nbuf_flush_3:
   \   0000006A   0x....             LDR.N    R2,??DataTable6_4
   \   0000006C   0x6812             LDR      R2,[R2, #+0]
   \   0000006E   0xF8B2 0x2260      LDRH     R2,[R2, #+608]
   \   00000072   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   00000076   0x....             LDR.N    R3,??DataTable6_4
   \   00000078   0x681B             LDR      R3,[R3, #+0]
   \   0000007A   0xF8A3 0x2260      STRH     R2,[R3, #+608]
    128          	TxNBUF[NUM_TXBDS - 1].status |= TX_BD_W;
   \   0000007E   0x....             LDR.N    R2,??DataTable6_2
   \   00000080   0x6812             LDR      R2,[R2, #+0]
   \   00000082   0xF8B2 0x2260      LDRH     R2,[R2, #+608]
   \   00000086   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   0000008A   0x....             LDR.N    R3,??DataTable6_2
   \   0000008C   0x681B             LDR      R3,[R3, #+0]
   \   0000008E   0xF8A3 0x2260      STRH     R2,[R3, #+608]
    129          }
   \   00000092   0xBC10             POP      {R4}
   \   00000094   0x4770             BX       LR               ;; return
    130          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          void 
    132          nbuf_init(int ch)
    133          {
    134          	// Set Receive Buffer Size
    135          	ENET_MRBR/*(ch)*/ = (uint16_t)RX_BUFFER_SIZE;  
   \                     nbuf_init:
   \   00000000   0x....             LDR.N    R1,??DataTable6_8  ;; 0x400c0188
   \   00000002   0xF44F 0x7280      MOV      R2,#+256
   \   00000006   0x600A             STR      R2,[R1, #+0]
    136            
    137           	// Point to the start of the Tx buffer descriptor queue
    138          	ENET_TDSR/*(ch)*/ = (uint32_t)TxNBUF;
   \   00000008   0x....             LDR.N    R1,??DataTable6_9  ;; 0x400c0184
   \   0000000A   0x....             LDR.N    R2,??DataTable6_2
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    139          	// Point to the start of the circular Rx buffer descriptor queue
    140          	ENET_RDSR/*(ch)*/ = (uint32_t)RxNBUF;
   \   00000010   0x....             LDR.N    R1,??DataTable6_10  ;; 0x400c0180
   \   00000012   0x....             LDR.N    R2,??DataTable6_4
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x600A             STR      R2,[R1, #+0]
    141          }
   \   00000018   0x4770             BX       LR               ;; return
    142          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    143          void 
    144          nbuf_start_rx(int ch)
    145          {
    146                  // Indicate Empty buffers have been produced
    147          	ENET_RDAR/*(ch)*/ = ENET_RDAR_RDAR_MASK;
   \                     nbuf_start_rx:
   \   00000000   0x....             LDR.N    R1,??DataTable6_11  ;; 0x400c0010
   \   00000002   0xF05F 0x7280      MOVS     R2,#+16777216
   \   00000006   0x600A             STR      R2,[R1, #+0]
    148          
    149                  while( !ENET_RDAR )
   \                     ??nbuf_start_rx_0:
   \   00000008   0x....             LDR.N    R1,??DataTable6_11  ;; 0x400c0010
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD0FB             BEQ.N    ??nbuf_start_rx_0
    150                  {
    151                    //If RDAR cannot be test,  
    152                    //printf("Error with internal ENET DMA engine\n");
    153                  }
    154          }
   \   00000010   0x4770             BX       LR               ;; return
    155          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    156          void 
    157          enet_get_received_packet(int ch, NBUF * rx_packet)
    158          {
   \                     enet_get_received_packet:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    159          	int last_buffer;
    160          	uint16_t status;
    161          	int index_rxbd;
    162          
    163          	last_buffer = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    164          	rx_packet->length = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x8068             STRH     R0,[R5, #+2]
    165          	
    166          	index_rxbd = next_rxbd;
   \   00000010   0x....             LDR.N    R0,??DataTable6_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x4680             MOV      R8,R0
    167              
    168          	if(RxNBUF[index_rxbd].status & RX_BD_E)
   \   00000016   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \   0000001A   0x....             LDR.N    R1,??DataTable6_4
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x5C40             LDRB     R0,[R0, R1]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD503             BPL.N    ??enet_get_received_packet_0
    169          	{
    170          		printf("Under processing. SHouldnt be here\n");
   \   00000024   0x....             LDR.N    R0,??DataTable6_12
   \   00000026   0x.... 0x....      BL       printf
    171          		return;	
   \   0000002A   0xE04F             B.N      ??enet_get_received_packet_1
    172          	}
    173                  #ifdef NBUF_LITTLE_ENDIAN
    174                  rx_packet->data = (uint8_t *)__REV((uint32_t)RxNBUF[index_rxbd].data);
   \                     ??enet_get_received_packet_0:
   \   0000002C   0x....             LDR.N    R0,??DataTable6_4
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xEB10 0x1048      ADDS     R0,R0,R8, LSL #+5
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0xBA00             REV      R0,R0
   \   00000038   0x6068             STR      R0,[R5, #+4]
    175                  #else
    176                  rx_packet->data = (uint8_t *)(uint32_t)RxNBUF[index_rxbd].data;
    177                  #endif
    178          	// Update next_rxbd pointer and mark buffers as empty again
    179          	while(!last_buffer)
   \                     ??enet_get_received_packet_2:
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD142             BNE.N    ??enet_get_received_packet_3
    180          	{
    181          		status = RxNBUF[index_rxbd].status;
   \   0000003E   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \   00000042   0x....             LDR.N    R1,??DataTable6_4
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x5A40             LDRH     R0,[R0, R1]
   \   00000048   0x0007             MOVS     R7,R0
    182          	        #ifdef NBUF_LITTLE_ENDIAN	
    183          		rx_packet->length = __REVSH(RxNBUF[index_rxbd].length);
   \   0000004A   0x....             LDR.N    R0,??DataTable6_4
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xEB10 0x1048      ADDS     R0,R0,R8, LSL #+5
   \   00000052   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000056   0xBAC0             REVSH    R0,R0
   \   00000058   0x8068             STRH     R0,[R5, #+2]
    184                          #else
    185                          rx_packet->length = RxNBUF[index_rxbd].length;
    186                          #endif
    187                          #ifdef ENHANCED_BD
    188          		rx_packet->ebd_status = RxNBUF[index_rxbd].ebd_status;
   \   0000005A   0x....             LDR.N    R0,??DataTable6_4
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xEB10 0x1048      ADDS     R0,R0,R8, LSL #+5
   \   00000062   0x6880             LDR      R0,[R0, #+8]
   \   00000064   0x60A8             STR      R0,[R5, #+8]
    189          	            #ifdef NBUF_LITTLE_ENDIAN	
    190          		    rx_packet->timestamp = __REV(RxNBUF[index_rxbd].timestamp);
   \   00000066   0x....             LDR.N    R0,??DataTable6_4
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xEB10 0x1048      ADDS     R0,R0,R8, LSL #+5
   \   0000006E   0x6940             LDR      R0,[R0, #+20]
   \   00000070   0xBA00             REV      R0,R0
   \   00000072   0x6168             STR      R0,[R5, #+20]
    191          		    rx_packet->length_proto_type = __REVSH(RxNBUF[index_rxbd].length_proto_type);
   \   00000074   0x....             LDR.N    R0,??DataTable6_4
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xEB10 0x1048      ADDS     R0,R0,R8, LSL #+5
   \   0000007C   0xF9B0 0x000C      LDRSH    R0,[R0, #+12]
   \   00000080   0xBAC0             REVSH    R0,R0
   \   00000082   0x81A8             STRH     R0,[R5, #+12]
    192          		    rx_packet->payload_checksum = __REVSH(RxNBUF[index_rxbd].payload_checksum);
   \   00000084   0x....             LDR.N    R0,??DataTable6_4
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xEB10 0x1048      ADDS     R0,R0,R8, LSL #+5
   \   0000008C   0xF9B0 0x000E      LDRSH    R0,[R0, #+14]
   \   00000090   0xBAC0             REVSH    R0,R0
   \   00000092   0x81E8             STRH     R0,[R5, #+14]
    193                              #else
    194          		    rx_packet->timestamp = RxNBUF[index_rxbd].timestamp;
    195          		    rx_packet->length_proto_type = RxNBUF[index_rxbd].length_proto_type;
    196          		    rx_packet->payload_checksum = RxNBUF[index_rxbd].payload_checksum;
    197                              #endif
    198                          #endif
    199          
    200          		last_buffer = (status & RX_BD_L);
   \   00000094   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000096   0xF017 0x0008      ANDS     R0,R7,#0x8
   \   0000009A   0x0006             MOVS     R6,R0
    201          		if(status & RX_BD_W)
   \   0000009C   0x06B8             LSLS     R0,R7,#+26
   \   0000009E   0xD508             BPL.N    ??enet_get_received_packet_4
    202          		{
    203          			RxNBUF[index_rxbd].status = (RX_BD_W | RX_BD_E);
   \   000000A0   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \   000000A4   0x....             LDR.N    R1,??DataTable6_4
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x22A0             MOVS     R2,#+160
   \   000000AA   0x5242             STRH     R2,[R0, R1]
    204          			index_rxbd = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x4680             MOV      R8,R0
   \   000000B0   0xE7C3             B.N      ??enet_get_received_packet_2
    205          		}
    206          		else
    207          		{
    208          			RxNBUF[index_rxbd].status = RX_BD_E;
   \                     ??enet_get_received_packet_4:
   \   000000B2   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \   000000B6   0x....             LDR.N    R1,??DataTable6_4
   \   000000B8   0x6809             LDR      R1,[R1, #+0]
   \   000000BA   0x2280             MOVS     R2,#+128
   \   000000BC   0x5242             STRH     R2,[R0, R1]
    209          			index_rxbd++;
   \   000000BE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000C2   0xE7BA             B.N      ??enet_get_received_packet_2
    210          		}
    211          	}
    212          	
    213          	// Update the global rxbd index
    214          	next_rxbd = index_rxbd;
   \                     ??enet_get_received_packet_3:
   \   000000C4   0x....             LDR.N    R0,??DataTable6_1
   \   000000C6   0xF8C0 0x8000      STR      R8,[R0, #+0]
    215          	
    216          	// Put the last BD status in rx_packet->status as MISS flags and more 
    217          	// are updated in last BD
    218          	rx_packet->status = status;
   \   000000CA   0x802F             STRH     R7,[R5, #+0]
    219          }
   \                     ??enet_get_received_packet_1:
   \   000000CC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    220          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    221          void enet_fill_txbds(int ch, NBUF * tx_packet)
    222          {
   \                     enet_fill_txbds:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    223          	int num_txbds, i;
    224          	int index_txbd;
    225          
    226          	num_txbds = (tx_packet->length/TX_BUFFER_SIZE);
   \   00000002   0x884D             LDRH     R5,[R1, #+2]
   \   00000004   0xF44F 0x7680      MOV      R6,#+256
   \   00000008   0xFB95 0xF5F6      SDIV     R5,R5,R6
   \   0000000C   0x002A             MOVS     R2,R5
    227          	
    228          	index_txbd = next_txbd;
   \   0000000E   0x....             LDR.N    R5,??DataTable6
   \   00000010   0x682D             LDR      R5,[R5, #+0]
   \   00000012   0x002C             MOVS     R4,R5
    229          	
    230          	if((num_txbds * TX_BUFFER_SIZE) < tx_packet->length)
   \   00000014   0xF44F 0x7580      MOV      R5,#+256
   \   00000018   0xFB05 0xF502      MUL      R5,R5,R2
   \   0000001C   0x884E             LDRH     R6,[R1, #+2]
   \   0000001E   0x42B5             CMP      R5,R6
   \   00000020   0xDA00             BGE.N    ??enet_fill_txbds_0
    231          	{
    232          		num_txbds = num_txbds + 1;
   \   00000022   0x1C52             ADDS     R2,R2,#+1
    233          	}
    234              
    235          	// Fill Descriptors
    236          	for (i = 0; i < num_txbds; i++)
   \                     ??enet_fill_txbds_0:
   \   00000024   0x2500             MOVS     R5,#+0
   \   00000026   0x002B             MOVS     R3,R5
   \                     ??enet_fill_txbds_1:
   \   00000028   0x4293             CMP      R3,R2
   \   0000002A   0xDA4B             BGE.N    ??enet_fill_txbds_2
    237          	{
    238          		
    239          		TxNBUF[index_txbd].status = TX_BD_TC | TX_BD_R;
   \   0000002C   0x0165             LSLS     R5,R4,#+5
   \   0000002E   0x....             LDR.N    R6,??DataTable6_2
   \   00000030   0x6836             LDR      R6,[R6, #+0]
   \   00000032   0x2784             MOVS     R7,#+132
   \   00000034   0x53AF             STRH     R7,[R5, R6]
    240                          #ifdef ENHANCED_BD
    241          		TxNBUF[index_txbd].bdu = 0x00000000;
   \   00000036   0x....             LDR.N    R5,??DataTable6_2
   \   00000038   0x682D             LDR      R5,[R5, #+0]
   \   0000003A   0xEB15 0x1544      ADDS     R5,R5,R4, LSL #+5
   \   0000003E   0x2600             MOVS     R6,#+0
   \   00000040   0x612E             STR      R6,[R5, #+16]
    242          		TxNBUF[index_txbd].ebd_status = TX_BD_INT | TX_BD_TS;// | TX_BD_IINS | TX_BD_PINS;
   \   00000042   0x....             LDR.N    R5,??DataTable6_2
   \   00000044   0x682D             LDR      R5,[R5, #+0]
   \   00000046   0xEB15 0x1544      ADDS     R5,R5,R4, LSL #+5
   \   0000004A   0x2660             MOVS     R6,#+96
   \   0000004C   0x60AE             STR      R6,[R5, #+8]
    243                          #endif
    244          
    245          		if(i == num_txbds - 1)
   \   0000004E   0x1E55             SUBS     R5,R2,#+1
   \   00000050   0x42AB             CMP      R3,R5
   \   00000052   0xD115             BNE.N    ??enet_fill_txbds_3
    246          		{
    247          		    #ifdef NBUF_LITTLE_ENDIAN 
    248          		    TxNBUF[index_txbd].length = __REVSH((tx_packet->length - (i*TX_BUFFER_SIZE)));
   \   00000054   0x884D             LDRH     R5,[R1, #+2]
   \   00000056   0xF44F 0x7680      MOV      R6,#+256
   \   0000005A   0xFB06 0x5513      MLS      R5,R6,R3,R5
   \   0000005E   0xBAED             REVSH    R5,R5
   \   00000060   0x....             LDR.N    R6,??DataTable6_2
   \   00000062   0x6836             LDR      R6,[R6, #+0]
   \   00000064   0xEB16 0x1644      ADDS     R6,R6,R4, LSL #+5
   \   00000068   0x8075             STRH     R5,[R6, #+2]
    249                              #else
    250                              TxNBUF[index_txbd].length = (tx_packet->length - (i*TX_BUFFER_SIZE));
    251                              #endif
    252          		    // Set the Last bit on the last BD
    253          		    TxNBUF[index_txbd].status |= TX_BD_L;		 
   \   0000006A   0x0165             LSLS     R5,R4,#+5
   \   0000006C   0x....             LDR.N    R6,??DataTable6_2
   \   0000006E   0x6836             LDR      R6,[R6, #+0]
   \   00000070   0x5BAD             LDRH     R5,[R5, R6]
   \   00000072   0xF055 0x0508      ORRS     R5,R5,#0x8
   \   00000076   0x0166             LSLS     R6,R4,#+5
   \   00000078   0x....             LDR.N    R7,??DataTable6_2
   \   0000007A   0x683F             LDR      R7,[R7, #+0]
   \   0000007C   0x53F5             STRH     R5,[R6, R7]
   \   0000007E   0xE005             B.N      ??enet_fill_txbds_4
    254          		}
    255          		else
    256          		{
    257          		    #ifdef NBUF_LITTLE_ENDIAN 
    258          		    TxNBUF[index_txbd].length = __REVSH(TX_BUFFER_SIZE);
   \                     ??enet_fill_txbds_3:
   \   00000080   0x....             LDR.N    R5,??DataTable6_2
   \   00000082   0x682D             LDR      R5,[R5, #+0]
   \   00000084   0xEB15 0x1544      ADDS     R5,R5,R4, LSL #+5
   \   00000088   0x2601             MOVS     R6,#+1
   \   0000008A   0x806E             STRH     R6,[R5, #+2]
    259          		    #else
    260          		    TxNBUF[index_txbd].length = TX_BUFFER_SIZE;
    261          		    #endif
    262          		}
    263          		
    264          		#ifdef USE_DEDICATED_TX_BUFFERS
    265          		  #ifdef NBUF_LITTLE_ENDIAN
    266          		  //Copy data to Tx buffers
    267                             memcpy((void *)__REV((uint32_t)TxNBUF[index_txbd].data), (void *)(((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE)),
    268                                    __REVSH(TxNBUF[index_txbd].length));  
    269                            #else
    270          		  // Copy data to Tx buffers
    271                            memcpy((void *)(uint32_t)TxNBUF[index_txbd].data, (void *)(((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE)),
    272                                    TxNBUF[index_txbd].length);         
    273                            #endif
    274                          #else
    275                            // Just update data pointer as data is aready there
    276                            #ifdef NBUF_LITTLE_ENDIAN 
    277                            TxNBUF[index_txbd].data = (uint8_t *)__REV((((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE)));
   \                     ??enet_fill_txbds_4:
   \   0000008C   0x684D             LDR      R5,[R1, #+4]
   \   0000008E   0xF44F 0x7680      MOV      R6,#+256
   \   00000092   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   00000096   0xBA2D             REV      R5,R5
   \   00000098   0x....             LDR.N    R6,??DataTable6_2
   \   0000009A   0x6836             LDR      R6,[R6, #+0]
   \   0000009C   0xEB16 0x1644      ADDS     R6,R6,R4, LSL #+5
   \   000000A0   0x6075             STR      R5,[R6, #+4]
    278                            #else
    279                            TxNBUF[index_txbd].data = (uint8_t *)(((uint32_t)(tx_packet->data)) + (i*TX_BUFFER_SIZE));
    280                            #endif 
    281                          #endif
    282          
    283          		// Wrap if this was last TxBD
    284          		if(++index_txbd == NUM_TXBDS)
   \   000000A2   0x1C64             ADDS     R4,R4,#+1
   \   000000A4   0x2C14             CMP      R4,#+20
   \   000000A6   0xD10B             BNE.N    ??enet_fill_txbds_5
    285          		{
    286          			TxNBUF[NUM_TXBDS - 1].status |= TX_BD_W;
   \   000000A8   0x....             LDR.N    R5,??DataTable6_2
   \   000000AA   0x682D             LDR      R5,[R5, #+0]
   \   000000AC   0xF8B5 0x5260      LDRH     R5,[R5, #+608]
   \   000000B0   0xF055 0x0520      ORRS     R5,R5,#0x20
   \   000000B4   0x....             LDR.N    R6,??DataTable6_2
   \   000000B6   0x6836             LDR      R6,[R6, #+0]
   \   000000B8   0xF8A6 0x5260      STRH     R5,[R6, #+608]
    287          			index_txbd = 0;
   \   000000BC   0x2500             MOVS     R5,#+0
   \   000000BE   0x002C             MOVS     R4,R5
    288          		}
    289          	}
   \                     ??enet_fill_txbds_5:
   \   000000C0   0x1C5B             ADDS     R3,R3,#+1
   \   000000C2   0xE7B1             B.N      ??enet_fill_txbds_1
    290          	
    291          	// Update the global txbd index
    292          	next_txbd = index_txbd;
   \                     ??enet_fill_txbds_2:
   \   000000C4   0x....             LDR.N    R5,??DataTable6
   \   000000C6   0x602C             STR      R4,[R5, #+0]
    293          }
   \   000000C8   0xBCF0             POP      {R4-R7}
   \   000000CA   0x4770             BX       LR               ;; return
    294          

   \                                 In section .text, align 2, keep-with-next
    295          void 
    296          enet_transmit_packet(int ch, NBUF * tx_packet)
    297          {
   \                     enet_transmit_packet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    298          	enet_fill_txbds(ch,tx_packet);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       enet_fill_txbds
    299          	
    300          	// Indicate that Descriptors are ready to transmit 
    301          	ENET_TDAR/*(ch)*/ = ENET_TDAR_TDAR_MASK;
   \   0000000E   0x....             LDR.N    R0,??DataTable6_13  ;; 0x400c0014
   \   00000010   0xF05F 0x7180      MOVS     R1,#+16777216
   \   00000014   0x6001             STR      R1,[R0, #+0]
    302          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     next_txbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     next_rxbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     TxNBUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     unaligned_txbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     RxNBUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     unaligned_rxbd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     unaligned_rxbuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x400C0188         DC32     0x400c0188

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x400C0184         DC32     0x400c0184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x400C0180         DC32     0x400c0180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x400C0010         DC32     0x400c0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     `?<Constant "Under processing. SHo...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x400C0014         DC32     0x400c0014

   \                                 In section .rodata, align 4
   \                     `?<Constant "Under processing. SHo...">`:
   \   00000000   0x55 0x6E          DC8 "Under processing. SHouldnt be here\012"
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x70 0x72    
   \              0x6F 0x63    
   \              0x65 0x73    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x2E 0x20    
   \              0x53 0x48    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x6E 0x74    
   \              0x20 0x62    
   \              0x65 0x20    
   \              0x68 0x65    
   \              0x72 0x65    
   \              0x0A 0x00    
    303          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  enet_fill_txbds
       24  enet_get_received_packet
             24 -> printf
       16  enet_transmit_packet
             16 -> enet_fill_txbds
        4  nbuf_alloc
        4  nbuf_flush
        0  nbuf_init
        0  nbuf_start_rx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      36  ?<Constant "Under processing. SHo...">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  RxBuffer
       4  RxNBUF
       4  TxNBUF
     204  enet_fill_txbds
     208  enet_get_received_packet
      24  enet_transmit_packet
     234  nbuf_alloc
     150  nbuf_flush
      26  nbuf_init
      18  nbuf_start_rx
       4  next_rxbd
       4  next_txbd
     656  unaligned_rxbd
    5136  unaligned_rxbuffer
     656  unaligned_txbd

 
 6 468 bytes in section .bss
    36 bytes in section .rodata
   920 bytes in section .text
 
   920 bytes of CODE  memory
    36 bytes of CONST memory
 6 468 bytes of DATA  memory

Errors: none
Warnings: none
