###############################################################################
#                                                                             #
#                                                       07/May/2014  16:39:00 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\mcg\mcg.c                             #
#    Command line =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\mcg\mcg.c -D IAR -D TWR_K60N512 -lCN  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -lB         #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -o          #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\ --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.0           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\projects\hello #
#                    _world\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kin #
#                    etisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\com #
#                    mon\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\headers #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\a #
#                    dc16\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kinet #
#                    isK60_Demo_OLED\build\iar\hello_world\..\..\..\src\drive #
#                    rs\enet\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Ki #
#                    netisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\dr #
#                    ivers\pmc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\ #
#                    KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\ #
#                    drivers\rtc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³ #
#                    Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\sr #
#                    c\drivers\lptmr\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐ #
#                    òÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\. #
#                    .\src\drivers\uart\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\ #
#                    ³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\. #
#                    .\..\src\drivers\mcg\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁ #
#                    Ï\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\.. #
#                    \..\..\src\drivers\wdog\ -I                              #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\platforms\ -I  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\drivers\ftm\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\SPI #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\O #
#                    LED\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\ -On             #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\mcg.lst      #
#    Object file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\mcg.o         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\src\drivers\mcg\mcg.c
      1          /*
      2           * File:    mcg.c
      3           * Purpose: Driver for enabling the PLL in 1 of 4 options
      4           *
      5           * Notes:
      6           * Assumes the MCG mode is in the default FEI mode out of reset
      7           * One of 4 clocking oprions can be selected.
      8           * One of 16 crystal values can be used
      9           */
     10          
     11          #include "common.h"
     12          #include "mcg.h"
     13          #include "lptmr.h"
     14          
     15          // global variables
     16          

   \                                 In section .data, align 4
     17          extern int slow_irc_freq = 32768; // default slow irc frequency is 32768Hz
   \                     slow_irc_freq:
   \   00000000   0x00008000         DC32 32768

   \                                 In section .data, align 4
     18          extern int fast_irc_freq = 4000000; // default fast irc frequency is 4MHz
   \                     fast_irc_freq:
   \   00000000   0x003D0900         DC32 4000000
     19          
     20          extern int core_clk_khz;
     21          extern int core_clk_mhz;
     22          extern int periph_clk_khz;
     23          extern char drs_val, dmx32_val;
     24          

   \                                 In section .text, align 2, keep-with-next
     25          unsigned char fll_rtc_init(unsigned char clk_option, unsigned char crystal_val)
     26          {
   \                     fll_rtc_init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     27            unsigned char pll_freq;
     28          
     29            rtc_as_refclk();
   \   00000006   0x.... 0x....      BL       rtc_as_refclk
     30            pll_freq = 24;
   \   0000000A   0x2018             MOVS     R0,#+24
   \   0000000C   0x0006             MOVS     R6,R0
     31            return pll_freq;
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
     32          }
     33          

   \                                 In section .text, align 2, keep-with-next
     34          unsigned char pll_init(unsigned char clk_option, unsigned char crystal_val)
     35          {
   \                     pll_init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     36            unsigned char pll_freq;
     37          
     38            if (clk_option > 3) {return 0;} //return 0 if one of the available options is not selected
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C04             CMP      R4,#+4
   \   0000000A   0xD301             BCC.N    ??pll_init_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE089             B.N      ??pll_init_1
     39            if (crystal_val > 15) {return 1;} // return 1 if one of the available crystal options is not available
   \                     ??pll_init_0:
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D10             CMP      R5,#+16
   \   00000014   0xD301             BCC.N    ??pll_init_2
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE084             B.N      ??pll_init_1
     40          //This assumes that the MCG is in default FEI mode out of reset.
     41          
     42          // First move to FBE mode
     43          #if (defined(K60_CLK) || defined(ASB817)||defined(K53_CLK))
     44               MCG_C2 = 0;
   \                     ??pll_init_2:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7001             STRB     R1,[R0, #+0]
     45          #else
     46          // Enable external oscillator, RANGE=2, HGO=1, EREFS=1, LP=0, IRCS=0
     47              MCG_C2 = MCG_C2_RANGE(2) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
     48          #endif
     49          
     50          // after initialization of oscillator release latched state of oscillator and GPIO
     51              SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40048034
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x40048034
   \   00000030   0x6008             STR      R0,[R1, #+0]
     52              LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4007c008
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x4007c008
   \   00000040   0x7008             STRB     R0,[R1, #+0]
     53            
     54          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
     55          // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
     56            MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40064000
   \   00000046   0x2198             MOVS     R1,#+152
   \   00000048   0x7001             STRB     R1,[R0, #+0]
     57          
     58            /* if we aren't using an osc input we don't need to wait for the osc to init */
     59          #if (!defined(K60_CLK) && !defined(ASB817)&& !defined(K53_CLK))
     60              while (!(MCG_S & MCG_S_OSCINIT_MASK)){};  // wait for oscillator to initialize
     61          #endif
     62          
     63            while (MCG_S & MCG_S_IREFST_MASK){}; // wait for Reference clock Status bit to clear
   \                     ??pll_init_3:
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x06C0             LSLS     R0,R0,#+27
   \   00000052   0xD4FA             BMI.N    ??pll_init_3
     64          
     65            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // Wait for clock status bits to show clock source is ext ref clk
   \                     ??pll_init_4:
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD1F7             BNE.N    ??pll_init_4
     66          
     67          // Now in FBE
     68          
     69          #if (defined(K60_CLK)||defined(K53_CLK))
     70             MCG_C5 = MCG_C5_PRDIV(0x18);
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40064004
   \   00000068   0x2118             MOVS     R1,#+24
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
     71          #else
     72          // Configure PLL Ref Divider, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
     73          // The crystal frequency is used to select the PRDIV value. Only even frequency crystals are supported
     74          // that will produce a 2MHz reference clock to the PLL.
     75            MCG_C5 = MCG_C5_PRDIV(crystal_val); // Set PLL ref divider to match the crystal used
     76          #endif
     77          
     78            // Ensure MCG_C6 is at the reset default of 0. LOLIE disabled, PLL disabled, clk monitor disabled, PLL VCO divider is clear
     79            MCG_C6 = 0x0;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x7001             STRB     R1,[R0, #+0]
     80          // Select the PLL VCO divider and system clock dividers depending on clocking option
     81            switch (clk_option) {
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD005             BEQ.N    ??pll_init_5
   \   0000007A   0x2C02             CMP      R4,#+2
   \   0000007C   0xD01D             BEQ.N    ??pll_init_6
   \   0000007E   0xD30F             BCC.N    ??pll_init_7
   \   00000080   0x2C03             CMP      R4,#+3
   \   00000082   0xD027             BEQ.N    ??pll_init_8
   \   00000084   0xE032             B.N      ??pll_init_9
     82              case 0:
     83                // Set system options dividers
     84                //MCG=PLL, core = MCG, bus = MCG, FlexBus = MCG, Flash clock= MCG/2
     85                set_sys_dividers(0,0,0,1);
   \                     ??pll_init_5:
   \   00000086   0x2301             MOVS     R3,#+1
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      BL       set_sys_dividers
     86                // Set the VCO divider and enable the PLL for 50MHz, LOLIE=0, PLLS=1, CME=0, VDIV=1
     87                MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(1); //VDIV = 1 (x25)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   00000096   0x2141             MOVS     R1,#+65
   \   00000098   0x7001             STRB     R1,[R0, #+0]
     88                pll_freq = 50;
   \   0000009A   0x2032             MOVS     R0,#+50
   \   0000009C   0x0006             MOVS     R6,R0
     89                break;
   \   0000009E   0xE025             B.N      ??pll_init_9
     90             case 1:
     91                // Set system options dividers
     92                //MCG=PLL, core = MCG, bus = MCG/2, FlexBus = MCG/2, Flash clock= MCG/4
     93               set_sys_dividers(0,1,1,3);
   \                     ??pll_init_7:
   \   000000A0   0x2303             MOVS     R3,#+3
   \   000000A2   0x2201             MOVS     R2,#+1
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x.... 0x....      BL       set_sys_dividers
     94                // Set the VCO divider and enable the PLL for 100MHz, LOLIE=0, PLLS=1, CME=0, VDIV=26
     95                MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(26); //VDIV = 26 (x50)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   000000B0   0x215A             MOVS     R1,#+90
   \   000000B2   0x7001             STRB     R1,[R0, #+0]
     96                pll_freq = 100;
   \   000000B4   0x2064             MOVS     R0,#+100
   \   000000B6   0x0006             MOVS     R6,R0
     97                break;
   \   000000B8   0xE018             B.N      ??pll_init_9
     98              case 2:
     99                // Set system options dividers
    100                //MCG=PLL, core = MCG, bus = MCG/2, FlexBus = MCG/2, Flash clock= MCG/4
    101                set_sys_dividers(0,1,1,3);
   \                     ??pll_init_6:
   \   000000BA   0x2303             MOVS     R3,#+3
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       set_sys_dividers
    102                // Set the VCO divider and enable the PLL for 96MHz, LOLIE=0, PLLS=1, CME=0, VDIV=24
    103                MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(24); //VDIV = 24 (x48)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   000000CA   0x2158             MOVS     R1,#+88
   \   000000CC   0x7001             STRB     R1,[R0, #+0]
    104                pll_freq = 96;
   \   000000CE   0x2060             MOVS     R0,#+96
   \   000000D0   0x0006             MOVS     R6,R0
    105                break;
   \   000000D2   0xE00B             B.N      ??pll_init_9
    106             case 3:
    107                // Set system options dividers
    108                //MCG=PLL, core = MCG, bus = MCG, FlexBus = MCG, Flash clock= MCG/2
    109                set_sys_dividers(0,0,0,1);
   \                     ??pll_init_8:
   \   000000D4   0x2301             MOVS     R3,#+1
   \   000000D6   0x2200             MOVS     R2,#+0
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x.... 0x....      BL       set_sys_dividers
    110                // Set the VCO divider and enable the PLL for 48MHz, LOLIE=0, PLLS=1, CME=0, VDIV=0
    111                MCG_C6 = MCG_C6_PLLS_MASK; //VDIV = 0 (x24)
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   000000E4   0x2140             MOVS     R1,#+64
   \   000000E6   0x7001             STRB     R1,[R0, #+0]
    112                pll_freq = 48;
   \   000000E8   0x2030             MOVS     R0,#+48
   \   000000EA   0x0006             MOVS     R6,R0
    113                break;
    114            }
    115            while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
   \                     ??pll_init_9:
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x0680             LSLS     R0,R0,#+26
   \   000000F4   0xD5FA             BPL.N    ??pll_init_9
    116          
    117            while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
   \                     ??pll_init_10:
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   000000FA   0x7800             LDRB     R0,[R0, #+0]
   \   000000FC   0x0640             LSLS     R0,R0,#+25
   \   000000FE   0xD5FA             BPL.N    ??pll_init_10
    118          
    119          // Now running PBE Mode
    120          
    121          // Transition into PEE by setting CLKS to 0
    122          // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    123            MCG_C1 &= ~MCG_C1_CLKS_MASK;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40064000
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   0000010E   0x7008             STRB     R0,[R1, #+0]
    124          
    125          // Wait for clock status bits to update
    126            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
   \                     ??pll_init_11:
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   0000011A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011C   0x2803             CMP      R0,#+3
   \   0000011E   0xD1F7             BNE.N    ??pll_init_11
    127          
    128          // Now running PEE Mode
    129          
    130          return pll_freq;
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??pll_init_1:
   \   00000124   0xBD70             POP      {R4-R6,PC}       ;; return
    131          } //pll_init
    132          
    133          
    134           /*
    135            * This routine must be placed in RAM. It is a workaround for errata e2448.
    136            * Flash prefetch must be disabled when the flash clock divider is changed.
    137            * This cannot be performed while executing out of flash.
    138            * There must be a short delay after the clock dividers are changed before prefetch
    139            * can be re-enabled.
    140            */
    141          #if (defined(IAR))

   \                                 In section .textrw, align 4, keep-with-next
    142          	__ramfunc void set_sys_dividers(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
    143          #elif (defined(CW))
    144          __relocate_code__ 
    145          void set_sys_dividers(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
    146          #endif
    147          {
   \                     set_sys_dividers:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    148            uint32 temp_reg;
    149            uint8 i;
    150            
    151            temp_reg = FMC_PFAPR; // store present value of FMC_PFAPR
   \   00000002   0x4E11             LDR.N    R6,??set_sys_dividers_0  ;; 0x4001f000
   \   00000004   0x6836             LDR      R6,[R6, #+0]
   \   00000006   0x0034             MOVS     R4,R6
    152            
    153            // set M0PFD through M7PFD to 1 to disable prefetch
    154            FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    155                       | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    156                       | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \   00000008   0x4E0F             LDR.N    R6,??set_sys_dividers_0  ;; 0x4001f000
   \   0000000A   0x6836             LDR      R6,[R6, #+0]
   \   0000000C   0xF456 0x067F      ORRS     R6,R6,#0xFF0000
   \   00000010   0x4F0D             LDR.N    R7,??set_sys_dividers_0  ;; 0x4001f000
   \   00000012   0x603E             STR      R6,[R7, #+0]
    157            
    158            // set clock dividers to desired value  
    159            SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    160                        | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);
   \   00000014   0x060E             LSLS     R6,R1,#+24
   \   00000016   0xF016 0x6670      ANDS     R6,R6,#0xF000000
   \   0000001A   0xEA56 0x7600      ORRS     R6,R6,R0, LSL #+28
   \   0000001E   0x0517             LSLS     R7,R2,#+20
   \   00000020   0xF417 0x0770      ANDS     R7,R7,#0xF00000
   \   00000024   0x433E             ORRS     R6,R7,R6
   \   00000026   0x041F             LSLS     R7,R3,#+16
   \   00000028   0xF417 0x2770      ANDS     R7,R7,#0xF0000
   \   0000002C   0x433E             ORRS     R6,R7,R6
   \   0000002E   0x4F07             LDR.N    R7,??set_sys_dividers_0+0x4  ;; 0x40048044
   \   00000030   0x603E             STR      R6,[R7, #+0]
    161          
    162            // wait for dividers to change
    163            for (i = 0 ; i < outdiv4 ; i++)
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0x0035             MOVS     R5,R6
   \                     ??set_sys_dividers_1:
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x429D             CMP      R5,R3
   \   0000003A   0xD201             BCS.N    ??set_sys_dividers_2
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0xE7FA             B.N      ??set_sys_dividers_1
    164            {}
    165            
    166            FMC_PFAPR = temp_reg; // re-store original value of FMC_PFAPR
   \                     ??set_sys_dividers_2:
   \   00000040   0x4E01             LDR.N    R6,??set_sys_dividers_0  ;; 0x4001f000
   \   00000042   0x6034             STR      R4,[R6, #+0]
    167            
    168            return;
   \   00000044   0xBCF0             POP      {R4-R7}
   \   00000046   0x4770             BX       LR               ;; return
   \                     ??set_sys_dividers_0:
   \   00000048   0x4001F000         DC32     0x4001f000
   \   0000004C   0x40048044         DC32     0x40048044
    169          } // set_sys_dividers
    170          
    171          
    172          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    173          void mcg_pee_2_blpi(void)
    174          {
    175              uint8 temp_reg;
    176              // Transition from PEE to BLPI: PEE -> PBE -> FBE -> FBI -> BLPI
    177            
    178              // Step 1: PEE -> PBE
    179              MCG_C1 |= MCG_C1_CLKS(2);  // System clock from external reference OSC, not PLL.
   \                     mcg_pee_2_blpi:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable15_3  ;; 0x40064000
   \   0000000E   0x7011             STRB     R1,[R2, #+0]
    180              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){};  // Wait for clock status to update.
   \                     ??mcg_pee_2_blpi_0:
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD1F7             BNE.N    ??mcg_pee_2_blpi_0
    181              
    182              // Step 2: PBE -> FBE
    183              MCG_C6 &= ~MCG_C6_PLLS_MASK;  // Clear PLLS to select FLL, still running system from ext OSC.
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x40064005
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0xF011 0x01BF      ANDS     R1,R1,#0xBF
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable15_6  ;; 0x40064005
   \   0000002E   0x7011             STRB     R1,[R2, #+0]
    184              while (MCG_S & MCG_S_PLLST_MASK){};  // Wait for PLL status flag to reflect FLL selected.
   \                     ??mcg_pee_2_blpi_1:
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x0689             LSLS     R1,R1,#+26
   \   00000038   0xD4FA             BMI.N    ??mcg_pee_2_blpi_1
    185              
    186              // Step 3: FBE -> FBI
    187              MCG_C2 &= ~MCG_C2_LP_MASK;  // FLL remains active in bypassed modes.
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40064001
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0xF011 0x01FD      ANDS     R1,R1,#0xFD
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40064001
   \   00000048   0x7011             STRB     R1,[R2, #+0]
    188              MCG_C2 |= MCG_C2_IRCS_MASK;  // Select fast (1MHz) internal reference
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40064001
   \   0000004E   0x7809             LDRB     R1,[R1, #+0]
   \   00000050   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40064001
   \   00000058   0x7011             STRB     R1,[R2, #+0]
    189              temp_reg = MCG_C1;
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   0000005E   0x7809             LDRB     R1,[R1, #+0]
   \   00000060   0x0008             MOVS     R0,R1
    190              temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK);
   \   00000062   0xF010 0x003B      ANDS     R0,R0,#0x3B
    191              temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK);  // Select internal reference (fast IREF clock @ 1MHz) as MCG clock source.
   \   00000066   0xF050 0x0044      ORRS     R0,R0,#0x44
    192              MCG_C1 = temp_reg;
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
    193            
    194              while (MCG_S & MCG_S_IREFST_MASK){};  // Wait for Reference Status bit to update.
   \                     ??mcg_pee_2_blpi_2:
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   00000074   0x7809             LDRB     R1,[R1, #+0]
   \   00000076   0x06C9             LSLS     R1,R1,#+27
   \   00000078   0xD4FA             BMI.N    ??mcg_pee_2_blpi_2
    195              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1){};  // Wait for clock status bits to update
   \                     ??mcg_pee_2_blpi_3:
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   0000007E   0x7809             LDRB     R1,[R1, #+0]
   \   00000080   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   00000084   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   0x2901             CMP      R1,#+1
   \   00000088   0xD1F7             BNE.N    ??mcg_pee_2_blpi_3
    196              
    197              // Step 4: FBI -> BLPI
    198              MCG_C1 |= MCG_C1_IREFSTEN_MASK;  // Keep internal reference clock running in STOP modes.
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   0000008E   0x7809             LDRB     R1,[R1, #+0]
   \   00000090   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000094   0x.... 0x....      LDR.W    R2,??DataTable15_3  ;; 0x40064000
   \   00000098   0x7011             STRB     R1,[R2, #+0]
    199              MCG_C2 |= MCG_C2_LP_MASK;  // FLL remains disabled in bypassed modes.
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40064001
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40064001
   \   000000A8   0x7011             STRB     R1,[R2, #+0]
    200              while (!(MCG_S & MCG_S_IREFST_MASK)){};  // Wait for Reference Status bit to update.
   \                     ??mcg_pee_2_blpi_4:
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   000000AE   0x7809             LDRB     R1,[R1, #+0]
   \   000000B0   0x06C9             LSLS     R1,R1,#+27
   \   000000B2   0xD5FA             BPL.N    ??mcg_pee_2_blpi_4
    201              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1){};  // Wait for clock status bits to update.
   \                     ??mcg_pee_2_blpi_5:
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   000000B8   0x7809             LDRB     R1,[R1, #+0]
   \   000000BA   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   000000BE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C0   0x2901             CMP      R1,#+1
   \   000000C2   0xD1F7             BNE.N    ??mcg_pee_2_blpi_5
    202            
    203          } // end MCG PEE to BLPI
   \   000000C4   0x4770             BX       LR               ;; return
    204          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    205          void mcg_blpi_2_pee(void)
    206          {
   \                     mcg_blpi_2_pee:
   \   00000000   0xB510             PUSH     {R4,LR}
    207              uint8 temp_reg;
    208              // Transition from BLPI to PEE: BLPI -> FBI -> FEI -> FBE -> PBE -> PEE
    209            
    210              // Step 1: BLPI -> FBI
    211              MCG_C2 &= ~MCG_C2_LP_MASK;  // FLL remains active in bypassed modes.
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40064001
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    212              while (!(MCG_S & MCG_S_IREFST_MASK)){};  // Wait for Reference Status bit to update.
   \                     ??mcg_blpi_2_pee_0:
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x06C0             LSLS     R0,R0,#+27
   \   0000001A   0xD5FA             BPL.N    ??mcg_blpi_2_pee_0
    213              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1){};  // Wait for clock status bits to update
   \                     ??mcg_blpi_2_pee_1:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD1F7             BNE.N    ??mcg_blpi_2_pee_1
    214              
    215              // Step 2: FBI -> FEI
    216              MCG_C2 &= ~MCG_C2_LP_MASK;  // FLL remains active in bypassed modes.
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40064001
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    217              temp_reg = MCG_C2;  // assign temporary variable of MCG_C2 contents
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x0004             MOVS     R4,R0
    218              temp_reg &= ~MCG_C2_RANGE_MASK;  // set RANGE field location to zero
   \   00000044   0xF014 0x04CF      ANDS     R4,R4,#0xCF
    219              temp_reg |= (0x2 << 0x4);  // OR in new values
   \   00000048   0xF054 0x0420      ORRS     R4,R4,#0x20
    220              MCG_C2 = temp_reg;  // store new value in MCG_C2
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   00000050   0x7004             STRB     R4,[R0, #+0]
    221              MCG_C4 = 0x0E;  // Low-range DCO output (~10MHz bus).  FCTRIM=%0111.
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40064003
   \   00000056   0x210E             MOVS     R1,#+14
   \   00000058   0x7001             STRB     R1,[R0, #+0]
    222              MCG_C1 = 0x04;  // Select internal clock as MCG source, FRDIV=%000, internal reference selected.
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40064000
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0x7001             STRB     R1,[R0, #+0]
    223           
    224              while (!(MCG_S & MCG_S_IREFST_MASK)){};   // Wait for Reference Status bit to update 
   \                     ??mcg_blpi_2_pee_2:
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x06C0             LSLS     R0,R0,#+27
   \   0000006A   0xD5FA             BPL.N    ??mcg_blpi_2_pee_2
    225              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0){}; // Wait for clock status bits to update
   \                     ??mcg_blpi_2_pee_3:
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD1F7             BNE.N    ??mcg_blpi_2_pee_3
    226              
    227              // Handle FEI to PEE transitions using standard clock initialization routine.
    228              core_clk_mhz = pll_init(CORE_CLK_MHZ, REF_CLK); 
   \   0000007C   0x2103             MOVS     R1,#+3
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x.... 0x....      BL       pll_init
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable15_8
   \   00000088   0x6008             STR      R0,[R1, #+0]
    229          
    230              /* Use the value obtained from the pll_init function to define variables
    231              * for the core clock in kHz and also the peripheral clock. These
    232              * variables can be used by other functions that need awareness of the
    233              * system frequency.
    234              */
    235              core_clk_khz = core_clk_mhz * 1000;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF44F 0x717A      MOV      R1,#+1000
   \   00000094   0x4348             MULS     R0,R1,R0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    236              periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);        
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable15_10  ;; 0x40048044
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   000000AC   0x1C49             ADDS     R1,R1,#+1
   \   000000AE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    237          } // end MCG BLPI to PEE
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    238          /********************************************************************/
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void mcg_pbe_2_pee(void)
    241          {  
    242            MCG_C1 &= ~MCG_C1_CLKS_MASK; // select PLL as MCG_OUT
   \                     mcg_pbe_2_pee:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40064000
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    243            // Wait for clock status bits to update 
    244            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){}; 
   \                     ??mcg_pbe_2_pee_0:
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD1F7             BNE.N    ??mcg_pbe_2_pee_0
    245          
    246            switch (CORE_CLK_MHZ) {
    247              case PLL50:
    248                core_clk_khz = 50000;
    249                break;
    250              case PLL100:
    251                core_clk_khz = 100000;
    252                break;
    253              case PLL96:
    254                core_clk_khz = 96000;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable15_12  ;; 0x17700
   \   00000028   0x6001             STR      R1,[R0, #+0]
    255                break;  
    256              case PLL48:
    257                core_clk_khz = 48000;
    258                break;  
    259            }
    260          }
   \   0000002A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    261          void rtc_as_refclk(void)
    262          {
   \                     rtc_as_refclk:
   \   00000000   0xB510             PUSH     {R4,LR}
    263            unsigned char temp_reg;
    264            
    265          // Using the RTC OSC as FLL Ref Clk
    266          // enable RTC clock gating
    267            SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;  
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_13  ;; 0x4004803c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_13  ;; 0x4004803c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    268          // set RTC in default state using software reset
    269            RTC_CR |= RTC_CR_SWR_MASK; // set SWR
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_14  ;; 0x4003d010
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15_14  ;; 0x4003d010
   \   00000020   0x6008             STR      R0,[R1, #+0]
    270            RTC_CR &= ~RTC_CR_SWR_MASK; // clear SWR
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_14  ;; 0x4003d010
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_14  ;; 0x4003d010
   \   00000030   0x6008             STR      R0,[R1, #+0]
    271          // Configure and enable the RTC OSC
    272          // select the load caps (application dependent) and the oscillator enable bit
    273          // note that other bits in this register may need to be set depending on the intended use of the RTC
    274            
    275            RTC_CR |= RTC_CR_OSCE_MASK;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_14  ;; 0x4003d010
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF44F 0x7180      MOV      R1,#+256
   \   0000003C   0x4308             ORRS     R0,R1,R0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable15_14  ;; 0x4003d010
   \   00000042   0x6008             STR      R0,[R1, #+0]
    276          
    277            time_delay_ms(1000); // wait for the RTC oscillator to intialize
   \   00000044   0xF44F 0x707A      MOV      R0,#+1000
   \   00000048   0x.... 0x....      BL       time_delay_ms
    278          // select the RTC oscillator as the MCG reference clock
    279            SIM_SOPT2 |= SIM_SOPT2_MCGCLKSEL_MASK;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable15_15  ;; 0x40048004
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable15_15  ;; 0x40048004
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    280            
    281          // ensure MCG_C2 is in the reset state, key items are RANGE = 0 to select the correct FRDIV factor
    282          // and LP = 0 to keep FLL enabled. HGO and EREFS do not affect RTC oscillator  
    283            MCG_C2 = 0x0;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x7001             STRB     R1,[R0, #+0]
    284            
    285          // Select the Reference Divider and clear IREFS to select the osc
    286          // CLKS=0, select the FLL as the clock source for MCGOUTCLK
    287          // FRDIV=0, set the FLL ref divider to divide by 1 
    288          // IREFS=0, select the external clock 
    289          // IRCLKEN=0, disable IRCLK (can enable if desired)
    290          // IREFSTEN=0, disable IRC in stop mode (can keep it enabled in stop if desired)
    291            MCG_C1 = 0x0;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40064000
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
    292          
    293            while (MCG_S & MCG_S_IREFST_MASK){}; // wait for Reference clock to switch to external reference
   \                     ??rtc_as_refclk_0:
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x06C0             LSLS     R0,R0,#+27
   \   00000074   0xD4FA             BMI.N    ??rtc_as_refclk_0
    294              
    295            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0){}; // Wait for clock status bits to update
   \                     ??rtc_as_refclk_1:
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD1F7             BNE.N    ??rtc_as_refclk_1
    296            
    297          // Can select the FLL operating range/freq by means of the DRS and DMX32 bits
    298          // Must first ensure the system clock dividers are set to keep the core and bus clocks
    299          // within spec.
    300          //  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) 
    301          //              | SIM_CLKDIV1_OUTDIV3(0) | SIM_CLKDIV1_OUTDIV4(1);
    302          
    303            temp_reg = MCG_C4;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40064003
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x0004             MOVS     R4,R0
    304            temp_reg &= ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK); // clear the DMX32 bit and DRS field
   \   0000008E   0xF014 0x041F      ANDS     R4,R4,#0x1F
    305            temp_reg |= (MCG_C4_DRST_DRS(drs_val) | (dmx32_val << MCG_C4_DMX32_SHIFT)); // select DRS range and dmx32 setting
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable15_16
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x0140             LSLS     R0,R0,#+5
   \   0000009A   0xF010 0x0060      ANDS     R0,R0,#0x60
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0x01C9             LSLS     R1,R1,#+7
   \   000000A6   0x4308             ORRS     R0,R1,R0
   \   000000A8   0x4304             ORRS     R4,R0,R4
    306            MCG_C4 = temp_reg;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40064003
   \   000000AE   0x7004             STRB     R4,[R0, #+0]
    307            
    308          // should enable clock monitor now that external reference is being used
    309          //  MCG_C6 |= MCG_C6_CME_MASK;
    310            
    311            core_clk_khz = fll_freq(32768); // calculate core clock based on 32768 crystal reference
   \   000000B0   0xF44F 0x4000      MOV      R0,#+32768
   \   000000B4   0x.... 0x....      BL       fll_freq
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    312            periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable15_10  ;; 0x40048044
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   000000CE   0x1C49             ADDS     R1,R1,#+1
   \   000000D0   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   000000D8   0x6008             STR      R0,[R1, #+0]
    313          } //end cmd_rtc_as_refclk
   \   000000DA   0xBD10             POP      {R4,PC}          ;; return
    314          
    315          

   \                                 In section .text, align 2, keep-with-next
    316          void fee_fei(void)
    317          {
   \                     fee_fei:
   \   00000000   0xB510             PUSH     {R4,LR}
    318            unsigned char temp_reg;
    319            
    320            // first ensure clock monitor is disabled otherwise a loss of clock reset will occur
    321            MCG_C6 &= ~MCG_C6_CME_MASK;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x40064005
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    322            
    323            MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40064000
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    324            
    325            // wait for Reference clock to switch to internal reference 
    326            while (!(MCG_S & MCG_S_IREFST_MASK)){}
   \                     ??fee_fei_0:
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x06C0             LSLS     R0,R0,#+27
   \   0000002A   0xD5FA             BPL.N    ??fee_fei_0
    327            
    328            // Select the system oscillator as the MCG reference clock.
    329            // Not typically requred to set this as default is system oscillator.
    330            // This is not required as part of moving to FEI but is performed here to ensure the system
    331            // oscillator is used in future mode changes.
    332            SIM_SOPT2 &= ~SIM_SOPT2_MCGCLKSEL_MASK;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable15_15  ;; 0x40048004
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable15_15  ;; 0x40048004
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    333            
    334            temp_reg = MCG_C4;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40064003
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x0004             MOVS     R4,R0
    335            temp_reg &= ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK); // clear the DMX32 bit and DRS field
   \   00000044   0xF014 0x041F      ANDS     R4,R4,#0x1F
    336            temp_reg |= (MCG_C4_DRST_DRS(drs_val) | (dmx32_val << MCG_C4_DMX32_SHIFT)); // select DRS range and dmx32 setting
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable15_16
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x0140             LSLS     R0,R0,#+5
   \   00000050   0xF010 0x0060      ANDS     R0,R0,#0x60
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \   00000058   0x7809             LDRB     R1,[R1, #+0]
   \   0000005A   0x01C9             LSLS     R1,R1,#+7
   \   0000005C   0x4308             ORRS     R0,R1,R0
   \   0000005E   0x4304             ORRS     R4,R0,R4
    337            MCG_C4 = temp_reg;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40064003
   \   00000064   0x7004             STRB     R4,[R0, #+0]
    338            
    339            core_clk_khz = fll_freq(slow_irc_freq);
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable15_18
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       fll_freq
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   00000074   0x6008             STR      R0,[R1, #+0]
    340            periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_10  ;; 0x40048044
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   00000086   0x1C49             ADDS     R1,R1,#+1
   \   00000088   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000090   0x6008             STR      R0,[R1, #+0]
    341              
    342          } // fee_fei
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    343          
    344          

   \                                 In section .text, align 2, keep-with-next
    345          int fll_freq(int fll_ref)
    346          {
   \                     fll_freq:
   \   00000000   0x0001             MOVS     R1,R0
    347            int fll_freq_khz;
    348            
    349            if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable15_7  ;; 0x40064003
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0x0612             LSLS     R2,R2,#+24
   \   0000000A   0xD536             BPL.N    ??fll_freq_0
    350            {
    351              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable15_7  ;; 0x40064003
   \   00000010   0x7812             LDRB     R2,[R2, #+0]
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x0952             LSRS     R2,R2,#+5
   \   00000016   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD005             BEQ.N    ??fll_freq_1
   \   0000001E   0x2A02             CMP      R2,#+2
   \   00000020   0xD017             BEQ.N    ??fll_freq_2
   \   00000022   0xD30C             BCC.N    ??fll_freq_3
   \   00000024   0x2A03             CMP      R2,#+3
   \   00000026   0xD01E             BEQ.N    ??fll_freq_4
   \   00000028   0xE05D             B.N      ??fll_freq_5
    352              {
    353              case 0:
    354                fll_freq_khz = ((fll_ref * 732) / 1000);
   \                     ??fll_freq_1:
   \   0000002A   0xF44F 0x7237      MOV      R2,#+732
   \   0000002E   0xFB02 0xF201      MUL      R2,R2,R1
   \   00000032   0xF44F 0x737A      MOV      R3,#+1000
   \   00000036   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   0000003A   0x0010             MOVS     R0,R2
    355                break;
   \   0000003C   0xE053             B.N      ??fll_freq_5
    356              case 1:
    357                fll_freq_khz = ((fll_ref * 1464) / 1000);
   \                     ??fll_freq_3:
   \   0000003E   0xF44F 0x62B7      MOV      R2,#+1464
   \   00000042   0xFB02 0xF201      MUL      R2,R2,R1
   \   00000046   0xF44F 0x737A      MOV      R3,#+1000
   \   0000004A   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   0000004E   0x0010             MOVS     R0,R2
    358                break;
   \   00000050   0xE049             B.N      ??fll_freq_5
    359              case 2:
    360                fll_freq_khz = ((fll_ref * 2197) / 1000);
   \                     ??fll_freq_2:
   \   00000052   0xF640 0x0295      MOVW     R2,#+2197
   \   00000056   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000005A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000005E   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000062   0x0010             MOVS     R0,R2
    361                break;
   \   00000064   0xE03F             B.N      ??fll_freq_5
    362              case 3:
    363                fll_freq_khz = ((fll_ref * 2929) / 1000);
   \                     ??fll_freq_4:
   \   00000066   0xF640 0x3271      MOVW     R2,#+2929
   \   0000006A   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000006E   0xF44F 0x737A      MOV      R3,#+1000
   \   00000072   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000076   0x0010             MOVS     R0,R2
    364                break;
   \   00000078   0xE035             B.N      ??fll_freq_5
    365              }
    366            }
    367            else // if DMX32 = 0
    368            {
    369              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \                     ??fll_freq_0:
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable15_7  ;; 0x40064003
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   0x0952             LSRS     R2,R2,#+5
   \   00000084   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000088   0x2A00             CMP      R2,#+0
   \   0000008A   0xD005             BEQ.N    ??fll_freq_6
   \   0000008C   0x2A02             CMP      R2,#+2
   \   0000008E   0xD017             BEQ.N    ??fll_freq_7
   \   00000090   0xD30C             BCC.N    ??fll_freq_8
   \   00000092   0x2A03             CMP      R2,#+3
   \   00000094   0xD01E             BEQ.N    ??fll_freq_9
   \   00000096   0xE026             B.N      ??fll_freq_5
    370              {
    371              case 0:
    372                fll_freq_khz = ((fll_ref * 640) / 1000);
   \                     ??fll_freq_6:
   \   00000098   0xF44F 0x7220      MOV      R2,#+640
   \   0000009C   0xFB02 0xF201      MUL      R2,R2,R1
   \   000000A0   0xF44F 0x737A      MOV      R3,#+1000
   \   000000A4   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   000000A8   0x0010             MOVS     R0,R2
    373                break;
   \   000000AA   0xE01C             B.N      ??fll_freq_5
    374              case 1:
    375                fll_freq_khz = ((fll_ref * 1280) / 1000);
   \                     ??fll_freq_8:
   \   000000AC   0xF44F 0x62A0      MOV      R2,#+1280
   \   000000B0   0xFB02 0xF201      MUL      R2,R2,R1
   \   000000B4   0xF44F 0x737A      MOV      R3,#+1000
   \   000000B8   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   000000BC   0x0010             MOVS     R0,R2
    376                break;
   \   000000BE   0xE012             B.N      ??fll_freq_5
    377              case 2:
    378                fll_freq_khz = ((fll_ref * 1920) / 1000);
   \                     ??fll_freq_7:
   \   000000C0   0xF44F 0x62F0      MOV      R2,#+1920
   \   000000C4   0xFB02 0xF201      MUL      R2,R2,R1
   \   000000C8   0xF44F 0x737A      MOV      R3,#+1000
   \   000000CC   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   000000D0   0x0010             MOVS     R0,R2
    379                break;
   \   000000D2   0xE008             B.N      ??fll_freq_5
    380              case 3:
    381                fll_freq_khz = ((fll_ref * 2560) / 1000);
   \                     ??fll_freq_9:
   \   000000D4   0xF44F 0x6220      MOV      R2,#+2560
   \   000000D8   0xFB02 0xF201      MUL      R2,R2,R1
   \   000000DC   0xF44F 0x737A      MOV      R3,#+1000
   \   000000E0   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   000000E4   0x0010             MOVS     R0,R2
    382                break;
    383              }
    384            }    
    385            return fll_freq_khz;
   \                     ??fll_freq_5:
   \   000000E6   0x4770             BX       LR               ;; return
    386          } // fll_freq
    387          

   \                                 In section .text, align 2, keep-with-next
    388          int fei_fbe(unsigned char crystal_val, unsigned char hgo_val)
    389          {
   \                     fei_fbe:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    390            unsigned char frdiv_val;
    391            int i;
    392            
    393            if ((crystal_val > 15) && (crystal_val != 24)) {return 1;} // return 1 if one of the available crystal options is not available
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x2A10             CMP      R2,#+16
   \   00000008   0xD304             BCC.N    ??fei_fbe_0
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x2A18             CMP      R2,#+24
   \   0000000E   0xD001             BEQ.N    ??fei_fbe_0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE05C             B.N      ??fei_fbe_1
    394            
    395            if (hgo_val > 0)
   \                     ??fei_fbe_0:
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD301             BCC.N    ??fei_fbe_2
    396            {
    397              hgo_val = 1; // force hgo_val to 1 if > 0
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x0001             MOVS     R1,R0
    398            }
    399          
    400          #if (defined(K60_CLK))
    401               MCG_C2 = MCG_C2_RANGE(1); // select external clock and set range to provide correct FRDIV range
   \                     ??fei_fbe_2:
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40064001
   \   00000022   0x2510             MOVS     R5,#+16
   \   00000024   0x7005             STRB     R5,[R0, #+0]
    402          #else
    403          // Enable external oscillator, select range based on crystal frequency
    404            if (crystal_val < 4)
    405            {
    406              MCG_C2 = MCG_C2_RANGE(1) | (MCG_C2_HGO_MASK << MCG_C2_HGO_SHIFT) | MCG_C2_EREFS_MASK;
    407            }
    408            else
    409            {
    410              MCG_C2 = MCG_C2_RANGE(2) | (MCG_C2_HGO_MASK << MCG_C2_HGO_SHIFT) | MCG_C2_EREFS_MASK;
    411            }
    412          #endif
    413          
    414            switch (crystal_val) // determine FRDIV based on reference clock frequency
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x0010             MOVS     R0,R2
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD008             BEQ.N    ??fei_fbe_3
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0xD009             BEQ.N    ??fei_fbe_4
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD909             BLS.N    ??fei_fbe_5
   \   00000038   0x1EC0             SUBS     R0,R0,#+3
   \   0000003A   0x2804             CMP      R0,#+4
   \   0000003C   0xD909             BLS.N    ??fei_fbe_6
   \   0000003E   0xE00B             B.N      ??fei_fbe_7
    415              {
    416              case 0:
    417                frdiv_val = 1;
   \                     ??fei_fbe_3:
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x0003             MOVS     R3,R0
    418                break;
   \   00000044   0xE00A             B.N      ??fei_fbe_8
    419              case 1:
    420                frdiv_val = 2;
   \                     ??fei_fbe_4:
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x0003             MOVS     R3,R0
    421                break;
   \   0000004A   0xE007             B.N      ??fei_fbe_8
    422              case 2:
    423              case 3:
    424              case 4:
    425                frdiv_val = 3;
   \                     ??fei_fbe_5:
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x0003             MOVS     R3,R0
    426                break;
   \   00000050   0xE004             B.N      ??fei_fbe_8
    427              case 5:
    428              case 6:
    429              case 7:
    430              case 8:
    431              case 9:
    432                frdiv_val = 4;
   \                     ??fei_fbe_6:
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x0003             MOVS     R3,R0
    433                break;
   \   00000056   0xE001             B.N      ??fei_fbe_8
    434              default:
    435                frdiv_val = 5;        
   \                     ??fei_fbe_7:
   \   00000058   0x2005             MOVS     R0,#+5
   \   0000005A   0x0003             MOVS     R3,R0
    436                break;
    437              }
    438          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    439          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
    440            MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val);
   \                     ??fei_fbe_8:
   \   0000005C   0x00D8             LSLS     R0,R3,#+3
   \   0000005E   0xF010 0x0038      ANDS     R0,R0,#0x38
   \   00000062   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000066   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40064000
   \   0000006A   0x7028             STRB     R0,[R5, #+0]
    441          
    442            /* if we aren't using an osc input we don't need to wait for the osc to init */
    443          #if (!defined(K60_CLK))
    444          //  while (!(MCG_S & MCG_S_OSCINIT_MASK)){};  // wait for oscillator to initialize
    445            for (i = 0 ; i < 10000 ; i++)
    446            {
    447              if (MCG_S & MCG_S_OSCINIT_MASK) break; // jump out early if OSCINIT sets before loop finishes
    448            }
    449            if (!(MCG_S & MCG_S_OSCINIT_MASK)) return 2; // check bit is really set and return with error if not set
    450          #endif
    451          
    452          //  while (MCG_S & MCG_S_IREFST_MASK){}; // wait for Reference clock Status bit to clear
    453            for (i = 0 ; i < 2000 ; i++)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0004             MOVS     R4,R0
   \                     ??fei_fbe_9:
   \   00000070   0xF5B4 0x6FFA      CMP      R4,#+2000
   \   00000074   0xDA06             BGE.N    ??fei_fbe_10
    454            {
    455              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x06C0             LSLS     R0,R0,#+27
   \   0000007E   0xD501             BPL.N    ??fei_fbe_10
    456            }
   \                     ??fei_fbe_11:
   \   00000080   0x1C64             ADDS     R4,R4,#+1
   \   00000082   0xE7F5             B.N      ??fei_fbe_9
    457            if (MCG_S & MCG_S_IREFST_MASK) return 3; // check bit is really clear and return with error if not set
   \                     ??fei_fbe_10:
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x06C0             LSLS     R0,R0,#+27
   \   0000008C   0xD501             BPL.N    ??fei_fbe_12
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0xE01D             B.N      ??fei_fbe_1
    458            
    459          //  while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // Wait for clock status bits to show clock source is ext ref clk
    460            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbe_12:
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0004             MOVS     R4,R0
   \                     ??fei_fbe_13:
   \   00000096   0xF5B4 0x6FFA      CMP      R4,#+2000
   \   0000009A   0xDA09             BGE.N    ??fei_fbe_14
    461            {
    462              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2802             CMP      R0,#+2
   \   000000AA   0xD001             BEQ.N    ??fei_fbe_14
    463            }
   \                     ??fei_fbe_15:
   \   000000AC   0x1C64             ADDS     R4,R4,#+1
   \   000000AE   0xE7F2             B.N      ??fei_fbe_13
    464            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 4; // check EXT CLK is really selected and return with error if not
   \                     ??fei_fbe_14:
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x2802             CMP      R0,#+2
   \   000000BE   0xD001             BEQ.N    ??fei_fbe_16
   \   000000C0   0x2004             MOVS     R0,#+4
   \   000000C2   0xE004             B.N      ??fei_fbe_1
    465            
    466            return ((crystal_val + 1) * 2 * 1000); // MCGOUT frequency in kHz = crystal value * 2 * 1000
   \                     ??fei_fbe_16:
   \   000000C4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C6   0x1C50             ADDS     R0,R2,#+1
   \   000000C8   0xF44F 0x62FA      MOV      R2,#+2000
   \   000000CC   0x4350             MULS     R0,R2,R0
   \                     ??fei_fbe_1:
   \   000000CE   0xBC30             POP      {R4,R5}
   \   000000D0   0x4770             BX       LR               ;; return
    467          
    468          // Now in FBE
    469          }
    470          

   \                                 In section .text, align 2, keep-with-next
    471          void fbe_pbe(unsigned char prdiv_val, unsigned char vdiv_val)
    472          {  
    473            MCG_C5 = MCG_C5_PRDIV(prdiv_val);    //set PLL ref divider
   \                     fbe_pbe:
   \   00000000   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable15_5  ;; 0x40064004
   \   00000008   0x701A             STRB     R2,[R3, #+0]
    474          
    475          // the PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk  
    476            MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(24);
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable15_6  ;; 0x40064005
   \   0000000E   0x2358             MOVS     R3,#+88
   \   00000010   0x7013             STRB     R3,[R2, #+0]
    477            
    478            while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
   \                     ??fbe_pbe_0:
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable15_4  ;; 0x40064006
   \   00000016   0x7812             LDRB     R2,[R2, #+0]
   \   00000018   0x0692             LSLS     R2,R2,#+26
   \   0000001A   0xD5FA             BPL.N    ??fbe_pbe_0
    479          
    480            while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
   \                     ??fbe_pbe_1:
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable15_4  ;; 0x40064006
   \   00000020   0x7812             LDRB     R2,[R2, #+0]
   \   00000022   0x0652             LSLS     R2,R2,#+25
   \   00000024   0xD5FA             BPL.N    ??fbe_pbe_1
    481          // now in PBE 
    482          // PBE frequency = FBE frequency, no need to change frequency
    483          }
   \   00000026   0x4770             BX       LR               ;; return
    484          

   \                                 In section .text, align 2, keep-with-next
    485          int pbe_pee(unsigned char crystal_val)
    486          {
   \                     pbe_pee:
   \   00000000   0xB410             PUSH     {R4}
    487            unsigned char prdiv, vdiv;  
    488            MCG_C1 &= ~MCG_C1_CLKS_MASK; // switch CLKS mux to select PLL as MCG_OUT
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable15_3  ;; 0x40064000
   \   00000006   0x781B             LDRB     R3,[R3, #+0]
   \   00000008   0xF013 0x033F      ANDS     R3,R3,#0x3F
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable15_3  ;; 0x40064000
   \   00000010   0x7023             STRB     R3,[R4, #+0]
    489            // Wait for clock status bits to update 
    490            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){} 
   \                     ??pbe_pee_0:
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable15_4  ;; 0x40064006
   \   00000016   0x781B             LDRB     R3,[R3, #+0]
   \   00000018   0xF3C3 0x0381      UBFX     R3,R3,#+2,#+2
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x2B03             CMP      R3,#+3
   \   00000020   0xD1F7             BNE.N    ??pbe_pee_0
    491          
    492            prdiv = ((MCG_C5 & MCG_C5_PRDIV_MASK) + 1);
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable15_5  ;; 0x40064004
   \   00000026   0x781B             LDRB     R3,[R3, #+0]
   \   00000028   0xF013 0x031F      ANDS     R3,R3,#0x1F
   \   0000002C   0x1C5B             ADDS     R3,R3,#+1
   \   0000002E   0x0019             MOVS     R1,R3
    493            vdiv = ((MCG_C6 & MCG_C6_VDIV_MASK) + 24);
   \   00000030   0x.... 0x....      LDR.W    R3,??DataTable15_6  ;; 0x40064005
   \   00000034   0x781B             LDRB     R3,[R3, #+0]
   \   00000036   0xF013 0x031F      ANDS     R3,R3,#0x1F
   \   0000003A   0x3318             ADDS     R3,R3,#+24
   \   0000003C   0x001A             MOVS     R2,R3
    494            
    495            return (((((crystal_val + 1) * 2)/prdiv) * vdiv) * 1000); //calculate PLL output frequency
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x0040             LSLS     R0,R0,#+1
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000004A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004C   0x4350             MULS     R0,R2,R0
   \   0000004E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000052   0x4348             MULS     R0,R1,R0
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
    496          }
    497          

   \                                 In section .text, align 2, keep-with-next
    498          int pee_pbe(unsigned char crystal_val)
    499          {  
    500            MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
   \                     pee_pbe:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable15_3  ;; 0x40064000
   \   0000000E   0x7011             STRB     R1,[R2, #+0]
    501            // Wait for clock status bits to update 
    502            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; 
   \                     ??pee_pbe_0:
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD1F7             BNE.N    ??pee_pbe_0
    503          
    504          return ((crystal_val + 1) * 2000); // MCGOUT frequency in kHz
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xF44F 0x61FA      MOV      R1,#+2000
   \   00000028   0x4348             MULS     R0,R1,R0
   \   0000002A   0x4770             BX       LR               ;; return
    505          
    506          } // pee_pbe, freq = REF_CLK
    507          

   \                                 In section .text, align 2, keep-with-next
    508          void pbe_fbe(void)
    509          {
    510            MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLs to disable PLL, still clocked from ext ref clk
   \                     pbe_fbe:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40064005
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x40064005
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    511            
    512            while (MCG_S & MCG_S_PLLST_MASK){}; // wait for PLLS status bit to set
   \                     ??pbe_fbe_0:
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40064006
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x0680             LSLS     R0,R0,#+26
   \   00000018   0xD4FA             BMI.N    ??pbe_fbe_0
    513          // FBE frequency = PBE frequency, no need to change frequency  
    514          } 
   \   0000001A   0x4770             BX       LR               ;; return
    515          

   \                                 In section .text, align 2, keep-with-next
    516          void fbe_fbi_fast(void)
    517          {
    518            unsigned char temp_reg;
    519            
    520            MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \                     fbe_fbi_fast:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40064001
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000A   0x....             LDR.N    R2,??DataTable15  ;; 0x40064001
   \   0000000C   0x7011             STRB     R1,[R2, #+0]
    521            
    522            temp_reg = MCG_C1;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40064000
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x0008             MOVS     R0,R1
    523            temp_reg &= ~MCG_C1_CLKS_MASK;
   \   00000016   0xF010 0x003F      ANDS     R0,R0,#0x3F
    524            temp_reg |= MCG_C1_CLKS(1); // select IRC as MCGOUT
   \   0000001A   0xF050 0x0040      ORRS     R0,R0,#0x40
    525            MCG_C1 = temp_reg; // update MCG_C1
   \   0000001E   0x....             LDR.N    R1,??DataTable15_3  ;; 0x40064000
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    526            
    527            while (!(MCG_S & MCG_S_IRCST_MASK)){}; // wait until internal reference switches to fast clock.
   \                     ??fbe_fbi_fast_0:
   \   00000022   0x....             LDR.N    R1,??DataTable15_4  ;; 0x40064006
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x07C9             LSLS     R1,R1,#+31
   \   00000028   0xD5FB             BPL.N    ??fbe_fbi_fast_0
    528            
    529            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1){}; // Wait for clock status bits to update
   \                     ??fbe_fbi_fast_1:
   \   0000002A   0x....             LDR.N    R1,??DataTable15_4  ;; 0x40064006
   \   0000002C   0x7809             LDRB     R1,[R1, #+0]
   \   0000002E   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x2901             CMP      R1,#+1
   \   00000036   0xD1F8             BNE.N    ??fbe_fbi_fast_1
    530          // fast IRC clock speed is determined by FCTRIM value and must be trimmed to a known frequency
    531          } //fbe_fbi_fast
   \   00000038   0x4770             BX       LR               ;; return
    532          

   \                                 In section .text, align 2, keep-with-next
    533          void fbe_fbi_slow(void)
    534          {
    535            unsigned char temp_reg;
    536            
    537            MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     fbe_fbi_slow:
   \   00000000   0x....             LDR.N    R1,??DataTable15  ;; 0x40064001
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \   00000008   0x....             LDR.N    R2,??DataTable15  ;; 0x40064001
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
    538            
    539            temp_reg = MCG_C1;
   \   0000000C   0x....             LDR.N    R1,??DataTable15_3  ;; 0x40064000
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x0008             MOVS     R0,R1
    540            temp_reg &= ~MCG_C1_CLKS_MASK;
   \   00000012   0xF010 0x003F      ANDS     R0,R0,#0x3F
    541            temp_reg |= MCG_C1_CLKS(1); // select IRC as MCGOUT
   \   00000016   0xF050 0x0040      ORRS     R0,R0,#0x40
    542            MCG_C1 = temp_reg; // update MCG_C1
   \   0000001A   0x....             LDR.N    R1,??DataTable15_3  ;; 0x40064000
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    543            
    544            while (!(MCG_S & MCG_S_IRCST_MASK)){}; // wait until internal reference switches to fast clock.
   \                     ??fbe_fbi_slow_0:
   \   0000001E   0x....             LDR.N    R1,??DataTable15_4  ;; 0x40064006
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x07C9             LSLS     R1,R1,#+31
   \   00000024   0xD5FB             BPL.N    ??fbe_fbi_slow_0
    545            
    546            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1){}; // Wait for clock status bits to update
   \                     ??fbe_fbi_slow_1:
   \   00000026   0x....             LDR.N    R1,??DataTable15_4  ;; 0x40064006
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x2901             CMP      R1,#+1
   \   00000032   0xD1F8             BNE.N    ??fbe_fbi_slow_1
    547          // fast IRC clock speed is determined by FCTRIM value and must be trimmed to a known frequency
    548          } //fbe_fbi_slow
   \   00000034   0x4770             BX       LR               ;; return
    549          

   \                                 In section .text, align 2, keep-with-next
    550          void fbi_blpi(void)
    551          { 
    552            MCG_C2 |= MCG_C2_LP_MASK; //set LP bit to disable the FLL 
   \                     fbi_blpi:
   \   00000000   0x....             LDR.N    R0,??DataTable15  ;; 0x40064001
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable15  ;; 0x40064001
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    553          // no change in MCGOUT frequency  
    554          } 
   \   0000000C   0x4770             BX       LR               ;; return
    555          
    556          

   \                                 In section .text, align 4, keep-with-next
    557          int atc (unsigned char irc, int irc_freq)
    558          {
   \                     atc:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    559              uint32 temp_reg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    560              unsigned char temp_reg8 = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    561              uint32 orig_SIM_CLKDIV1;
    562              unsigned short atcv;
    563              unsigned char clks_val;
    564              unsigned int i;
    565                       
    566              printf("\n-------------------------------------------\n");
   \   0000000C   0x....             LDR.N    R0,??DataTable15_19
   \   0000000E   0x.... 0x....      BL       printf
    567              printf("  MCG AutoTrim Utility\n");
   \   00000012   0x....             LDR.N    R0,??DataTable15_20
   \   00000014   0x.... 0x....      BL       printf
    568              printf("-------------------------------------------\n");
   \   00000018   0x....             LDR.N    R0,??DataTable15_21
   \   0000001A   0x.... 0x....      BL       printf
    569              printf("\n");
   \   0000001E   0xA09A             ADR.N    R0,??atc_0       ;; "\n"
   \   00000020   0x.... 0x....      BL       printf
    570              {
    571                  if (irc > 0) // force irc to 1 if greater than 0
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD301             BCC.N    ??atc_1
    572                  {
    573                    irc = 1;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x0004             MOVS     R4,R0
    574                  }
    575                  
    576                  clks_val = ((MCG_C1 & MCG_C1_CLKS_MASK) >> 6);
   \                     ??atc_1:
   \   0000002E   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40064000
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x0980             LSRS     R0,R0,#+6
   \   00000036   0x4682             MOV      R10,R0
    577                  
    578                  if (((clks_val == 1) || (clks_val ==3)))
   \   00000038   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000003C   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000040   0xD004             BEQ.N    ??atc_2
   \   00000042   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000046   0xF1BA 0x0F03      CMP      R10,#+3
   \   0000004A   0xD104             BNE.N    ??atc_3
    579                  {
    580                    printf("\nAuto trim error - cannot use the internal clock source.\r\n\n");
   \                     ??atc_2:
   \   0000004C   0x....             LDR.N    R0,??DataTable15_22
   \   0000004E   0x.... 0x....      BL       printf
    581                    return 1; //error using IRC as system clock
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE115             B.N      ??atc_4
    582                  }
    583                        
    584                  if ((clks_val == 0) && (!(MCG_C6 & MCG_C6_PLLS_MASK)) && (MCG_C1 & MCG_C1_IREFS_MASK))
   \                     ??atc_3:
   \   00000056   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000005E   0xD10C             BNE.N    ??atc_5
   \   00000060   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40064005
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x0640             LSLS     R0,R0,#+25
   \   00000066   0xD408             BMI.N    ??atc_5
   \   00000068   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40064000
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x0740             LSLS     R0,R0,#+29
   \   0000006E   0xD504             BPL.N    ??atc_5
    585                  {
    586                    printf("\nAuto trim error - cannot use the FLL with internal clock source.\r\n\n");
   \   00000070   0x....             LDR.N    R0,??DataTable15_23
   \   00000072   0x.... 0x....      BL       printf
    587                    return 2; // error using FLL with IRC
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0xE103             B.N      ??atc_4
    588                  }
    589                  if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 3)
   \                     ??atc_5:
   \   0000007A   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40064006
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD002             BEQ.N    ??atc_6
    590                  {
    591                    printf("\nWARNING - PLL is not the internal clock source. Auto trim value will not be correct\r\n\n");
   \   00000088   0x....             LDR.N    R0,??DataTable15_24
   \   0000008A   0x.... 0x....      BL       printf
    592                  }
    593                          
    594                  if(!irc) //determine if slow or fast IRC to be trimmed
   \                     ??atc_6:
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD111             BNE.N    ??atc_7
    595                  {
    596                    if (irc_freq < 31250) // check frequency is above min spec.
   \   00000094   0xF647 0x2012      MOVW     R0,#+31250
   \   00000098   0x4285             CMP      R5,R0
   \   0000009A   0xDA04             BGE.N    ??atc_8
    597                    {
    598                      printf("\nAuto trim error - target frequency is below 31250 Hz.\r\n\n");
   \   0000009C   0x....             LDR.N    R0,??DataTable15_25
   \   0000009E   0x.... 0x....      BL       printf
    599                      return 3;
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0xE0ED             B.N      ??atc_4
    600                    }
    601                    if (irc_freq > 39062) // check frequency is below max spec.
   \                     ??atc_8:
   \   000000A6   0xF649 0x0097      MOVW     R0,#+39063
   \   000000AA   0x4285             CMP      R5,R0
   \   000000AC   0xDB14             BLT.N    ??atc_9
    602                    {
    603                      printf("\nAuto trim error - target frequency is above 39062 Hz.\r\n\n");
   \   000000AE   0x....             LDR.N    R0,??DataTable15_26
   \   000000B0   0x.... 0x....      BL       printf
    604                      return 4;
   \   000000B4   0x2004             MOVS     R0,#+4
   \   000000B6   0xE0E4             B.N      ??atc_4
    605                    }         
    606                  }
    607                  else
    608                  {
    609                    if (irc_freq < 3000000) // check frequency is above min spec.
   \                     ??atc_7:
   \   000000B8   0x....             LDR.N    R0,??DataTable15_27  ;; 0x2dc6c0
   \   000000BA   0x4285             CMP      R5,R0
   \   000000BC   0xDA04             BGE.N    ??atc_10
    610                    {
    611                      printf("\nAuto trim error - target frequency is below 3 MHz.\r\n\n");
   \   000000BE   0x....             LDR.N    R0,??DataTable15_28
   \   000000C0   0x.... 0x....      BL       printf
    612                      return 5;
   \   000000C4   0x2005             MOVS     R0,#+5
   \   000000C6   0xE0DC             B.N      ??atc_4
    613                    }
    614                    if (irc_freq > 5000000) // check frequency is below max spec.
   \                     ??atc_10:
   \   000000C8   0x....             LDR.N    R0,??DataTable15_29  ;; 0x4c4b41
   \   000000CA   0x4285             CMP      R5,R0
   \   000000CC   0xDB04             BLT.N    ??atc_9
    615                    {
    616                      printf("\nAuto trim error - target frequency is above 5 MHz.\r\n\n");
   \   000000CE   0x....             LDR.N    R0,??DataTable15_30
   \   000000D0   0x.... 0x....      BL       printf
    617                      return 6;
   \   000000D4   0x2006             MOVS     R0,#+6
   \   000000D6   0xE0D4             B.N      ??atc_4
    618                    }            
    619                  } // if
    620                  for (i=0;i<0xffff;i++);
   \                     ??atc_9:
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x4683             MOV      R11,R0
   \                     ??atc_11:
   \   000000DC   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000E0   0x4583             CMP      R11,R0
   \   000000E2   0xD202             BCS.N    ??atc_12
   \   000000E4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000E8   0xE7F8             B.N      ??atc_11
    621                  orig_SIM_CLKDIV1 = SIM_CLKDIV1;        // backup current divider value
   \                     ??atc_12:
   \   000000EA   0x....             LDR.N    R0,??DataTable15_10  ;; 0x40048044
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x4680             MOV      R8,R0
    622                  temp_reg = SIM_CLKDIV1;                // bus clock needs to be between 8 and 16 MHz
   \   000000F0   0x....             LDR.N    R0,??DataTable15_10  ;; 0x40048044
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x0006             MOVS     R6,R0
    623                  temp_reg &= ~SIM_CLKDIV1_OUTDIV2_MASK; // clear bus divider field
   \   000000F6   0xF036 0x6670      BICS     R6,R6,#0xF000000
    624                  temp_reg |= SIM_CLKDIV1_OUTDIV2(5);    //divide 96MHz PLL by 6 = 16MHz bus clock
   \   000000FA   0xF056 0x66A0      ORRS     R6,R6,#0x5000000
    625                  SIM_CLKDIV1 = temp_reg; 
   \   000000FE   0x....             LDR.N    R0,??DataTable15_10  ;; 0x40048044
   \   00000100   0x6006             STR      R6,[R0, #+0]
    626          // Set up autocal registers, must use floating point calculation
    627                  if (irc)
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x2C00             CMP      R4,#+0
   \   00000106   0xD011             BEQ.N    ??atc_13
    628                    atcv = (unsigned short)(128.0f * (21.0f * (16000000.0f / (float)irc_freq))); 
   \   00000108   0x0028             MOVS     R0,R5
   \   0000010A   0x.... 0x....      BL       __aeabi_i2f
   \   0000010E   0x0001             MOVS     R1,R0
   \   00000110   0x....             LDR.N    R0,??DataTable15_31  ;; 0x4b742400
   \   00000112   0x.... 0x....      BL       __aeabi_fdiv
   \   00000116   0x....             LDR.N    R1,??DataTable15_32  ;; 0x41a80000
   \   00000118   0x.... 0x....      BL       __aeabi_fmul
   \   0000011C   0xF05F 0x4186      MOVS     R1,#+1124073472
   \   00000120   0x.... 0x....      BL       __aeabi_fmul
   \   00000124   0x.... 0x....      BL       __aeabi_f2iz
   \   00000128   0x4681             MOV      R9,R0
   \   0000012A   0xE00C             B.N      ??atc_14
    629                  else
    630                    atcv = (unsigned short)(21.0f * (16000000.0f / (float)irc_freq));
   \                     ??atc_13:
   \   0000012C   0x0028             MOVS     R0,R5
   \   0000012E   0x.... 0x....      BL       __aeabi_i2f
   \   00000132   0x0001             MOVS     R1,R0
   \   00000134   0x....             LDR.N    R0,??DataTable15_31  ;; 0x4b742400
   \   00000136   0x.... 0x....      BL       __aeabi_fdiv
   \   0000013A   0x....             LDR.N    R1,??DataTable15_32  ;; 0x41a80000
   \   0000013C   0x.... 0x....      BL       __aeabi_fmul
   \   00000140   0x.... 0x....      BL       __aeabi_f2iz
   \   00000144   0x4681             MOV      R9,R0
    631                  
    632                  MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
   \                     ??atc_14:
   \   00000146   0x....             LDR.N    R0,??DataTable15_33  ;; 0x4006400b
   \   00000148   0xF880 0x9000      STRB     R9,[R0, #+0]
    633                  MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
   \   0000014C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000150   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   00000154   0x....             LDR.N    R1,??DataTable15_34  ;; 0x4006400a
   \   00000156   0x7008             STRB     R0,[R1, #+0]
    634          
    635          // Enable autocal
    636                  MCG_ATC = 0x0; // clear auto trim control register
   \   00000158   0x....             LDR.N    R0,??DataTable15_35  ;; 0x40064008
   \   0000015A   0x2100             MOVS     R1,#+0
   \   0000015C   0x7001             STRB     R1,[R0, #+0]
    637                  temp_reg8 |= (MCG_ATC_ATME_MASK | (irc << MCG_ATC_ATMS_SHIFT)); //Select IRC to trim and enable trim machine
   \   0000015E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000160   0x01A0             LSLS     R0,R4,#+6
   \   00000162   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000166   0x4307             ORRS     R7,R0,R7
    638                  MCG_ATC = temp_reg8;
   \   00000168   0x....             LDR.N    R0,??DataTable15_35  ;; 0x40064008
   \   0000016A   0x7007             STRB     R7,[R0, #+0]
    639                  
    640                  while (MCG_ATC & MCG_ATC_ATME_MASK) {}; //poll for ATME bit to clear
   \                     ??atc_15:
   \   0000016C   0x....             LDR.N    R0,??DataTable15_35  ;; 0x40064008
   \   0000016E   0x7800             LDRB     R0,[R0, #+0]
   \   00000170   0x0600             LSLS     R0,R0,#+24
   \   00000172   0xD4FB             BMI.N    ??atc_15
    641                  
    642                  SIM_CLKDIV1 = orig_SIM_CLKDIV1; //restore the divider value
   \   00000174   0x....             LDR.N    R0,??DataTable15_10  ;; 0x40048044
   \   00000176   0xF8C0 0x8000      STR      R8,[R0, #+0]
    643                  
    644                  if (MCG_ATC & MCG_ATC_ATMF_MASK) // check if error flag set
   \   0000017A   0x....             LDR.N    R0,??DataTable15_35  ;; 0x40064008
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0x0680             LSLS     R0,R0,#+26
   \   00000180   0xD549             BPL.N    ??atc_16
    645                  {
    646                    printf("Autotrim error.\r\n\n");
   \   00000182   0x....             LDR.N    R0,??DataTable15_36
   \   00000184   0x.... 0x....      BL       printf
    647                    printf("\n");
   \   00000188   0xA03F             ADR.N    R0,??atc_0       ;; "\n"
   \   0000018A   0x.... 0x....      BL       printf
    648                    printf("MCG_C1   = %#02X \r\n", (MCG_C1));
   \   0000018E   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40064000
   \   00000190   0x7801             LDRB     R1,[R0, #+0]
   \   00000192   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000194   0x....             LDR.N    R0,??DataTable15_37
   \   00000196   0x.... 0x....      BL       printf
    649                    printf("MCG_C2   = %#02X \r\n", (MCG_C2));
   \   0000019A   0x....             LDR.N    R0,??DataTable15  ;; 0x40064001
   \   0000019C   0x7801             LDRB     R1,[R0, #+0]
   \   0000019E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A0   0x....             LDR.N    R0,??DataTable15_38
   \   000001A2   0x.... 0x....      BL       printf
    650                    printf("MCG_C3   = %#02X \r\n", (MCG_C3));
   \   000001A6   0x....             LDR.N    R0,??DataTable15_39  ;; 0x40064002
   \   000001A8   0x7801             LDRB     R1,[R0, #+0]
   \   000001AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001AC   0x....             LDR.N    R0,??DataTable15_40
   \   000001AE   0x.... 0x....      BL       printf
    651                    printf("MCG_C4   = %#02X \r\n", (MCG_C4)) ;
   \   000001B2   0x....             LDR.N    R0,??DataTable15_7  ;; 0x40064003
   \   000001B4   0x7801             LDRB     R1,[R0, #+0]
   \   000001B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001B8   0x....             LDR.N    R0,??DataTable15_41
   \   000001BA   0x.... 0x....      BL       printf
    652                    printf("MCG_C5   = %#02X \r\n", (MCG_C5));
   \   000001BE   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40064004
   \   000001C0   0x7801             LDRB     R1,[R0, #+0]
   \   000001C2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001C4   0x....             LDR.N    R0,??DataTable15_42
   \   000001C6   0x.... 0x....      BL       printf
    653                    printf("MCG_C6   = %#02X \r\n\n", (MCG_C6));
   \   000001CA   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40064005
   \   000001CC   0x7801             LDRB     R1,[R0, #+0]
   \   000001CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D0   0x....             LDR.N    R0,??DataTable15_43
   \   000001D2   0x.... 0x....      BL       printf
    654                    printf("MCG_S    = %#02X \r\n\n", (MCG_S)) ;
   \   000001D6   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40064006
   \   000001D8   0x7801             LDRB     R1,[R0, #+0]
   \   000001DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001DC   0x....             LDR.N    R0,??DataTable15_44
   \   000001DE   0x.... 0x....      BL       printf
    655                    printf("MCG_ATC   = %#02X \r\n",   (MCG_ATC)) ;
   \   000001E2   0x....             LDR.N    R0,??DataTable15_35  ;; 0x40064008
   \   000001E4   0x7801             LDRB     R1,[R0, #+0]
   \   000001E6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E8   0x....             LDR.N    R0,??DataTable15_45
   \   000001EA   0x.... 0x....      BL       printf
    656                    printf("MCG_ATCVL = %#02X \r\n",   (MCG_ATCVL)) ;
   \   000001EE   0x....             LDR.N    R0,??DataTable15_33  ;; 0x4006400b
   \   000001F0   0x7801             LDRB     R1,[R0, #+0]
   \   000001F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F4   0x....             LDR.N    R0,??DataTable15_46
   \   000001F6   0x.... 0x....      BL       printf
    657                    printf("MCG_ATVCH = %#02X \r\n",   (MCG_ATCVH));
   \   000001FA   0x....             LDR.N    R0,??DataTable15_34  ;; 0x4006400a
   \   000001FC   0x7801             LDRB     R1,[R0, #+0]
   \   000001FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000200   0x....             LDR.N    R0,??DataTable15_47
   \   00000202   0x.... 0x....      BL       printf
    658                    MCG_ATC |= MCG_ATC_ATMF_MASK; // clear fail flag
   \   00000206   0x....             LDR.N    R0,??DataTable15_35  ;; 0x40064008
   \   00000208   0x7800             LDRB     R0,[R0, #+0]
   \   0000020A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000020E   0x....             LDR.N    R1,??DataTable15_35  ;; 0x40064008
   \   00000210   0x7008             STRB     R0,[R1, #+0]
    659                    return 7;
   \   00000212   0x2007             MOVS     R0,#+7
   \   00000214   0xE035             B.N      ??atc_4
    660                  } 
    661                  else 
    662                  {      
    663                    printf("Autotrim Passed.\r\n\n");
   \                     ??atc_16:
   \   00000216   0x....             LDR.N    R0,??DataTable15_48
   \   00000218   0x.... 0x....      BL       printf
    664                    printf("MCG_C3   = %#02X \r\n", (MCG_C3));
   \   0000021C   0x....             LDR.N    R0,??DataTable15_39  ;; 0x40064002
   \   0000021E   0x7801             LDRB     R1,[R0, #+0]
   \   00000220   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000222   0x....             LDR.N    R0,??DataTable15_40
   \   00000224   0x.... 0x....      BL       printf
    665                    printf("MCG_C4   = %#02X \r\n", (MCG_C4));
   \   00000228   0x....             LDR.N    R0,??DataTable15_7  ;; 0x40064003
   \   0000022A   0x7801             LDRB     R1,[R0, #+0]
   \   0000022C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000022E   0x....             LDR.N    R0,??DataTable15_41
   \   00000230   0x.... 0x....      BL       printf
    666                    // Check trim value is not at either extreme of the range
    667                    if (!irc)
   \   00000234   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000236   0x2C00             CMP      R4,#+0
   \   00000238   0xD10E             BNE.N    ??atc_17
    668                    {
    669                      if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
   \   0000023A   0x....             LDR.N    R0,??DataTable15_39  ;; 0x40064002
   \   0000023C   0x7800             LDRB     R0,[R0, #+0]
   \   0000023E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000240   0x28FF             CMP      R0,#+255
   \   00000242   0xD004             BEQ.N    ??atc_18
   \   00000244   0x....             LDR.N    R0,??DataTable15_39  ;; 0x40064002
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024A   0x2800             CMP      R0,#+0
   \   0000024C   0xD117             BNE.N    ??atc_19
    670                      {
    671                        printf("\nAutotrim result is not valid.\r\n\n");
   \                     ??atc_18:
   \   0000024E   0x....             LDR.N    R0,??DataTable15_49
   \   00000250   0x.... 0x....      BL       printf
    672                        return 8;
   \   00000254   0x2008             MOVS     R0,#+8
   \   00000256   0xE014             B.N      ??atc_4
    673                      }
    674                    }
    675                    else
    676                    {
    677                      if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
    678                        (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
   \                     ??atc_17:
   \   00000258   0x....             LDR.N    R0,??DataTable15_7  ;; 0x40064003
   \   0000025A   0x7800             LDRB     R0,[R0, #+0]
   \   0000025C   0xF3C0 0x0043      UBFX     R0,R0,#+1,#+4
   \   00000260   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000262   0x280F             CMP      R0,#+15
   \   00000264   0xD006             BEQ.N    ??atc_20
   \   00000266   0x....             LDR.N    R0,??DataTable15_7  ;; 0x40064003
   \   00000268   0x7800             LDRB     R0,[R0, #+0]
   \   0000026A   0xF3C0 0x0043      UBFX     R0,R0,#+1,#+4
   \   0000026E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000270   0x2800             CMP      R0,#+0
   \   00000272   0xD104             BNE.N    ??atc_19
    679                      {
    680                        printf("\nAutotrim result is not valid.\r\n\n");
   \                     ??atc_20:
   \   00000274   0x....             LDR.N    R0,??DataTable15_49
   \   00000276   0x.... 0x....      BL       printf
    681                        return 8;
   \   0000027A   0x2008             MOVS     R0,#+8
   \   0000027C   0xE001             B.N      ??atc_4
    682                      }
    683                    }
    684                  }
    685                    
    686              }// end else
    687              return irc;
   \                     ??atc_19:
   \   0000027E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000280   0x0020             MOVS     R0,R4
   \                     ??atc_4:
   \   00000282   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   00000286   0xBF00             Nop      
   \                     ??atc_0:
   \   00000288   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    
    688          }// end atc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x4007C008         DC32     0x4007c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     core_clk_mhz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     periph_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x00017700         DC32     0x17700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x4003D010         DC32     0x4003d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x........         DC32     drs_val

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0x........         DC32     dmx32_val

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0x........         DC32     slow_irc_freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   0x........         DC32     `?<Constant "\\n--------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   0x........         DC32     `?<Constant "  MCG AutoTrim Utility\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   0x........         DC32     `?<Constant "---------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   0x........         DC32     `?<Constant "\\nAuto trim error - ca...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   0x........         DC32     `?<Constant "\\nAuto trim error - ca...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   0x........         DC32     `?<Constant "\\nWARNING - PLL is not...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   0x........         DC32     `?<Constant "\\nAuto trim error - ta...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_26:
   \   00000000   0x........         DC32     `?<Constant "\\nAuto trim error - ta...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_27:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_28:
   \   00000000   0x........         DC32     `?<Constant "\\nAuto trim error - ta...">_2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_29:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_30:
   \   00000000   0x........         DC32     `?<Constant "\\nAuto trim error - ta...">_3`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_31:
   \   00000000   0x4B742400         DC32     0x4b742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_32:
   \   00000000   0x41A80000         DC32     0x41a80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_33:
   \   00000000   0x4006400B         DC32     0x4006400b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_34:
   \   00000000   0x4006400A         DC32     0x4006400a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_35:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_36:
   \   00000000   0x........         DC32     `?<Constant "Autotrim error.\\r\\n\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_37:
   \   00000000   0x........         DC32     `?<Constant "MCG_C1   = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_38:
   \   00000000   0x........         DC32     `?<Constant "MCG_C2   = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_39:
   \   00000000   0x40064002         DC32     0x40064002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_40:
   \   00000000   0x........         DC32     `?<Constant "MCG_C3   = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_41:
   \   00000000   0x........         DC32     `?<Constant "MCG_C4   = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_42:
   \   00000000   0x........         DC32     `?<Constant "MCG_C5   = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_43:
   \   00000000   0x........         DC32     `?<Constant "MCG_C6   = %#02X \\r\\n\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_44:
   \   00000000   0x........         DC32     `?<Constant "MCG_S    = %#02X \\r\\n\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_45:
   \   00000000   0x........         DC32     `?<Constant "MCG_ATC   = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_46:
   \   00000000   0x........         DC32     `?<Constant "MCG_ATCVL = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_47:
   \   00000000   0x........         DC32     `?<Constant "MCG_ATVCH = %#02X \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_48:
   \   00000000   0x........         DC32     `?<Constant "Autotrim Passed.\\r\\n\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_49:
   \   00000000   0x........         DC32     `?<Constant "\\nAutotrim result is n...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n--------------------...">`:
   \   00000000   0x0A 0x2D          DC8 "\012-------------------------------------------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x0A 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "  MCG AutoTrim Utility\\n">`:
   \   00000000   0x20 0x20          DC8 "  MCG AutoTrim Utility\012"
   \              0x4D 0x43    
   \              0x47 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x54 0x72    
   \              0x69 0x6D    
   \              0x20 0x55    
   \              0x74 0x69    
   \              0x6C 0x69    
   \              0x74 0x79    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "---------------------...">`:
   \   00000000   0x2D 0x2D          DC8 "-------------------------------------------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAuto trim error - ca...">`:
   \   00000000   0x0A 0x41          DC8 0AH, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 20H, 65H, 72H, 72H, 6FH, 72H
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \   00000010   0x20 0x2D          DC8 20H, 2DH, 20H, 63H, 61H, 6EH, 6EH, 6FH
   \              0x20 0x63    
   \              0x61 0x6E    
   \              0x6E 0x6F    
   \   00000018   0x74 0x20          DC8 74H, 20H, 75H, 73H, 65H, 20H, 74H, 68H
   \              0x75 0x73    
   \              0x65 0x20    
   \              0x74 0x68    
   \   00000020   0x65 0x20          DC8 65H, 20H, 69H, 6EH, 74H, 65H, 72H, 6EH
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x6E    
   \   00000028   0x61 0x6C          DC8 61H, 6CH, 20H, 63H, 6CH, 6FH, 63H, 6BH
   \              0x20 0x63    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000030   0x20 0x73          DC8 20H, 73H, 6FH, 75H, 72H, 63H, 65H, 2EH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x2E    
   \   00000038   0x0D 0x0A          DC8 0DH, 0AH, 0AH, 0
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAuto trim error - ca...">_1`:
   \   00000000   0x0A 0x41          DC8 0AH, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 20H, 65H, 72H, 72H, 6FH, 72H
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \   00000010   0x20 0x2D          DC8 20H, 2DH, 20H, 63H, 61H, 6EH, 6EH, 6FH
   \              0x20 0x63    
   \              0x61 0x6E    
   \              0x6E 0x6F    
   \   00000018   0x74 0x20          DC8 74H, 20H, 75H, 73H, 65H, 20H, 74H, 68H
   \              0x75 0x73    
   \              0x65 0x20    
   \              0x74 0x68    
   \   00000020   0x65 0x20          DC8 65H, 20H, 46H, 4CH, 4CH, 20H, 77H, 69H
   \              0x46 0x4C    
   \              0x4C 0x20    
   \              0x77 0x69    
   \   00000028   0x74 0x68          DC8 74H, 68H, 20H, 69H, 6EH, 74H, 65H, 72H
   \              0x20 0x69    
   \              0x6E 0x74    
   \              0x65 0x72    
   \   00000030   0x6E 0x61          DC8 6EH, 61H, 6CH, 20H, 63H, 6CH, 6FH, 63H
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \   00000038   0x6B 0x20          DC8 6BH, 20H, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000040   0x2E 0x0D          DC8 2EH, 0DH, 0AH, 0AH, 0
   \              0x0A 0x0A    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nWARNING - PLL is not...">`:
   \   00000000   0x0A 0x57          DC8 0AH, 57H, 41H, 52H, 4EH, 49H, 4EH, 47H
   \              0x41 0x52    
   \              0x4E 0x49    
   \              0x4E 0x47    
   \   00000008   0x20 0x2D          DC8 20H, 2DH, 20H, 50H, 4CH, 4CH, 20H, 69H
   \              0x20 0x50    
   \              0x4C 0x4C    
   \              0x20 0x69    
   \   00000010   0x73 0x20          DC8 73H, 20H, 6EH, 6FH, 74H, 20H, 74H, 68H
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x74 0x68    
   \   00000018   0x65 0x20          DC8 65H, 20H, 69H, 6EH, 74H, 65H, 72H, 6EH
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x6E    
   \   00000020   0x61 0x6C          DC8 61H, 6CH, 20H, 63H, 6CH, 6FH, 63H, 6BH
   \              0x20 0x63    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000028   0x20 0x73          DC8 20H, 73H, 6FH, 75H, 72H, 63H, 65H, 2EH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x2E    
   \   00000030   0x20 0x41          DC8 20H, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000038   0x69 0x6D          DC8 69H, 6DH, 20H, 76H, 61H, 6CH, 75H, 65H
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \   00000040   0x20 0x77          DC8 20H, 77H, 69H, 6CH, 6CH, 20H, 6EH, 6FH
   \              0x69 0x6C    
   \              0x6C 0x20    
   \              0x6E 0x6F    
   \   00000048   0x74 0x20          DC8 74H, 20H, 62H, 65H, 20H, 63H, 6FH, 72H
   \              0x62 0x65    
   \              0x20 0x63    
   \              0x6F 0x72    
   \   00000050   0x72 0x65          DC8 72H, 65H, 63H, 74H, 0DH, 0AH, 0AH, 0
   \              0x63 0x74    
   \              0x0D 0x0A    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAuto trim error - ta...">`:
   \   00000000   0x0A 0x41          DC8 0AH, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 20H, 65H, 72H, 72H, 6FH, 72H
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \   00000010   0x20 0x2D          DC8 20H, 2DH, 20H, 74H, 61H, 72H, 67H, 65H
   \              0x20 0x74    
   \              0x61 0x72    
   \              0x67 0x65    
   \   00000018   0x74 0x20          DC8 74H, 20H, 66H, 72H, 65H, 71H, 75H, 65H
   \              0x66 0x72    
   \              0x65 0x71    
   \              0x75 0x65    
   \   00000020   0x6E 0x63          DC8 6EH, 63H, 79H, 20H, 69H, 73H, 20H, 62H
   \              0x79 0x20    
   \              0x69 0x73    
   \              0x20 0x62    
   \   00000028   0x65 0x6C          DC8 65H, 6CH, 6FH, 77H, 20H, 33H, 31H, 32H
   \              0x6F 0x77    
   \              0x20 0x33    
   \              0x31 0x32    
   \   00000030   0x35 0x30          DC8 35H, 30H, 20H, 48H, 7AH, 2EH, 0DH, 0AH
   \              0x20 0x48    
   \              0x7A 0x2E    
   \              0x0D 0x0A    
   \   00000038   0x0A 0x00          DC8 0AH, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAuto trim error - ta...">_1`:
   \   00000000   0x0A 0x41          DC8 0AH, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 20H, 65H, 72H, 72H, 6FH, 72H
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \   00000010   0x20 0x2D          DC8 20H, 2DH, 20H, 74H, 61H, 72H, 67H, 65H
   \              0x20 0x74    
   \              0x61 0x72    
   \              0x67 0x65    
   \   00000018   0x74 0x20          DC8 74H, 20H, 66H, 72H, 65H, 71H, 75H, 65H
   \              0x66 0x72    
   \              0x65 0x71    
   \              0x75 0x65    
   \   00000020   0x6E 0x63          DC8 6EH, 63H, 79H, 20H, 69H, 73H, 20H, 61H
   \              0x79 0x20    
   \              0x69 0x73    
   \              0x20 0x61    
   \   00000028   0x62 0x6F          DC8 62H, 6FH, 76H, 65H, 20H, 33H, 39H, 30H
   \              0x76 0x65    
   \              0x20 0x33    
   \              0x39 0x30    
   \   00000030   0x36 0x32          DC8 36H, 32H, 20H, 48H, 7AH, 2EH, 0DH, 0AH
   \              0x20 0x48    
   \              0x7A 0x2E    
   \              0x0D 0x0A    
   \   00000038   0x0A 0x00          DC8 0AH, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAuto trim error - ta...">_2`:
   \   00000000   0x0A 0x41          DC8 0AH, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 20H, 65H, 72H, 72H, 6FH, 72H
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \   00000010   0x20 0x2D          DC8 20H, 2DH, 20H, 74H, 61H, 72H, 67H, 65H
   \              0x20 0x74    
   \              0x61 0x72    
   \              0x67 0x65    
   \   00000018   0x74 0x20          DC8 74H, 20H, 66H, 72H, 65H, 71H, 75H, 65H
   \              0x66 0x72    
   \              0x65 0x71    
   \              0x75 0x65    
   \   00000020   0x6E 0x63          DC8 6EH, 63H, 79H, 20H, 69H, 73H, 20H, 62H
   \              0x79 0x20    
   \              0x69 0x73    
   \              0x20 0x62    
   \   00000028   0x65 0x6C          DC8 65H, 6CH, 6FH, 77H, 20H, 33H, 20H, 4DH
   \              0x6F 0x77    
   \              0x20 0x33    
   \              0x20 0x4D    
   \   00000030   0x48 0x7A          DC8 48H, 7AH, 2EH, 0DH, 0AH, 0AH, 0
   \              0x2E 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   00000037   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAuto trim error - ta...">_3`:
   \   00000000   0x0A 0x41          DC8 0AH, 41H, 75H, 74H, 6FH, 20H, 74H, 72H
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x74 0x72    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 20H, 65H, 72H, 72H, 6FH, 72H
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \   00000010   0x20 0x2D          DC8 20H, 2DH, 20H, 74H, 61H, 72H, 67H, 65H
   \              0x20 0x74    
   \              0x61 0x72    
   \              0x67 0x65    
   \   00000018   0x74 0x20          DC8 74H, 20H, 66H, 72H, 65H, 71H, 75H, 65H
   \              0x66 0x72    
   \              0x65 0x71    
   \              0x75 0x65    
   \   00000020   0x6E 0x63          DC8 6EH, 63H, 79H, 20H, 69H, 73H, 20H, 61H
   \              0x79 0x20    
   \              0x69 0x73    
   \              0x20 0x61    
   \   00000028   0x62 0x6F          DC8 62H, 6FH, 76H, 65H, 20H, 35H, 20H, 4DH
   \              0x76 0x65    
   \              0x20 0x35    
   \              0x20 0x4D    
   \   00000030   0x48 0x7A          DC8 48H, 7AH, 2EH, 0DH, 0AH, 0AH, 0
   \              0x2E 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   00000037   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Autotrim error.\\r\\n\\n">`:
   \   00000000   0x41 0x75          DC8 "Autotrim error.\015\012\012"
   \              0x74 0x6F    
   \              0x74 0x72    
   \              0x69 0x6D    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x2E 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_C1   = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_C1   = %#02X \015\012"
   \              0x47 0x5F    
   \              0x43 0x31    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_C2   = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_C2   = %#02X \015\012"
   \              0x47 0x5F    
   \              0x43 0x32    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_C3   = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_C3   = %#02X \015\012"
   \              0x47 0x5F    
   \              0x43 0x33    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_C4   = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_C4   = %#02X \015\012"
   \              0x47 0x5F    
   \              0x43 0x34    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_C5   = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_C5   = %#02X \015\012"
   \              0x47 0x5F    
   \              0x43 0x35    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_C6   = %#02X \\r\\n\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_C6   = %#02X \015\012\012"
   \              0x47 0x5F    
   \              0x43 0x36    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_S    = %#02X \\r\\n\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_S    = %#02X \015\012\012"
   \              0x47 0x5F    
   \              0x53 0x20    
   \              0x20 0x20    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x23 0x30    
   \              0x32 0x58    
   \              0x20 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_ATC   = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_ATC   = %#02X \015\012"
   \              0x47 0x5F    
   \              0x41 0x54    
   \              0x43 0x20    
   \              0x20 0x20    
   \              0x3D 0x20    
   \              0x25 0x23    
   \              0x30 0x32    
   \              0x58 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_ATCVL = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_ATCVL = %#02X \015\012"
   \              0x47 0x5F    
   \              0x41 0x54    
   \              0x43 0x56    
   \              0x4C 0x20    
   \              0x3D 0x20    
   \              0x25 0x23    
   \              0x30 0x32    
   \              0x58 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "MCG_ATVCH = %#02X \\r\\n">`:
   \   00000000   0x4D 0x43          DC8 "MCG_ATVCH = %#02X \015\012"
   \              0x47 0x5F    
   \              0x41 0x54    
   \              0x56 0x43    
   \              0x48 0x20    
   \              0x3D 0x20    
   \              0x25 0x23    
   \              0x30 0x32    
   \              0x58 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Autotrim Passed.\\r\\n\\n">`:
   \   00000000   0x41 0x75          DC8 "Autotrim Passed.\015\012\012"
   \              0x74 0x6F    
   \              0x74 0x72    
   \              0x69 0x6D    
   \              0x20 0x50    
   \              0x61 0x73    
   \              0x73 0x65    
   \              0x64 0x2E    
   \              0x0D 0x0A    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nAutotrim result is n...">`:
   \   00000000   0x0A 0x41          DC8 "\012Autotrim result is not valid.\015\012\012"
   \              0x75 0x74    
   \              0x6F 0x74    
   \              0x72 0x69    
   \              0x6D 0x20    
   \              0x72 0x65    
   \              0x73 0x75    
   \              0x6C 0x74    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x2E    
   \              0x0D 0x0A    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       40  atc
             40 -> __aeabi_f2iz
             40 -> __aeabi_fdiv
             40 -> __aeabi_fmul
             40 -> __aeabi_i2f
             40 -> printf
        0  fbe_fbi_fast
        0  fbe_fbi_slow
        0  fbe_pbe
        0  fbi_blpi
        8  fee_fei
              8 -> fll_freq
        8  fei_fbe
        0  fll_freq
       16  fll_rtc_init
             16 -> rtc_as_refclk
        8  mcg_blpi_2_pee
              8 -> pll_init
        0  mcg_pbe_2_pee
        0  mcg_pee_2_blpi
        0  pbe_fbe
        4  pbe_pee
        0  pee_pbe
       16  pll_init
             16 -> set_sys_dividers
        8  rtc_as_refclk
              8 -> fll_freq
              8 -> time_delay_ms
       16  set_sys_dividers


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "  MCG AutoTrim Utility\n">
      48  ?<Constant "---------------------...">
      20  ?<Constant "Autotrim Passed.\r\n\n">
      20  ?<Constant "Autotrim error.\r\n\n">
      24  ?<Constant "MCG_ATC   = %#02X \r\n">
      24  ?<Constant "MCG_ATCVL = %#02X \r\n">
      24  ?<Constant "MCG_ATVCH = %#02X \r\n">
      20  ?<Constant "MCG_C1   = %#02X \r\n">
      20  ?<Constant "MCG_C2   = %#02X \r\n">
      20  ?<Constant "MCG_C3   = %#02X \r\n">
      20  ?<Constant "MCG_C4   = %#02X \r\n">
      20  ?<Constant "MCG_C5   = %#02X \r\n">
      24  ?<Constant "MCG_C6   = %#02X \r\n\n">
      24  ?<Constant "MCG_S    = %#02X \r\n\n">
       2  ?<Constant "\n">
      48  ?<Constant "\n--------------------...">
      60  ?<Constant "\nAuto trim error - ca...">
      72  ?<Constant "\nAuto trim error - ca...">_1
      60  ?<Constant "\nAuto trim error - ta...">
      60  ?<Constant "\nAuto trim error - ta...">_1
      56  ?<Constant "\nAuto trim error - ta...">_2
      56  ?<Constant "\nAuto trim error - ta...">_3
      36  ?<Constant "\nAutotrim result is n...">
      88  ?<Constant "\nWARNING - PLL is not...">
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_27
       4  ??DataTable15_28
       4  ??DataTable15_29
       4  ??DataTable15_3
       4  ??DataTable15_30
       4  ??DataTable15_31
       4  ??DataTable15_32
       4  ??DataTable15_33
       4  ??DataTable15_34
       4  ??DataTable15_35
       4  ??DataTable15_36
       4  ??DataTable15_37
       4  ??DataTable15_38
       4  ??DataTable15_39
       4  ??DataTable15_4
       4  ??DataTable15_40
       4  ??DataTable15_41
       4  ??DataTable15_42
       4  ??DataTable15_43
       4  ??DataTable15_44
       4  ??DataTable15_45
       4  ??DataTable15_46
       4  ??DataTable15_47
       4  ??DataTable15_48
       4  ??DataTable15_49
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
     652  atc
       4  fast_irc_freq
      58  fbe_fbi_fast
      54  fbe_fbi_slow
      40  fbe_pbe
      14  fbi_blpi
     148  fee_fei
     210  fei_fbe
     232  fll_freq
      20  fll_rtc_init
     186  mcg_blpi_2_pee
      44  mcg_pbe_2_pee
     198  mcg_pee_2_blpi
      28  pbe_fbe
      88  pbe_pee
      44  pee_pbe
     294  pll_init
     220  rtc_as_refclk
      80  set_sys_dividers
       4  slow_irc_freq

 
     8 bytes in section .data
   870 bytes in section .rodata
 2 730 bytes in section .text
    80 bytes in section .textrw
 
 2 810 bytes of CODE  memory
   870 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
