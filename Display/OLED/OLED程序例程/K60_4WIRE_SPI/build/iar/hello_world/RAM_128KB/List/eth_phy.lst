###############################################################################
#                                                                             #
#                                                       07/May/2014  16:38:58 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\enet\eth_phy.c                        #
#    Command line =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\src\drivers\enet\eth_phy.c -D IAR -D TWR_K60N512  #
#                    -lCN C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\RAM_128KB\List\ -lB    #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\ -o          #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\ --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench 6.0           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\projects\hello #
#                    _world\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kin #
#                    etisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\com #
#                    mon\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\cpu\headers #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\a #
#                    dc16\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kinet #
#                    isK60_Demo_OLED\build\iar\hello_world\..\..\..\src\drive #
#                    rs\enet\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Ki #
#                    netisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\dr #
#                    ivers\pmc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\ #
#                    KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\src\ #
#                    drivers\rtc\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³ #
#                    Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\..\sr #
#                    c\drivers\lptmr\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐ #
#                    òÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\..\. #
#                    .\src\drivers\uart\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\ #
#                    ³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\..\. #
#                    .\..\src\drivers\mcg\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁ #
#                    Ï\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\build\iar\hello_world\.. #
#                    \..\..\src\drivers\wdog\ -I                              #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\platforms\ -I  #
#                    C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\..\..\..\src\drivers\ftm\   #
#                    -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_ #
#                    Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\SPI #
#                    \ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK6 #
#                    0_Demo_OLED\build\iar\hello_world\..\..\..\src\drivers\O #
#                    LED\ -I C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\Kineti #
#                    sK60_Demo_OLED\build\iar\hello_world\..\ -On             #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\List\eth_phy.lst  #
#    Object file  =  C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Dem #
#                    o_OLED\build\iar\hello_world\RAM_128KB\Obj\eth_phy.o     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\me\Desktop\OLED¿Í»§×ÊÁÏ\³ÌÐòÀý³Ì\KinetisK60_Demo_OLED\src\drivers\enet\eth_phy.c
      1          /*!
      2           * \file    eth_phy.c
      3           * \brief   Ethernet Physical Layer Interface Driver
      4           * \version $Revision: 1.3 $
      5           * \author  Michael Norman
      6           * 
      7           * This is a generic driver for all Ethernet PHYs with the basic MII registers
      8           */
      9          
     10          #include "common.h"
     11          #include "eth_phy.h"
     12          #include "mii.h"
     13          
     14          /* Variable to save off auto-negotiate settings */

   \                                 In section .data, align 4
     15          int eth_phy_anar = 0
   \                     eth_phy_anar:
   \   00000000   0x000001E1         DC32 481
     16              | PHY_ANAR_100BTX_FDX
     17              | PHY_ANAR_100BTX
     18              | PHY_ANAR_10BT_FDX
     19              | PHY_ANAR_10BT;
     20          

   \                                 In section .text, align 2, keep-with-next
     21          int
     22          eth_phy_reset(int ch, int phy_addr)
     23          {
   \                     eth_phy_reset:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     24          #if MII_CHECK_TIMEOUT
     25              int timeout; 
     26          #endif
     27              int settings;
     28          
     29              /* Reset the PHY */
     30              if (mii_write(ch, phy_addr, PHY_BMCR, PHY_BMCR_RESET)) 
   \   00000006   0xF44F 0x4300      MOV      R3,#+32768
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       mii_write
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??eth_phy_reset_0
     31                  return 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE00B             B.N      ??eth_phy_reset_1
     32              /* Wait for reset to complete */
     33          #if MII_CHECK_TIMEOUT
     34              for (timeout = 0; timeout < MII_LINK_TIMEOUT; ++timeout)
     35          #endif
     36              while(1)
     37              {
     38                /* Read back the contents of the CTRL register and verify
     39                 * that RESET is not set - this is a sanity check to ensure
     40                 * that we are talking to the PHY correctly. RESET should
     41                 * always be cleared. */
     42                if (!(mii_read(ch, phy_addr, PHY_BMCR, &settings)) && !(settings & PHY_BMCR_RESET))
   \                     ??eth_phy_reset_0:
   \   0000001C   0xAB00             ADD      R3,SP,#+0
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       mii_read
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F7             BNE.N    ??eth_phy_reset_0
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x0400             LSLS     R0,R0,#+16
   \   00000030   0xD4F4             BMI.N    ??eth_phy_reset_0
     43                  break;/*FSL: ready*/
     44              }
     45          #if MII_CHECK_TIMEOUT
     46              if (timeout == MII_LINK_TIMEOUT || (settings & PHY_BMCR_RESET))
     47                  return 1;
     48              else
     49          #endif      
     50                  return 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_reset_1:
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     51          }
     52          
     53          /********************************************************************/
     54          /*!
     55           * \brief   Enable the Ethernet PHY in auto-negotiate mode
     56           * \param   phy_addr    Address of the PHY
     57           * \param   speed       Desired speed (MII_10BASE_T or MII_100BASE_TX)
     58           * \param   duplex      Desired duplex (MII_FDX or MII_HDX)
     59           * \return  0 if successful; non-zero otherwise
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          int
     62          eth_phy_autoneg(int ch, int phy_addr, ENET_SPEED speed, ENET_DUPLEX duplex)
     63          {
   \                     eth_phy_autoneg:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
     64              int timeout, settings;
     65          
     66              /* Reset the PHY */
     67              eth_phy_reset(ch, phy_addr);
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       eth_phy_reset
     68          
     69              /* Set the Auto-Negotiation Advertisement Register */
     70              if (speed == MII_10BASET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD108             BNE.N    ??eth_phy_autoneg_0
     71              {
     72                  settings = (duplex == MII_FDX) 
     73                      ? PHY_ANAR_10BT_FDX | PHY_ANAR_10BT 
     74                      : PHY_ANAR_10BT;
   \   0000001C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001E   0x2F01             CMP      R7,#+1
   \   00000020   0xD102             BNE.N    ??eth_phy_autoneg_1
   \   00000022   0x2061             MOVS     R0,#+97
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0xE00B             B.N      ??eth_phy_autoneg_2
   \                     ??eth_phy_autoneg_1:
   \   00000028   0x2021             MOVS     R0,#+33
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0xE008             B.N      ??eth_phy_autoneg_2
     75              }
     76              else /* (speed == MII_100BASET) */
     77              {
     78                  settings = (duplex == MII_FDX)  
     79                      ? PHY_ANAR_100BTX_FDX   | 
     80                        PHY_ANAR_100BTX       | 
     81                        PHY_ANAR_10BT_FDX     | 
     82                        PHY_ANAR_10BT
     83                      : PHY_ANAR_10BT_FDX     | 
     84                        PHY_ANAR_10BT;
   \                     ??eth_phy_autoneg_0:
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xD103             BNE.N    ??eth_phy_autoneg_3
   \   00000034   0xF240 0x10E1      MOVW     R0,#+481
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0xE001             B.N      ??eth_phy_autoneg_2
   \                     ??eth_phy_autoneg_3:
   \   0000003C   0x2061             MOVS     R0,#+97
   \   0000003E   0x9000             STR      R0,[SP, #+0]
     85              }
     86              
     87              /* Save off the settings we just advertised */
     88              eth_phy_anar = settings;
   \                     ??eth_phy_autoneg_2:
   \   00000040   0x....             LDR.N    R0,??DataTable4_1
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x6001             STR      R1,[R0, #+0]
     89              
     90              if (mii_write(ch, phy_addr, PHY_ANAR, settings))
   \   00000046   0x9B00             LDR      R3,[SP, #+0]
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       mii_write
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD001             BEQ.N    ??eth_phy_autoneg_4
     91                  return 1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xE032             B.N      ??eth_phy_autoneg_5
     92                  
     93              /* Enable Auto-Negotiation */
     94              if (mii_write(ch, phy_addr, PHY_BMCR, PHY_BMCR_AN_ENABLE | PHY_BMCR_AN_RESTART))
   \                     ??eth_phy_autoneg_4:
   \   0000005A   0xF44F 0x5390      MOV      R3,#+4608
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       mii_write
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD001             BEQ.N    ??eth_phy_autoneg_6
     95                  return 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE027             B.N      ??eth_phy_autoneg_5
     96          
     97              /* Wait for auto-negotiation to complete */
     98              for (timeout = 0; timeout < MII_LINK_TIMEOUT; ++timeout)
   \                     ??eth_phy_autoneg_6:
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x4680             MOV      R8,R0
   \                     ??eth_phy_autoneg_7:
   \   00000074   0x....             LDR.N    R0,??DataTable4_2  ;; 0x1ffff
   \   00000076   0x4580             CMP      R8,R0
   \   00000078   0xDA0F             BGE.N    ??eth_phy_autoneg_8
     99              {
    100                  if (mii_read(ch, phy_addr, PHY_BMSR, &settings))
   \   0000007A   0xAB00             ADD      R3,SP,#+0
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       mii_read
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD001             BEQ.N    ??eth_phy_autoneg_9
    101                      return 1;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE018             B.N      ??eth_phy_autoneg_5
    102                  if (settings & PHY_BMSR_AN_COMPLETE)
   \                     ??eth_phy_autoneg_9:
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x0680             LSLS     R0,R0,#+26
   \   00000092   0xD402             BMI.N    ??eth_phy_autoneg_8
    103                      break;
    104              }
   \                     ??eth_phy_autoneg_10:
   \   00000094   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000098   0xE7EC             B.N      ??eth_phy_autoneg_7
    105              /* Read the BMSR one last time */
    106              if (mii_read(ch, phy_addr, PHY_BMSR, &settings))
   \                     ??eth_phy_autoneg_8:
   \   0000009A   0xAB00             ADD      R3,SP,#+0
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0x0029             MOVS     R1,R5
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       mii_read
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD001             BEQ.N    ??eth_phy_autoneg_11
    107                  return 1;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xE008             B.N      ??eth_phy_autoneg_5
    108              if (timeout == MII_LINK_TIMEOUT || !(settings & PHY_BMSR_LINK))
   \                     ??eth_phy_autoneg_11:
   \   000000AE   0x....             LDR.N    R0,??DataTable4_2  ;; 0x1ffff
   \   000000B0   0x4580             CMP      R8,R0
   \   000000B2   0xD002             BEQ.N    ??eth_phy_autoneg_12
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x0740             LSLS     R0,R0,#+29
   \   000000B8   0xD401             BMI.N    ??eth_phy_autoneg_13
    109                  return 1;
   \                     ??eth_phy_autoneg_12:
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0xE000             B.N      ??eth_phy_autoneg_5
    110              else
    111                  return 0;
   \                     ??eth_phy_autoneg_13:
   \   000000BE   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_autoneg_5:
   \   000000C0   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    112          }
    113          /********************************************************************/
    114          /*!
    115           * \brief   Enable the Ethernet PHY in manual mode
    116           * \param   phy_addr    Address of the PHY
    117           * \param   speed       Desired speed (MII_10BASE_T or MII_100BASE_TX)
    118           * \param   duplex      Desired duplex (MII_FDX or MII_HDX)
    119           * \param   loop        Put PHY in loopback mode?
    120           * \return  0 if successful; non-zero otherwise
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          int 
    123          eth_phy_manual(int ch, int phy_addr, ENET_SPEED speed, ENET_DUPLEX duplex, int loop)
    124          {
   \                     eth_phy_manual:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    125              int timeout; 
    126              int settings = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9000             STR      R0,[SP, #+0]
    127            
    128              /* Reset the PHY */
    129                  /* Reset the PHY */
    130              eth_phy_reset(ch, phy_addr);
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       eth_phy_reset
    131              
    132              if (loop)
   \   0000001C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000020   0xD003             BEQ.N    ??eth_phy_manual_0
    133                  settings |= PHY_BMCR_LOOP;
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000028   0x9000             STR      R0,[SP, #+0]
    134              if (duplex == MII_FDX)
   \                     ??eth_phy_manual_0:
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F01             CMP      R7,#+1
   \   0000002E   0xD104             BNE.N    ??eth_phy_manual_1
    135                  settings |= PHY_BMCR_FDX;
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0xF44F 0x7180      MOV      R1,#+256
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x9000             STR      R0,[SP, #+0]
    136              if (speed == MII_100BASET)
   \                     ??eth_phy_manual_1:
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD103             BNE.N    ??eth_phy_manual_2
    137                  settings |= PHY_BMCR_SPEED;
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000046   0x9000             STR      R0,[SP, #+0]
    138          
    139              if (mii_write(ch, phy_addr, PHY_BMCR, settings))
   \                     ??eth_phy_manual_2:
   \   00000048   0x9B00             LDR      R3,[SP, #+0]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x0029             MOVS     R1,R5
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       mii_write
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ.N    ??eth_phy_manual_3
    140                  return 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xE015             B.N      ??eth_phy_manual_4
    141              
    142              /* Wait for link */
    143              for (timeout = 0; timeout < MII_LINK_TIMEOUT; ++timeout)
   \                     ??eth_phy_manual_3:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x4681             MOV      R9,R0
   \                     ??eth_phy_manual_5:
   \   00000060   0x....             LDR.N    R0,??DataTable4_2  ;; 0x1ffff
   \   00000062   0x4581             CMP      R9,R0
   \   00000064   0xDA0F             BGE.N    ??eth_phy_manual_6
    144              {
    145                  if (mii_read(ch, phy_addr, PHY_BMSR, &settings))
   \   00000066   0xAB00             ADD      R3,SP,#+0
   \   00000068   0x2201             MOVS     R2,#+1
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       mii_read
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD001             BEQ.N    ??eth_phy_manual_7
    146                      return 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE006             B.N      ??eth_phy_manual_4
    147                  if (settings & PHY_BMSR_LINK)
   \                     ??eth_phy_manual_7:
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x0740             LSLS     R0,R0,#+29
   \   0000007E   0xD402             BMI.N    ??eth_phy_manual_6
    148                      break;
    149              }
   \                     ??eth_phy_manual_8:
   \   00000080   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000084   0xE7EC             B.N      ??eth_phy_manual_5
    150          
    151          #if MII_CHECK_TIMEOUT    
    152              if (timeout == MII_LINK_TIMEOUT || !(settings & PHY_BMSR_LINK))
    153                  return 1;
    154              else
    155          #endif      
    156                  return 0;
   \                     ??eth_phy_manual_6:
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_manual_4:
   \   00000088   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    157          }
    158          /********************************************************************/
    159          /*!
    160           * \brief   Get the auto-negotiated speed
    161           * \param   phy_addr    Address of the PHY
    162           * \param   speed       Pointer where speed data is stored
    163           * \return  0 if successful; non-zero otherwise
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          int 
    166          eth_phy_get_speed(int ch, int phy_addr, int *speed)
    167          {
   \                     eth_phy_get_speed:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    168          #if MII_CHECK_TIMEOUT
    169              int timeout;
    170          #endif
    171              int settings = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    172          
    173              /* Get Link Partner settings */
    174          #if MII_CHECK_TIMEOUT
    175              for (timeout = 0; timeout < MII_TIMEOUT; ++timeout)
    176          #endif
    177              while(1)
    178              {      
    179                  if (mii_read(ch, phy_addr, PHY_ANLPAR, &settings))
   \   0000000E   0xAB00             ADD      R3,SP,#+0
   \   00000010   0x2205             MOVS     R2,#+5
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       mii_read
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??eth_phy_get_speed_0
    180                      return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE00F             B.N      ??eth_phy_get_speed_1
    181                  else
    182                      break;
    183              }
    184          #if MII_CHECK_TIMEOUT
    185              if (timeout == MII_TIMEOUT)
    186                  return 1;
    187          #endif
    188              
    189              settings &= eth_phy_anar;
   \                     ??eth_phy_get_speed_0:
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable4_1
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x4008             ANDS     R0,R1,R0
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    190              if (settings & PHY_ANLPAR_100BT4     ||
    191                  settings & PHY_ANLPAR_100BTX_FDX ||
    192                  settings & PHY_ANLPAR_100BTX)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0xF44F 0x7160      MOV      R1,#+896
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD002             BEQ.N    ??eth_phy_get_speed_2
    193                  *speed = MII_100BASET;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x6030             STR      R0,[R6, #+0]
   \   0000003A   0xE001             B.N      ??eth_phy_get_speed_3
    194              else
    195                  *speed = MII_10BASET;
   \                     ??eth_phy_get_speed_2:
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6030             STR      R0,[R6, #+0]
    196          
    197              return 0;
   \                     ??eth_phy_get_speed_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_get_speed_1:
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    198          }
    199          /********************************************************************/
    200          /*!
    201           * \brief   Get the auto-negotiated duplex
    202           * \param   phy_addr    Address of the PHY
    203           * \param   speed       Pointer where speed data is stored
    204           * \return  0 if successful; non-zero otherwise
    205           */

   \                                 In section .text, align 2, keep-with-next
    206          int 
    207          eth_phy_get_duplex(int ch, int phy_addr, int *speed)
    208          {
   \                     eth_phy_get_duplex:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    209          #if MII_CHECK_TIMEOUT  
    210              int timeout;
    211          #endif    
    212              int settings = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    213          
    214              /* Get Link Partner settings */
    215          #if MII_CHECK_TIMEOUT
    216              for (timeout = 0; timeout < MII_TIMEOUT; ++timeout)
    217          #endif
    218              while(1)
    219              {
    220                  if (mii_read(ch, phy_addr, PHY_ANLPAR, &settings))
   \   0000000E   0xAB00             ADD      R3,SP,#+0
   \   00000010   0x2205             MOVS     R2,#+5
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       mii_read
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??eth_phy_get_duplex_0
    221                      return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE00F             B.N      ??eth_phy_get_duplex_1
    222                  else
    223                      break;
    224              }
    225          #if MII_CHECK_TIMEOUT
    226              if (timeout == MII_TIMEOUT)
    227                  return 1;
    228          #endif
    229              
    230              settings &= eth_phy_anar;
   \                     ??eth_phy_get_duplex_0:
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable4_1
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x4008             ANDS     R0,R1,R0
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    231              if (settings & PHY_ANLPAR_100BTX_FDX ||
    232                  settings & PHY_ANLPAR_10BTX_FDX)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0xF44F 0x71A0      MOV      R1,#+320
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD002             BEQ.N    ??eth_phy_get_duplex_2
    233                  *speed = MII_FDX;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x6030             STR      R0,[R6, #+0]
   \   0000003A   0xE001             B.N      ??eth_phy_get_duplex_3
    234              else
    235                  *speed = MII_HDX;
   \                     ??eth_phy_get_duplex_2:
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6030             STR      R0,[R6, #+0]
    236          
    237              return 0;
   \                     ??eth_phy_get_duplex_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_get_duplex_1:
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    238          }
    239          
    240          
    241          /********************************************************************/
    242          /*!
    243           * \brief   Get the manual speed
    244           * \param   phy_addr    Address of the PHY
    245           * \param   speed       Pointer where speed data is stored
    246           * \return  0 if successful; non-zero otherwise
    247           */

   \                                 In section .text, align 2, keep-with-next
    248          int 
    249          eth_phy_get_manual_speed(int ch, int phy_addr, int *speed)
    250          {
   \                     eth_phy_get_manual_speed:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    251          #if MII_CHECK_TIMEOUT
    252              int timeout;
    253          #endif
    254              int settings = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    255          
    256              /* Get Link Partner settings */
    257          #if MII_CHECK_TIMEOUT
    258              for (timeout = 0; timeout < MII_TIMEOUT; ++timeout)
    259          #endif
    260              while(1)
    261              {      
    262          #ifdef TWR_K60N512 
    263                  if (mii_read(ch, phy_addr, PHY_PHYCTRL2, &settings))//Micrel
   \   0000000E   0xAB00             ADD      R3,SP,#+0
   \   00000010   0x221F             MOVS     R2,#+31
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       mii_read
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??eth_phy_get_manual_speed_0
    264          #else
    265                  if (mii_read(ch, phy_addr, PHY_PHYSTS, &settings))//National Semiconductors
    266          #endif
    267                      return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE00F             B.N      ??eth_phy_get_manual_speed_1
    268                  else
    269                      break;
    270              }
    271          #if MII_CHECK_TIMEOUT
    272              if (timeout == MII_TIMEOUT)
    273                  return 1;
    274          #endif
    275          
    276          #ifdef TWR_K60N512
    277              /*FSL: obtain speed/duplex*/
    278              settings = (settings & PHY_PHYCTRL2_OP_MOD_MASK)>>PHY_PHYCTRL2_OP_MOD_SHIFT;
   \                     ??eth_phy_get_manual_speed_0:
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF3C0 0x0082      UBFX     R0,R0,#+2,#+3
   \   00000028   0x9000             STR      R0,[SP, #+0]
    279              
    280              if (settings == PHY_PHYCTRL2_MODE_OP_MOD_10MBPS_HD     ||
    281                  settings == PHY_PHYCTRL2_MODE_OP_MOD_10MBPS_FD)
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD002             BEQ.N    ??eth_phy_get_manual_speed_2
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x2805             CMP      R0,#+5
   \   00000034   0xD102             BNE.N    ??eth_phy_get_manual_speed_3
    282                  *speed = MII_10BASET;
   \                     ??eth_phy_get_manual_speed_2:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6030             STR      R0,[R6, #+0]
   \   0000003A   0xE001             B.N      ??eth_phy_get_manual_speed_4
    283              else
    284                  *speed = MII_100BASET;
   \                     ??eth_phy_get_manual_speed_3:
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x6030             STR      R0,[R6, #+0]
    285          #else
    286              if (settings & PHY_PHYSTS_SPEEDSTATUS)
    287                  *speed = MII_10BASET;
    288              else
    289                  *speed = MII_100BASET;    
    290          #endif
    291              
    292              return 0;
   \                     ??eth_phy_get_manual_speed_4:
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_get_manual_speed_1:
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    293          }
    294          /********************************************************************/
    295          /*!
    296           * \brief   Get the manual duplex
    297           * \param   phy_addr    Address of the PHY
    298           * \param   duplex       Pointer where duplex data is stored
    299           * \return  0 if successful; non-zero otherwise
    300           */

   \                                 In section .text, align 2, keep-with-next
    301          int 
    302          eth_phy_get_manual_duplex(int ch, int phy_addr, int *duplex)
    303          {
   \                     eth_phy_get_manual_duplex:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    304          #if MII_CHECK_TIMEOUT  
    305              int timeout;
    306          #endif    
    307              int settings = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    308          
    309              /* Get Link Partner settings */
    310          #if MII_CHECK_TIMEOUT
    311              for (timeout = 0; timeout < MII_TIMEOUT; ++timeout)
    312          #endif
    313              while(1)
    314              {
    315          #ifdef TWR_K60N512 
    316                  if (mii_read(ch, phy_addr, PHY_PHYCTRL2, &settings))//Micrel
   \   0000000E   0xAB00             ADD      R3,SP,#+0
   \   00000010   0x221F             MOVS     R2,#+31
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       mii_read
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??eth_phy_get_manual_duplex_0
    317          #else
    318                  if (mii_read(ch, phy_addr, PHY_PHYSTS, &settings))//National Semiconductors
    319          #endif
    320                      return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE00F             B.N      ??eth_phy_get_manual_duplex_1
    321                  else
    322                      break;
    323              }
    324          #if MII_CHECK_TIMEOUT
    325              if (timeout == MII_TIMEOUT)
    326                  return 1;
    327          #endif
    328          
    329          #ifdef TWR_K60N512    
    330              /*FSL: obtain speed/duplex*/
    331              settings = (settings & PHY_PHYCTRL2_OP_MOD_MASK)>>PHY_PHYCTRL2_OP_MOD_SHIFT;
   \                     ??eth_phy_get_manual_duplex_0:
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF3C0 0x0082      UBFX     R0,R0,#+2,#+3
   \   00000028   0x9000             STR      R0,[SP, #+0]
    332              
    333              if (settings == PHY_PHYCTRL2_MODE_OP_MOD_10MBPS_HD     ||
    334                  settings == PHY_PHYCTRL2_MODE_OP_MOD_100MBPS_HD)
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD002             BEQ.N    ??eth_phy_get_manual_duplex_2
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD102             BNE.N    ??eth_phy_get_manual_duplex_3
    335                  *duplex = MII_HDX;
   \                     ??eth_phy_get_manual_duplex_2:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6030             STR      R0,[R6, #+0]
   \   0000003A   0xE001             B.N      ??eth_phy_get_manual_duplex_4
    336              else
    337                  *duplex = MII_FDX;
   \                     ??eth_phy_get_manual_duplex_3:
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x6030             STR      R0,[R6, #+0]
    338          #else
    339              if (settings & PHY_PHYSTS_DUPLEXSTATUS)
    340                  *duplex = MII_FDX;
    341              else
    342                  *duplex = MII_HDX;
    343          #endif
    344          
    345              return 0;
   \                     ??eth_phy_get_manual_duplex_4:
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_get_manual_duplex_1:
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    346          }
    347          
    348          /********************************************************************/
    349          /*!
    350           * \brief   Get the manual speed
    351           * \param   phy_addr    Address of the PHY
    352           * \param   loop        set if loopback is needed
    353           * \return  0 if successful; non-zero otherwise
    354           */

   \                                 In section .text, align 2, keep-with-next
    355          int 
    356          eth_phy_set_remote_loopback(int ch, int phy_addr, int loop)
    357          {
   \                     eth_phy_set_remote_loopback:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    358          #if MII_CHECK_TIMEOUT
    359              int timeout;
    360          #endif
    361              int settings = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    362          
    363              /* Get Link Partner settings */
    364          #if MII_CHECK_TIMEOUT
    365              for (timeout = 0; timeout < MII_TIMEOUT; ++timeout)
    366          #endif
    367              while(1)
    368              {      
    369                  if (mii_read(ch, phy_addr, PHY_PHYCTRL1, &settings))
   \   0000000E   0xAB00             ADD      R3,SP,#+0
   \   00000010   0x221E             MOVS     R2,#+30
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       mii_read
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??eth_phy_set_remote_loopback_0
    370                      return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE015             B.N      ??eth_phy_set_remote_loopback_1
    371                  else
    372                      break;
    373              }
    374          #if MII_CHECK_TIMEOUT
    375              if (timeout == MII_TIMEOUT)
    376                  return 1;
    377          #endif
    378              /*set remote loopback flag*/
    379              if(loop)
   \                     ??eth_phy_set_remote_loopback_0:
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD004             BEQ.N    ??eth_phy_set_remote_loopback_2
    380                settings |= PHY_PHYCTRL1_REMOTE_LOOP; /*set bit*/
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0xE003             B.N      ??eth_phy_set_remote_loopback_3
    381              else      
    382                settings &= ~PHY_PHYCTRL1_REMOTE_LOOP; /*clear bit*/
   \                     ??eth_phy_set_remote_loopback_2:
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000036   0x9000             STR      R0,[SP, #+0]
    383              
    384              if (mii_write(ch, phy_addr, PHY_PHYCTRL1, settings))
   \                     ??eth_phy_set_remote_loopback_3:
   \   00000038   0x9B00             LDR      R3,[SP, #+0]
   \   0000003A   0x221E             MOVS     R2,#+30
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       mii_write
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ.N    ??eth_phy_set_remote_loopback_4
    385                  return 1;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??eth_phy_set_remote_loopback_1
    386          
    387              return 0;
   \                     ??eth_phy_set_remote_loopback_4:
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??eth_phy_set_remote_loopback_1:
   \   0000004E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    388          }
    389          
    390          /********************************************************************/
    391          /*!
    392           * \brief   Print all the MII registers (0x00-0x1F)
    393           * \param   phy_addr    Address of the PHY
    394           */

   \                                 In section .text, align 2, keep-with-next
    395          int 
    396          eth_phy_reg_dump(int ch, int phy_addr)
    397          {
   \                     eth_phy_reg_dump:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    398              int j, settings;
    399              
    400              printf("\n    MII Register Block\n");
   \   00000008   0x....             LDR.N    R0,??DataTable4_3
   \   0000000A   0x.... 0x....      BL       printf
    401              printf("--------------------------------");
   \   0000000E   0x....             LDR.N    R0,??DataTable4_4
   \   00000010   0x.... 0x....      BL       printf
    402              for (j = 0; j < 32; j++)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0006             MOVS     R6,R0
   \                     ??eth_phy_reg_dump_0:
   \   00000018   0x2E20             CMP      R6,#+32
   \   0000001A   0xDA19             BGE.N    ??eth_phy_reg_dump_1
    403              {
    404                  mii_read(ch, phy_addr, j, &settings);
   \   0000001C   0xAB00             ADD      R3,SP,#+0
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       mii_read
    405                  if (!(j % 4))
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   0000002E   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD106             BNE.N    ??eth_phy_reg_dump_2
    406                      printf("\n0x%02X-0x%02X : %04X ", j, j + 3, settings);
   \   00000036   0x9B00             LDR      R3,[SP, #+0]
   \   00000038   0x1CF2             ADDS     R2,R6,#+3
   \   0000003A   0x0031             MOVS     R1,R6
   \   0000003C   0x....             LDR.N    R0,??DataTable4_5
   \   0000003E   0x.... 0x....      BL       printf
   \   00000042   0xE003             B.N      ??eth_phy_reg_dump_3
    407                  else
    408                      printf("%04X ", settings);
   \                     ??eth_phy_reg_dump_2:
   \   00000044   0x9900             LDR      R1,[SP, #+0]
   \   00000046   0x....             LDR.N    R0,??DataTable4_6
   \   00000048   0x.... 0x....      BL       printf
    409              }
   \                     ??eth_phy_reg_dump_3:
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \   0000004E   0xE7E3             B.N      ??eth_phy_reg_dump_0
    410              printf("\n");
   \                     ??eth_phy_reg_dump_1:
   \   00000050   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   00000052   0x.... 0x....      BL       printf
    411              
    412              return 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    413          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     eth_phy_anar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x0001FFFF         DC32     0x1ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     `?<Constant "\\n    MII Register Block\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     `?<Constant "---------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     `?<Constant "\\n0x%02X-0x%02X : %04X ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     `?<Constant "%04X ">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n    MII Register Block\\n">`:
   \   00000000   0x0A 0x20          DC8 "\012    MII Register Block\012"
   \              0x20 0x20    
   \              0x20 0x4D    
   \              0x49 0x49    
   \              0x20 0x52    
   \              0x65 0x67    
   \              0x69 0x73    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "---------------------...">`:
   \   00000000   0x2D 0x2D          DC8 "--------------------------------"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n0x%02X-0x%02X : %04X ">`:
   \   00000000   0x0A 0x30          DC8 "\0120x%02X-0x%02X : %04X "
   \              0x78 0x25    
   \              0x30 0x32    
   \              0x58 0x2D    
   \              0x30 0x78    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x30 0x34    
   \              0x58 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%04X ">`:
   \   00000000   0x25 0x30          DC8 "%04X "
   \              0x34 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  eth_phy_autoneg
             32 -> eth_phy_reset
             32 -> mii_read
             32 -> mii_write
       24  eth_phy_get_duplex
             24 -> mii_read
       24  eth_phy_get_manual_duplex
             24 -> mii_read
       24  eth_phy_get_manual_speed
             24 -> mii_read
       24  eth_phy_get_speed
             24 -> mii_read
       32  eth_phy_manual
             32 -> eth_phy_reset
             32 -> mii_read
             32 -> mii_write
       24  eth_phy_reg_dump
             24 -> mii_read
             24 -> printf
       16  eth_phy_reset
             16 -> mii_read
             16 -> mii_write
       24  eth_phy_set_remote_loopback
             24 -> mii_read
             24 -> mii_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "%04X ">
      36  ?<Constant "---------------------...">
      28  ?<Constant "\n    MII Register Block\n">
       2  ?<Constant "\n">
      24  ?<Constant "\n0x%02X-0x%02X : %04X ">
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  eth_phy_anar
     196  eth_phy_autoneg
      68  eth_phy_get_duplex
      68  eth_phy_get_manual_duplex
      68  eth_phy_get_manual_speed
      68  eth_phy_get_speed
     140  eth_phy_manual
      90  eth_phy_reg_dump
      54  eth_phy_reset
      80  eth_phy_set_remote_loopback

 
   4 bytes in section .data
  98 bytes in section .rodata
 860 bytes in section .text
 
 860 bytes of CODE  memory
  98 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
