C51 COMPILER V9.00   MAIN                                                                  09/17/2013 11:38:29 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN MAIN.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE MAIN.C ROM(COMPACT) OPTIMIZE(6,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "typedef.h"
   2          #include "gpio.h"
   3          #include "uart.h"
   4          #include "nrf_24l01.h"
   5          #include "delay.h"
   6          
   7          /******************************************************************************/
   8          // 函数名称：main 
   9          // 输入参数： 
  10          // 输出参数： 
  11          // 函数功能： 
  12          /******************************************************************************/
  13          void main(void)
  14          {
  15   1        unsigned char i=0;
  16   1      
  17   1        unsigned int count_send=0;
  18   1        unsigned int rec_new=0;
  19   1        unsigned int rec_old=0;
  20   1        unsigned int rec_err=0;
  21   1        unsigned int lock_key=0;
  22   1      
  23   1      
  24   1        uartInit();    //初始化串口
  25   1      
  26   1        Delay100ms();
  27   1      
  28   1        init_nrf24l01_io(); //初始化驱动NRF24L01的IO口
  29   1      
  30   1      //  led=0;
  31   1      //  Delay100ms();
  32   1      //  led=1;
  33   1      //  Delay100ms();
  34   1      //  led=0;
  35   1      //  Delay100ms();
  36   1      //  led=1;
  37   1      //  Delay100ms();
  38   1      //  TI=1;
  39   1        Delay100ms();
  40   1      
  41   1      
  42   1        uartSendString("READY!\r\n");
  43   1      
  44   1      
  45   1        ifnnrf_rx_mode();        //设置NRF24L01上电后为接收模式
  46   1      
  47   1      
  48   1      
  49   1        while(1)
  50   1        {
  51   2      
  52   2          KEY=1;
  53   2      
  54   2          KEY2=1;
  55   2      
C51 COMPILER V9.00   MAIN                                                                  09/17/2013 11:38:29 PAGE 2   

  56   2          while(KEY == 0 || KEY2 == 0)                        //发送:当有按键按下的时候，将测试数据通过无线模块发送出去。
  57   2              {
  58   3              
  59   3                      IRQ=1;
  60   3      
  61   3              SPI_RW_Reg(WRITE_REG+STATUS,0xff);
  62   3      
  63   3              if (KEY == 0)
  64   3                      {
  65   4                  tx_buf[0]=0xAA;
  66   4              } 
  67   3                      else if (KEY2 == 0) 
  68   3                      {
  69   4                  tx_buf[0]=0x55;
  70   4              }
  71   3      
  72   3              ifnnrf_tx_mode();              //写数据到nrf24L01的发送缓冲区，最长32个字节
  73   3      
  74   3              while(IRQ);                       //等待NRF24L01的发送完中断信号
  75   3      
  76   3              sta=SPI_Read(STATUS);         //读取状态寄存器
  77   3      
  78   3              SPI_RW_Reg(WRITE_REG+STATUS,0xff);        //进入到等待状态
  79   3      
  80   3              if(sta&STA_MARK_TX)                       //如果发送完成，则闪烁LED灯
  81   3                      {
  82   4                  if (KEY == 0)
  83   4                              {
  84   5                              led=0;
  85   5                              Delay100ms();
  86   5                              led=1;
  87   5                      Delay100ms();
  88   5                  } 
  89   4                              else
  90   4                               {
  91   5                              led2=0;
  92   5                              Delay100ms();
  93   5                              led2=1;
  94   5                      Delay100ms();
  95   5                  }
  96   4                 } 
  97   3                 else
  98   3                  {
  99   4                  ifnnrf_CLERN_ALL();           //否则，清除本次发送，重新发
 100   4                  }
 101   3      
 102   3                 lock_key=1;
 103   3      
 104   3          }
 105   2                      //发送
 106   2          if(lock_key) 
 107   2              {
 108   3              lock_key=0;
 109   3      
 110   3              ifnnrf_rx_mode();       //进入到接收模式，等待接收数据
 111   3      
 112   3              IRQ=1;                          //设置中断接收标记
 113   3      
 114   3              while(IRQ==0);      //等待中断
 115   3      
 116   3              _delay_us(400);         //延时
 117   3      
C51 COMPILER V9.00   MAIN                                                                  09/17/2013 11:38:29 PAGE 3   

 118   3          }
 119   2      
 120   2          IRQ=1;
 121   2      
 122   2          if(IRQ==0)                   //如果接收到了数据，则对接收到的数据进行处理
 123   2      
 124   2              {        
 125   3              sta=SPI_Read(STATUS);             //读取状态寄存器
 126   3      
 127   3              SPI_RW_Reg(WRITE_REG+STATUS,0xff);        //进入到等待状态
 128   3              
 129   3              if(sta&STA_MARK_RX)                                       //判断状态寄存器的状态，如果为接收到数据状态，则启动接收数据处理函数
 130   3                      { 
 131   4                  SPI_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);     //读取接收数据到接收缓冲区
 132   4      
 133   4                  if (rx_buf[0] == 0xAA) 
 134   4                              {
 135   5                      uartSendString("你按下了左边按键\r\n");
 136   5                      led=0;
 137   5                      Delay100ms();
 138   5                      led=1;
 139   5                      Delay100ms();
 140   5                  } 
 141   4                              else if (rx_buf[0] == 0x55)
 142   4                              {
 143   5                      uartSendString("你按下了右边按键\r\n");
 144   5                              led2=0;
 145   5                              Delay100ms();
 146   5                              led2=1;
 147   5                      Delay100ms();
 148   5                  }
 149   4                  rx_buf[0] = 0;
 150   4              }
 151   3                      else
 152   3                      {
 153   4                  ifnnrf_CLERN_ALL();
 154   4                  ifnnrf_rx_mode();
 155   4                  IRQ=1;
 156   4                  while(IRQ==0);
 157   4              }
 158   3          } //接收
 159   2                
 160   2        }
 161   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    287    ----
   CONSTANT SIZE    =     47    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
