; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --device=DARMSTM --apcs=interwork -O3 -I..\..\library\inc -I..\..\library\src -I..\uvsion -Id:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\obj\main.crf main.c]
                          THUMB

                          AREA ||i.EXTI_Configuration||, CODE, READONLY, ALIGN=1

                  EXTI_Configuration PROC
;;;167    *******************************************************************************/
;;;168    void EXTI_Configuration(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;169    {
;;;170      EXTI_InitTypeDef EXTI_InitStructure;
;;;171    
;;;172      /* Connect EXTI Line9 to PB.9 */
;;;173      GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource9);
000002  2109              MOVS     r1,#9
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;174    
;;;175      /* Configure EXTI Line9 to generate an interrupt on falling edge */
;;;176      EXTI_ClearITPendingBit(EXTI_Line9);
00000a  f44f7400          MOV      r4,#0x200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EXTI_ClearITPendingBit
;;;177      EXTI_InitStructure.EXTI_Line = EXTI_Line9;
;;;178      EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000014  2000              MOVS     r0,#0
000016  f88d0004          STRB     r0,[sp,#4]
;;;179      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
00001a  200c              MOVS     r0,#0xc
00001c  f88d0005          STRB     r0,[sp,#5]
;;;180      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000020  2001              MOVS     r0,#1
000022  f88d0006          STRB     r0,[sp,#6]
000026  9400              STR      r4,[sp,#0]            ;178
;;;181      EXTI_Init(&EXTI_InitStructure); 
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       EXTI_Init
;;;182    }
00002e  bd1c              POP      {r2-r4,pc}
;;;183    
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;144    *******************************************************************************/
;;;145    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;146    {
;;;147      GPIO_InitTypeDef GPIO_InitStructure;
;;;148    
;;;149      /* Configure PC.06 and PC.07 as Output push-pull */
;;;150      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
000002  20c0              MOVS     r0,#0xc0
000004  f8ad0000          STRH     r0,[sp,#0]
;;;151      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000008  2003              MOVS     r0,#3
00000a  f88d0002          STRB     r0,[sp,#2]
;;;152      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000e  2010              MOVS     r0,#0x10
000010  f88d0003          STRB     r0,[sp,#3]
;;;153      GPIO_Init(GPIOC, &GPIO_InitStructure);
000014  4669              MOV      r1,sp
000016  4807              LDR      r0,|L2.52|
000018  f7fffffe          BL       GPIO_Init
;;;154    
;;;155      /* Configure PB9 as input floating (EXTI Line9) */
;;;156      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00001c  f44f7000          MOV      r0,#0x200
000020  f8ad0000          STRH     r0,[sp,#0]
;;;157      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000024  2004              MOVS     r0,#4
000026  f88d0003          STRB     r0,[sp,#3]
;;;158      GPIO_Init(GPIOB, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4802              LDR      r0,|L2.56|
00002e  f7fffffe          BL       GPIO_Init
;;;159    }
000032  bd08              POP      {r3,pc}
;;;160    
                          ENDP

                  |L2.52|
                          DCD      0x40011000
                  |L2.56|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=2

                  NVIC_Configuration PROC
;;;190    *******************************************************************************/
;;;191    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;192    {
;;;193      NVIC_InitTypeDef NVIC_InitStructure;
;;;194    
;;;195      /* 2 bits for Preemption Priority and 2 bits for Sub Priority */
;;;196      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;197    
;;;198      NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel;
00000a  2017              MOVS     r0,#0x17
00000c  f88d0000          STRB     r0,[sp,#0]
;;;199      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;200      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  f88d0002          STRB     r0,[sp,#2]
;;;201      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2001              MOVS     r0,#1
00001c  f88d0003          STRB     r0,[sp,#3]
;;;202      NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;203    
;;;204      /* Set SysTick interrupt vector Preemption Priority to 1 */
;;;205      NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 1, 0);
000026  2200              MOVS     r2,#0
000028  2101              MOVS     r1,#1
00002a  4802              LDR      r0,|L3.52|
00002c  f7fffffe          BL       NVIC_SystemHandlerPriorityConfig
;;;206    }
000030  bd08              POP      {r3,pc}
;;;207    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x0002c39a

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;96     *******************************************************************************/
;;;97     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99       /* RCC system reset(for debug purpose) */
;;;100      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;101    
;;;102      /* Enable HSE */
;;;103      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;104    
;;;105      /* Wait till HSE is ready */
;;;106      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4910              LDR      r1,|L4.84|
000014  7008              STRB     r0,[r1,#0]
;;;107    
;;;108      if(HSEStartUpStatus == SUCCESS)
000016  b2c0              UXTB     r0,r0
000018  2801              CMP      r0,#1
00001a  d115              BNE      |L4.72|
;;;109      {
;;;110        /* HCLK = SYSCLK */
;;;111        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       RCC_HCLKConfig
;;;112      
;;;113        /* PCLK2 = HCLK */
;;;114        RCC_PCLK2Config(RCC_HCLK_Div1); 
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       RCC_PCLK2Config
;;;115    
;;;116        /* PCLK1 = HCLK */
;;;117        RCC_PCLK1Config(RCC_HCLK_Div1);
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       RCC_PCLK1Config
;;;118    
;;;119        /* Flash 0 wait state */
;;;120        FLASH_SetLatency(FLASH_Latency_0);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       FLASH_SetLatency
;;;121        /* Enable Prefetch Buffer */
;;;122        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000034  2010              MOVS     r0,#0x10
000036  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;123    
;;;124        /* Select HSE as system clock source */
;;;125        RCC_SYSCLKConfig(RCC_SYSCLKSource_HSE);
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       RCC_SYSCLKConfig
                  |L4.64|
;;;126    
;;;127        /* Wait till HSE is used as system clock source */
;;;128        while(RCC_GetSYSCLKSource() != 0x04)
000040  f7fffffe          BL       RCC_GetSYSCLKSource
000044  2804              CMP      r0,#4
000046  d1fb              BNE      |L4.64|
                  |L4.72|
;;;129        {
;;;130        }
;;;131      }
;;;132      
;;;133      /* Enable GPIOC, GPIOB and AFIO clock */
;;;134      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOB |
000048  2101              MOVS     r1,#1
00004a  e8bd4010          POP      {r4,lr}
00004e  2019              MOVS     r0,#0x19
000050  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;135                             RCC_APB2Periph_AFIO, ENABLE);  
;;;136    }
;;;137    
                          ENDP

                  |L4.84|
                          DCD      ||.data||

                          AREA ||i.SysTick_Configuration||, CODE, READONLY, ALIGN=2

                  SysTick_Configuration PROC
;;;236    *******************************************************************************/
;;;237    void SysTick_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;238    {
;;;239      /* Select HCLK/8 as SysTick clock source */
;;;240      SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);
000002  f06f0004          MVN      r0,#4
000006  f7fffffe          BL       SysTick_CLKSourceConfig
;;;241      
;;;242      /* SysTick interrupt each 250ms with counter clock equal to 1MHz */
;;;243      SysTick_SetReload(250000);
00000a  4805              LDR      r0,|L5.32|
00000c  f7fffffe          BL       SysTick_SetReload
;;;244    
;;;245      /* Enable the SysTick Counter */
;;;246      SysTick_CounterCmd(SysTick_Counter_Enable);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       SysTick_CounterCmd
;;;247    
;;;248      /* Enable the SysTick Interrupt */
;;;249      SysTick_ITConfig(ENABLE); 
000016  e8bd4010          POP      {r4,lr}
00001a  2001              MOVS     r0,#1
00001c  f7ffbffe          B.W      SysTick_ITConfig
;;;250    }
;;;251    
                          ENDP

                  |L5.32|
                          DCD      0x0003d090

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;31     *******************************************************************************/
;;;32     int main(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34     #ifdef DEBUG
;;;35       debug();
;;;36     #endif
;;;37     
;;;38       /* System Clocks Configuration ---------------------------------------------*/
;;;39       RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;40       
;;;41       /* GPIO configuration ------------------------------------------------------*/
;;;42       GPIO_Configuration();
000006  f7fffffe          BL       GPIO_Configuration
;;;43     
;;;44       /* Check if the system has resumed from IWDG reset -------------------------*/
;;;45       if(RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
00000a  207d              MOVS     r0,#0x7d
00000c  f7fffffe          BL       RCC_GetFlagStatus
;;;46       {	/* IWDGRST flag set */
;;;47         /* Turn on led connected to PC.06 */
;;;48         GPIO_WriteBit(GPIOC, GPIO_Pin_6, Bit_SET);
000010  4b12              LDR      r3,|L6.92|
000012  b138              CBZ      r0,|L6.36|
000014  2201              MOVS     r2,#1
000016  2140              MOVS     r1,#0x40
000018  4618              MOV      r0,r3
00001a  f7fffffe          BL       GPIO_WriteBit
;;;49     
;;;50     	/* Clear reset flags */
;;;51         RCC_ClearFlag();
00001e  f7fffffe          BL       RCC_ClearFlag
000022  e004              B        |L6.46|
                  |L6.36|
;;;52       }
;;;53       else
;;;54       {	/* IWDGRST flag is not set */
;;;55         /* Turn off led connected to PC.06 */
;;;56         GPIO_WriteBit(GPIOC, GPIO_Pin_6, Bit_RESET);
000024  2200              MOVS     r2,#0
000026  2140              MOVS     r1,#0x40
000028  4618              MOV      r0,r3
00002a  f7fffffe          BL       GPIO_WriteBit
                  |L6.46|
;;;57       }
;;;58     
;;;59       /* Configure EXTI Line9 to generate an interrupt on falling edge -----------*/
;;;60       EXTI_Configuration();
00002e  f7fffffe          BL       EXTI_Configuration
;;;61     
;;;62       /* NVIC configuration ------------------------------------------------------*/
;;;63       NVIC_Configuration();
000032  f7fffffe          BL       NVIC_Configuration
;;;64     
;;;65       /* Configure SysTick to generate an interrupt each 250ms -------------------*/
;;;66       SysTick_Configuration();
000036  f7fffffe          BL       SysTick_Configuration
;;;67     
;;;68       /* IWDG timeout equal to 350ms (the timeout may varies due to LSI frequency
;;;69          dispersion) -------------------------------------------------------------*/
;;;70       /* Enable write access to IWDG_PR and IWDG_RLR registers */
;;;71       IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
00003a  f2455055          MOV      r0,#0x5555
00003e  f7fffffe          BL       IWDG_WriteAccessCmd
;;;72     
;;;73       /* IWDG counter clock: 32KHz(LSI) / 32 = 1KHz */
;;;74       IWDG_SetPrescaler(IWDG_Prescaler_32);
000042  2003              MOVS     r0,#3
000044  f7fffffe          BL       IWDG_SetPrescaler
;;;75     
;;;76       /* Set counter reload value to 349 */
;;;77       IWDG_SetReload(349);
000048  f240105d          MOV      r0,#0x15d
00004c  f7fffffe          BL       IWDG_SetReload
;;;78     
;;;79       /* Reload IWDG counter */
;;;80       IWDG_ReloadCounter();
000050  f7fffffe          BL       IWDG_ReloadCounter
;;;81     
;;;82       /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
;;;83       IWDG_Enable();
000054  f7fffffe          BL       IWDG_Enable
                  |L6.88|
;;;84     
;;;85       while(1)
000058  e7fe              B        |L6.88|
;;;86       {
;;;87       }
;;;88     }
;;;89     
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
                          DCD      0x40011000

                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
