; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\hw_config.o --depend=.\Obj\hw_config.d --device=DARMSTM --apcs=interwork -O3 -I.\usb_library\inc -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DVECT_TAB_FLASH --omf_browse=.\Obj\hw_config.crf hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=1

                  Enter_LowPowerMode PROC
;;;147    *******************************************************************************/
;;;148    void Enter_LowPowerMode(void)
000000  4770              BX       lr
;;;149    {
;;;150    }
;;;151    
                          ENDP


                          AREA ||i.JoyState||, CODE, READONLY, ALIGN=2

                  JoyState PROC
;;;216    *******************************************************************************/
;;;217    u8 JoyState(void)
000000  b510              PUSH     {r4,lr}
;;;218    {
;;;219      /* "right" key is pressed */
;;;220      if (!GPIO_ReadInputDataBit(GPIOE, JOY_RIGHT))
000002  4c18              LDR      r4,|L2.100|
000004  2120              MOVS     r1,#0x20
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  b908              CBNZ     r0,|L2.18|
;;;221      {
;;;222        return RIGHT;
00000e  2003              MOVS     r0,#3
;;;223      }
;;;224      /* "left" key is pressed */
;;;225      if (!GPIO_ReadInputDataBit(GPIOE, JOY_LEFT))
;;;226      {
;;;227        return LEFT;
;;;228      }
;;;229      /* "up" key is pressed */
;;;230      if (!GPIO_ReadInputDataBit(GPIOE, JOY_UP))
;;;231      {
;;;232        return UP;
;;;233      }
;;;234      /* "down" key is pressed */
;;;235      if (!GPIO_ReadInputDataBit(GPIOE, JOY_DOWN))
;;;236      {
;;;237        return DOWN;
;;;238      }
;;;239      if (!GPIO_ReadInputDataBit(GPIOC, JOY_LEFT_BUTTON))
;;;240      {
;;;241        return LEFT_BUTTON;
;;;242      }
;;;243       if (!GPIO_ReadInputDataBit(GPIOC, JOY_RIGHT_BUTTON))
;;;244      {
;;;245        return RIGHT_BUTTON;
;;;246      }
;;;247      /* No key is pressed */
;;;248      else
;;;249      {
;;;250        return 0;
;;;251      }
;;;252    }
000010  bd10              POP      {r4,pc}
                  |L2.18|
000012  2110              MOVS     r1,#0x10              ;225
000014  4620              MOV      r0,r4                 ;225
000016  f7fffffe          BL       GPIO_ReadInputDataBit
00001a  b908              CBNZ     r0,|L2.32|
00001c  2002              MOVS     r0,#2                 ;227
00001e  bd10              POP      {r4,pc}
                  |L2.32|
000020  2108              MOVS     r1,#8                 ;230
000022  4620              MOV      r0,r4                 ;230
000024  f7fffffe          BL       GPIO_ReadInputDataBit
000028  b908              CBNZ     r0,|L2.46|
00002a  2004              MOVS     r0,#4                 ;232
00002c  bd10              POP      {r4,pc}
                  |L2.46|
00002e  2140              MOVS     r1,#0x40              ;235
000030  4620              MOV      r0,r4                 ;235
000032  f7fffffe          BL       GPIO_ReadInputDataBit
000036  b908              CBNZ     r0,|L2.60|
000038  2001              MOVS     r0,#1                 ;237
00003a  bd10              POP      {r4,pc}
                  |L2.60|
00003c  4c0a              LDR      r4,|L2.104|
00003e  f44f5100          MOV      r1,#0x2000            ;239
000042  4620              MOV      r0,r4                 ;239
000044  f7fffffe          BL       GPIO_ReadInputDataBit
000048  b908              CBNZ     r0,|L2.78|
00004a  2005              MOVS     r0,#5                 ;241
00004c  bd10              POP      {r4,pc}
                  |L2.78|
00004e  f44f5180          MOV      r1,#0x1000            ;243
000052  4620              MOV      r0,r4                 ;243
000054  f7fffffe          BL       GPIO_ReadInputDataBit
000058  b908              CBNZ     r0,|L2.94|
00005a  2006              MOVS     r0,#6                 ;245
00005c  bd10              POP      {r4,pc}
                  |L2.94|
00005e  2000              MOVS     r0,#0                 ;250
000060  bd10              POP      {r4,pc}
;;;253    
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      0x40011800
                  |L2.104|
                          DCD      0x40011000

                          AREA ||i.Joystick_Send||, CODE, READONLY, ALIGN=1

                  Joystick_Send PROC
;;;260    *******************************************************************************/
;;;261    void Joystick_Send(u8 Keys)
000000  b538              PUSH     {r3-r5,lr}
;;;262    {
;;;263      u8 Mouse_Buffer[4] = {0, 0, 0, 0};
000002  2400              MOVS     r4,#0
;;;264      s8 X = 0, Y = 0,BUTTON=0;
;;;265    
;;;266      switch (Keys)
;;;267      {
;;;268        case LEFT:
;;;269          X += CURSOR_STEP;
;;;270          break;
;;;271        case RIGHT:
;;;272    
;;;273          X -= CURSOR_STEP;
000004  1ee5              SUBS     r5,r4,#3
000006  4621              MOV      r1,r4                 ;264
000008  4622              MOV      r2,r4                 ;264
00000a  4623              MOV      r3,r4                 ;264
00000c  9400              STR      r4,[sp,#0]            ;266
00000e  2807              CMP      r0,#7                 ;266
000010  d22e              BCS      |L3.112|
000012  e8dff000          TBB      [pc,r0]               ;266
000016  2d0a              DCB      0x2d,0x0a
000018  0406080c          DCB      0x04,0x06,0x08,0x0c
00001c  0e00              DCB      0x0e,0x00
00001e  2103              MOVS     r1,#3                 ;269
000020  e008              B        |L3.52|
000022  4629              MOV      r1,r5
;;;274          break;
000024  e006              B        |L3.52|
;;;275        case UP:
;;;276          Y -= CURSOR_STEP;
000026  462a              MOV      r2,r5
;;;277          break;
000028  e004              B        |L3.52|
;;;278        case DOWN:
;;;279          Y += CURSOR_STEP;
00002a  2203              MOVS     r2,#3
;;;280          break;
00002c  e002              B        |L3.52|
;;;281    	 case LEFT_BUTTON:
;;;282          BUTTON = BUTTON|0x01;
00002e  2301              MOVS     r3,#1
;;;283          break;
000030  e000              B        |L3.52|
;;;284     	 case RIGHT_BUTTON:
;;;285          BUTTON = BUTTON|0x02;
000032  2302              MOVS     r3,#2
                  |L3.52|
;;;286          break;
;;;287        
;;;288        default:
;;;289          return;
;;;290      }
;;;291    
;;;292      /* prepare buffer to send */
;;;293      Mouse_Buffer[0] = BUTTON;
000034  f88d3000          STRB     r3,[sp,#0]
;;;294      Mouse_Buffer[1] = X;
000038  f88d1001          STRB     r1,[sp,#1]
;;;295      Mouse_Buffer[2] = Y;
00003c  f88d2002          STRB     r2,[sp,#2]
;;;296    
;;;297      /*copy mouse position info in ENDP1 Tx Packet Memory Area*/
;;;298      UserToPMABufferCopy(Mouse_Buffer, GetEPTxAddr(ENDP1), 4);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       GetEPTxAddr
000046  4601              MOV      r1,r0
000048  2204              MOVS     r2,#4
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       UserToPMABufferCopy
;;;299      if(Mouse_Buffer[0]!= 0)
000050  f89d0000          LDRB     r0,[sp,#0]
000054  b148              CBZ      r0,|L3.106|
;;;300      {
;;;301        Mouse_Buffer[0] = 0;
000056  f88d4000          STRB     r4,[sp,#0]
;;;302        UserToPMABufferCopy(Mouse_Buffer, GetEPTxAddr(ENDP1), 4);
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       GetEPTxAddr
000060  4601              MOV      r1,r0
000062  2204              MOVS     r2,#4
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       UserToPMABufferCopy
                  |L3.106|
;;;303      } 
;;;304      /* enable endpoint for transmission */
;;;305      SetEPTxValid(ENDP1);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       SetEPTxValid
                  |L3.112|
;;;306    }
000070  bd38              POP      {r3-r5,pc}
;;;307    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=1

                  Leave_LowPowerMode PROC
;;;158    *******************************************************************************/
;;;159    void Leave_LowPowerMode(void)
000000  4770              BX       lr
;;;160    {
;;;161    }
;;;162    
                          ENDP


                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;42     *******************************************************************************/
;;;43     void Set_System(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;44     {
;;;45       GPIO_InitTypeDef GPIO_InitStructure;
;;;46     
;;;47       /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------------------------*/   
;;;48       /* RCC system reset(for debug purpose) */
;;;49       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;50     
;;;51       /* Enable HSE */
;;;52       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;53     
;;;54       /* Wait till HSE is ready */
;;;55       HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  4930              LDR      r1,|L5.216|
000016  7008              STRB     r0,[r1,#0]
;;;56     
;;;57       if(HSEStartUpStatus == SUCCESS)
000018  b2c0              UXTB     r0,r0
00001a  2801              CMP      r0,#1
00001c  d126              BNE      |L5.108|
;;;58       {
;;;59         /* Enable Prefetch Buffer */
;;;60         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;61     
;;;62         /* Flash 2 wait state */
;;;63         FLASH_SetLatency(FLASH_Latency_2);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       FLASH_SetLatency
;;;64      
;;;65         /* HCLK = SYSCLK */
;;;66         RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RCC_HCLKConfig
;;;67       
;;;68         /* PCLK2 = HCLK */
;;;69         RCC_PCLK2Config(RCC_HCLK_Div1); 
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       RCC_PCLK2Config
;;;70     
;;;71         /* PCLK1 = HCLK/2 */
;;;72         RCC_PCLK1Config(RCC_HCLK_Div2);
000036  11a0              ASRS     r0,r4,#6
000038  f7fffffe          BL       RCC_PCLK1Config
;;;73     
;;;74         /* ADCCLK = PCLK2/6 */
;;;75         RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00003c  1060              ASRS     r0,r4,#1
00003e  f7fffffe          BL       RCC_ADCCLKConfig
;;;76     
;;;77         /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;78         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000042  f44f11e0          MOV      r1,#0x1c0000
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       RCC_PLLConfig
;;;79     
;;;80         /* Enable PLL */ 
;;;81         RCC_PLLCmd(ENABLE);
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       RCC_PLLCmd
                  |L5.82|
;;;82     
;;;83         /* Wait till PLL is ready */
;;;84         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000052  2039              MOVS     r0,#0x39
000054  f7fffffe          BL       RCC_GetFlagStatus
000058  2800              CMP      r0,#0
00005a  d0fa              BEQ      |L5.82|
;;;85         {
;;;86         }
;;;87     
;;;88         /* Select PLL as system clock source */
;;;89         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       RCC_SYSCLKConfig
;;;90     
;;;91         /* Wait till PLL is used as system clock source */
;;;92         while(RCC_GetSYSCLKSource() != 0x08)
000062  bf00              NOP      
                  |L5.100|
000064  f7fffffe          BL       RCC_GetSYSCLKSource
000068  2808              CMP      r0,#8
00006a  d1fb              BNE      |L5.100|
                  |L5.108|
;;;93         {
;;;94         }
;;;95       }
;;;96       
;;;97       /* Enable GPIOD and GPIOE clock */
;;;98       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE| RCC_APB2Periph_GPIOC, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2070              MOVS     r0,#0x70
000070  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;99       
;;;100      /* PD.13 used as USB pull-up */
;;;101      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000074  f44f5000          MOV      r0,#0x2000
000078  f8ad0000          STRH     r0,[sp,#0]
;;;102      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00007c  2403              MOVS     r4,#3
00007e  f88d4002          STRB     r4,[sp,#2]
;;;103      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000082  2014              MOVS     r0,#0x14
000084  f88d0003          STRB     r0,[sp,#3]
;;;104      GPIO_Init(GPIOD, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  4814              LDR      r0,|L5.220|
00008c  f7fffffe          BL       GPIO_Init
;;;105    
;;;106      /* Configure the JoyStick IOs */
;;;107      /* Key up + Key down  */
;;;108      GPIO_InitStructure.GPIO_Pin = JOY_UP | JOY_DOWN ;
000090  2548              MOVS     r5,#0x48
000092  f8ad5000          STRH     r5,[sp,#0]
;;;109      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;110      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
;;;111      GPIO_Init(GPIOE, &GPIO_InitStructure);
000096  4e12              LDR      r6,|L5.224|
000098  f88d4002          STRB     r4,[sp,#2]            ;109
00009c  f88d5003          STRB     r5,[sp,#3]            ;110
0000a0  4669              MOV      r1,sp
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       GPIO_Init
;;;112    
;;;113      /* Key left + Key right */
;;;114      GPIO_InitStructure.GPIO_Pin = JOY_LEFT | JOY_RIGHT;
0000a8  2030              MOVS     r0,#0x30
0000aa  f8ad0000          STRH     r0,[sp,#0]
;;;115      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000ae  f88d4002          STRB     r4,[sp,#2]
;;;116      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
0000b2  f88d5003          STRB     r5,[sp,#3]
;;;117      GPIO_Init(GPIOE, &GPIO_InitStructure);
0000b6  4669              MOV      r1,sp
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       GPIO_Init
;;;118        /* Right_button + Left_button */
;;;119      GPIO_InitStructure.GPIO_Pin = JOY_LEFT_BUTTON|JOY_RIGHT_BUTTON;
0000be  0320              LSLS     r0,r4,#12
0000c0  f8ad0000          STRH     r0,[sp,#0]
;;;120      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c4  f88d4002          STRB     r4,[sp,#2]
;;;121      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
0000c8  f88d5003          STRB     r5,[sp,#3]
;;;122      GPIO_Init(GPIOC, &GPIO_InitStructure);
0000cc  4669              MOV      r1,sp
0000ce  4805              LDR      r0,|L5.228|
0000d0  f7fffffe          BL       GPIO_Init
;;;123    }
0000d4  bdf8              POP      {r3-r7,pc}
;;;124    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L5.216|
                          DCD      ||.data||
                  |L5.220|
                          DCD      0x40011400
                  |L5.224|
                          DCD      0x40011800
                  |L5.228|
                          DCD      0x40011000

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;131    *******************************************************************************/
;;;132    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134      /* Select USBCLK source */
;;;135      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;136    
;;;137      /* Enable USB clock */
;;;138      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;139    }
;;;140    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;197    *******************************************************************************/
;;;198    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;199    { 
;;;200      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;201      {
;;;202        GPIO_ResetBits(GPIOD, GPIO_Pin_13);
000004  f44f5100          MOV      r1,#0x2000
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L7.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L7.16|
;;;203      }
;;;204      else
;;;205      {
;;;206        GPIO_SetBits(GPIOD, GPIO_Pin_13);
000010  f7ffbffe          B.W      GPIO_SetBits
;;;207      }
;;;208    }
;;;209    
                          ENDP

                  |L7.20|
                          DCD      0x40011400

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;169    *******************************************************************************/
;;;170    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;171    {
;;;172      NVIC_InitTypeDef NVIC_InitStructure;
;;;173    
;;;174    #ifdef  VECT_TAB_RAM  
;;;175      /* Set the Vector Table base location at 0x20000000 */ 
;;;176      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;177    #else  /* VECT_TAB_FLASH */
;;;178      /* Set the Vector Table base location at 0x08000000 */
;;;179      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;180    #endif 
;;;181    
;;;182      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
00000c  f44f60e0          MOV      r0,#0x700
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;183    
;;;184      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN_RX0_IRQChannel;
000014  2014              MOVS     r0,#0x14
000016  f88d0000          STRB     r0,[sp,#0]
;;;185      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2000              MOVS     r0,#0
00001c  f88d0001          STRB     r0,[sp,#1]
;;;186      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d0002          STRB     r0,[sp,#2]
;;;187      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2001              MOVS     r0,#1
000026  f88d0003          STRB     r0,[sp,#3]
;;;188      NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;189    }
000030  bd08              POP      {r3,pc}
;;;190    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00
