; generated by ARM C/C++ Compiler, 4.1 [Build 713]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Obj\usb_prop.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\usb_prop.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DVECT_TAB_FLASH --omf_browse=.\Obj\usb_prop.crf usb_prop.c]
                          THUMB

                          AREA ||i.Joystick_Data_Setup||, CODE, READONLY, ALIGN=2

                  Joystick_Data_Setup PROC
;;;193    *******************************************************************************/
;;;194    RESULT Joystick_Data_Setup(u8 RequestNo)
000000  4912              LDR      r1,|L1.76|
;;;195    {
000002  b510              PUSH     {r4,lr}
;;;196      u8 *(*CopyRoutine)(u16);
;;;197    
;;;198      CopyRoutine = NULL;
;;;199    
;;;200      if ((RequestNo == GET_DESCRIPTOR)
;;;201          && (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
000004  680a              LDR      r2,[r1,#0]
000006  2806              CMP      r0,#6                 ;200
000008  7811              LDRB     r1,[r2,#0]
00000a  f001017f          AND      r1,r1,#0x7f
00000e  d103              BNE      |L1.24|
000010  2901              CMP      r1,#1
000012  d101              BNE      |L1.24|
;;;202          && (pInformation->USBwIndex0 == 0))
000014  7953              LDRB     r3,[r2,#5]
000016  b113              CBZ      r3,|L1.30|
                  |L1.24|
;;;203      {
;;;204    
;;;205        if (pInformation->USBwValue1 == REPORT_DESCRIPTOR)
;;;206        {
;;;207          CopyRoutine = Joystick_GetReportDescriptor;
;;;208        }
;;;209        else if (pInformation->USBwValue1 == HID_DESCRIPTOR_TYPE)
;;;210        {
;;;211          CopyRoutine = Joystick_GetHIDDescriptor;
;;;212        }
;;;213    
;;;214      } /* End of GET_DESCRIPTOR */
;;;215    
;;;216      /*** GET_PROTOCOL ***/
;;;217      else if ((Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
000018  2921              CMP      r1,#0x21
00001a  d00a              BEQ      |L1.50|
00001c  e013              B        |L1.70|
                  |L1.30|
00001e  7890              LDRB     r0,[r2,#2]            ;205
000020  2822              CMP      r0,#0x22              ;205
000022  d002              BEQ      |L1.42|
000024  2821              CMP      r0,#0x21              ;209
000026  d002              BEQ      |L1.46|
000028  e00d              B        |L1.70|
                  |L1.42|
00002a  4909              LDR      r1,|L1.80|
00002c  e004              B        |L1.56|
                  |L1.46|
00002e  4909              LDR      r1,|L1.84|
000030  e002              B        |L1.56|
                  |L1.50|
;;;218               && RequestNo == GET_PROTOCOL)
000032  2803              CMP      r0,#3
000034  d107              BNE      |L1.70|
;;;219      {
;;;220        CopyRoutine = Joystick_GetProtocolValue;
000036  4908              LDR      r1,|L1.88|
                  |L1.56|
;;;221      }
;;;222    
;;;223      if (CopyRoutine == NULL)
000038  b129              CBZ      r1,|L1.70|
;;;224      {
;;;225        return USB_UNSUPPORT;
;;;226      }
;;;227    
;;;228      pInformation->Ctrl_Info.CopyData = CopyRoutine;
;;;229      pInformation->Ctrl_Info.Usb_wOffset = 0;
00003a  2000              MOVS     r0,#0
00003c  6191              STR      r1,[r2,#0x18]
00003e  8250              STRH     r0,[r2,#0x12]
;;;230      (*CopyRoutine)(0);
000040  4788              BLX      r1
;;;231      return USB_SUCCESS;
000042  2000              MOVS     r0,#0
;;;232    }
000044  bd10              POP      {r4,pc}
                  |L1.70|
000046  2002              MOVS     r0,#2                 ;225
000048  bd10              POP      {r4,pc}
;;;233    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      pInformation
                  |L1.80|
                          DCD      Joystick_GetReportDescriptor
                  |L1.84|
                          DCD      Joystick_GetHIDDescriptor
                  |L1.88|
                          DCD      Joystick_GetProtocolValue

                          AREA ||i.Joystick_GetConfigDescriptor||, CODE, READONLY, ALIGN=2

                  Joystick_GetConfigDescriptor PROC
;;;273    *******************************************************************************/
;;;274    u8 *Joystick_GetConfigDescriptor(u16 Length)
000000  4901              LDR      r1,|L2.8|
;;;275    {
;;;276      return Standard_GetDescriptorData(Length, &Config_Descriptor);
000002  f7ffbffe          B.W      Standard_GetDescriptorData
;;;277    }
;;;278    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||area_number.18||+0xc

                          AREA ||i.Joystick_GetDeviceDescriptor||, CODE, READONLY, ALIGN=2

                  Joystick_GetDeviceDescriptor PROC
;;;261    *******************************************************************************/
;;;262    u8 *Joystick_GetDeviceDescriptor(u16 Length)
000000  4901              LDR      r1,|L3.8|
;;;263    {
;;;264      return Standard_GetDescriptorData(Length, &Device_Descriptor);
000002  f7ffbffe          B.W      Standard_GetDescriptorData
;;;265    }
;;;266    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||area_number.18||+0x4

                          AREA ||i.Joystick_GetHIDDescriptor||, CODE, READONLY, ALIGN=2

                  Joystick_GetHIDDescriptor PROC
;;;310    *******************************************************************************/
;;;311    u8 *Joystick_GetHIDDescriptor(u16 Length)
000000  4901              LDR      r1,|L4.8|
;;;312    {
;;;313      return Standard_GetDescriptorData(Length, &Mouse_Hid_Descriptor);
000002  f7ffbffe          B.W      Standard_GetDescriptorData
;;;314    }
;;;315    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||area_number.18||+0x1c

                          AREA ||i.Joystick_GetProtocolValue||, CODE, READONLY, ALIGN=2

                  Joystick_GetProtocolValue PROC
;;;358    *******************************************************************************/
;;;359    u8 *Joystick_GetProtocolValue(u16 Length)
000000  b108              CBZ      r0,|L5.6|
;;;360    {
;;;361      if (Length == 0)
;;;362      {
;;;363        pInformation->Ctrl_Info.Usb_wLength = 1;
;;;364        return NULL;
;;;365      }
;;;366      else
;;;367      {
;;;368        return (u8 *)(&ProtocolValue);
000002  4804              LDR      r0,|L5.20|
;;;369      }
;;;370    }
000004  4770              BX       lr
                  |L5.6|
000006  4904              LDR      r1,|L5.24|
000008  2001              MOVS     r0,#1                 ;363
00000a  6809              LDR      r1,[r1,#0]            ;363  ; pInformation
00000c  8208              STRH     r0,[r1,#0x10]         ;363
00000e  2000              MOVS     r0,#0                 ;364
000010  4770              BX       lr
;;;371    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ||area_number.18||
                  |L5.24|
                          DCD      pInformation

                          AREA ||i.Joystick_GetReportDescriptor||, CODE, READONLY, ALIGN=2

                  Joystick_GetReportDescriptor PROC
;;;298    *******************************************************************************/
;;;299    u8 *Joystick_GetReportDescriptor(u16 Length)
000000  4901              LDR      r1,|L6.8|
;;;300    {
;;;301      return Standard_GetDescriptorData(Length, &Joystick_Report_Descriptor);
000002  f7ffbffe          B.W      Standard_GetDescriptorData
;;;302    }
;;;303    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||area_number.18||+0x14

                          AREA ||i.Joystick_GetStringDescriptor||, CODE, READONLY, ALIGN=2

                  Joystick_GetStringDescriptor PROC
;;;285    *******************************************************************************/
;;;286    u8 *Joystick_GetStringDescriptor(u16 Length)
000000  4903              LDR      r1,|L7.16|
;;;287    {
;;;288      u8 wValue0 = pInformation->USBwValue0;
;;;289      return Standard_GetDescriptorData(Length, &String_Descriptor[wValue0]);
000002  4a04              LDR      r2,|L7.20|
000004  6809              LDR      r1,[r1,#0]            ;288  ; pInformation
000006  78c9              LDRB     r1,[r1,#3]            ;288
000008  eb0201c1          ADD      r1,r2,r1,LSL #3
00000c  f7ffbffe          B.W      Standard_GetDescriptorData
;;;290    }
;;;291    
                          ENDP

                  |L7.16|
                          DCD      pInformation
                  |L7.20|
                          DCD      ||area_number.18||+0x54

                          AREA ||i.Joystick_Get_Interface_Setting||, CODE, READONLY, ALIGN=1

                  Joystick_Get_Interface_Setting PROC
;;;324    *******************************************************************************/
;;;325    RESULT Joystick_Get_Interface_Setting(u8 Interface, u8 AlternateSetting)
000000  b909              CBNZ     r1,|L8.6|
;;;326    {
;;;327      if (AlternateSetting > 0)
;;;328      {
;;;329        return USB_UNSUPPORT;
;;;330      }
;;;331      else if (Interface > 0)
000002  2800              CMP      r0,#0
000004  d000              BEQ      |L8.8|
                  |L8.6|
;;;332      {
;;;333        return USB_UNSUPPORT;
000006  2002              MOVS     r0,#2
                  |L8.8|
;;;334      }
;;;335      return USB_SUCCESS;
;;;336    }
000008  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.Joystick_NoData_Setup||, CODE, READONLY, ALIGN=2

                  Joystick_NoData_Setup PROC
;;;240    *******************************************************************************/
;;;241    RESULT Joystick_NoData_Setup(u8 RequestNo)
000000  4906              LDR      r1,|L9.28|
;;;242    {
;;;243      if ((Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
000002  6809              LDR      r1,[r1,#0]  ; pInformation
000004  7809              LDRB     r1,[r1,#0]
000006  f001017f          AND      r1,r1,#0x7f
00000a  2921              CMP      r1,#0x21
00000c  d101              BNE      |L9.18|
;;;244          && (RequestNo == SET_PROTOCOL))
00000e  280b              CMP      r0,#0xb
000010  d001              BEQ      |L9.22|
                  |L9.18|
;;;245      {
;;;246        return Joystick_SetProtocol();
;;;247      }
;;;248    
;;;249      else
;;;250      {
;;;251        return USB_UNSUPPORT;
000012  2002              MOVS     r0,#2
;;;252      }
;;;253    }
000014  4770              BX       lr
                  |L9.22|
000016  f7ffbffe          B.W      Joystick_SetProtocol
;;;254    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      pInformation

                          AREA ||i.Joystick_Reset||, CODE, READONLY, ALIGN=2

                  Joystick_Reset PROC
;;;137    *******************************************************************************/
;;;138    void Joystick_Reset(void)
000000  491f              LDR      r1,|L10.128|
;;;139    {
000002  b510              PUSH     {r4,lr}
;;;140      /* Set Joystick_DEVICE as not configured */
;;;141      pInformation->Current_Configuration = 0;
000004  6809              LDR      r1,[r1,#0]  ; pInformation
000006  2000              MOVS     r0,#0
000008  7288              STRB     r0,[r1,#0xa]
;;;142      pInformation->Current_Interface = 0;/*the default Interface*/
00000a  72c8              STRB     r0,[r1,#0xb]
;;;143      SetBTABLE(BTABLE_ADDRESS);
00000c  f7fffffe          BL       SetBTABLE
;;;144    
;;;145      /* Initialize Endpoint 0 */
;;;146      SetEPType(ENDP0, EP_CONTROL);
000010  f44f7100          MOV      r1,#0x200
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       SetEPType
;;;147      SetEPTxStatus(ENDP0, EP_TX_STALL);
00001a  2110              MOVS     r1,#0x10
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SetEPTxStatus
;;;148      SetEPRxAddr(ENDP0, ENDP0_RXADDR);
000022  2118              MOVS     r1,#0x18
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SetEPRxAddr
;;;149      SetEPTxAddr(ENDP0, ENDP0_TXADDR);
00002a  2158              MOVS     r1,#0x58
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SetEPTxAddr
;;;150      Clear_Status_Out(ENDP0);
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       Clear_Status_Out
;;;151      SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
000038  4812              LDR      r0,|L10.132|
00003a  f890102c          LDRB     r1,[r0,#0x2c]  ; Device_Property
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       SetEPRxCount
;;;152      SetEPRxValid(ENDP0);
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       SetEPRxValid
;;;153    
;;;154      /* Initialize Endpoint 1 */
;;;155      SetEPType(ENDP1, EP_INTERRUPT);
00004a  f44f61c0          MOV      r1,#0x600
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       SetEPType
;;;156      SetEPTxAddr(ENDP1, ENDP1_TXADDR);
000054  f44f7180          MOV      r1,#0x100
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       SetEPTxAddr
;;;157      SetEPTxCount(ENDP1, 4);
00005e  2104              MOVS     r1,#4
000060  2001              MOVS     r0,#1
000062  f7fffffe          BL       SetEPTxCount
;;;158      SetEPRxStatus(ENDP1, EP_RX_DIS);
000066  2100              MOVS     r1,#0
000068  2001              MOVS     r0,#1
00006a  f7fffffe          BL       SetEPRxStatus
;;;159      SetEPTxStatus(ENDP1, EP_TX_NAK);
00006e  2120              MOVS     r1,#0x20
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       SetEPTxStatus
;;;160    
;;;161      /* Set this device to response on default address */
;;;162      SetDeviceAddress(0);
000076  e8bd4010          POP      {r4,lr}
00007a  2000              MOVS     r0,#0
00007c  f7ffbffe          B.W      SetDeviceAddress
;;;163    }
;;;164    
                          ENDP

                  |L10.128|
                          DCD      pInformation
                  |L10.132|
                          DCD      ||area_number.18||+0x24

                          AREA ||i.Joystick_SetProtocol||, CODE, READONLY, ALIGN=2

                  Joystick_SetProtocol PROC
;;;344    *******************************************************************************/
;;;345    RESULT Joystick_SetProtocol(void)
000000  4803              LDR      r0,|L11.16|
;;;346    {
;;;347      u8 wValue0 = pInformation->USBwValue0;
;;;348      ProtocolValue = wValue0;
000002  4904              LDR      r1,|L11.20|
000004  6800              LDR      r0,[r0,#0]            ;347  ; pInformation
000006  78c0              LDRB     r0,[r0,#3]            ;347
;;;349      return USB_SUCCESS;
000008  6008              STR      r0,[r1,#0]  ; ProtocolValue
00000a  2000              MOVS     r0,#0
;;;350    }
00000c  4770              BX       lr
;;;351    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      pInformation
                  |L11.20|
                          DCD      ||area_number.18||

                          AREA ||i.Joystick_Status_In||, CODE, READONLY, ALIGN=1

                  Joystick_Status_In PROC
;;;171    *******************************************************************************/
;;;172    void Joystick_Status_In(void)
000000  4770              BX       lr
;;;173    {
;;;174    }
;;;175    
                          ENDP


                          AREA ||i.Joystick_Status_Out||, CODE, READONLY, ALIGN=1

                  Joystick_Status_Out PROC
;;;182    *******************************************************************************/
;;;183    void Joystick_Status_Out (void)
000000  4770              BX       lr
;;;184    {
;;;185    }
;;;186    
                          ENDP


                          AREA ||i.Joystick_init||, CODE, READONLY, ALIGN=2

                  Joystick_init PROC
;;;111    *******************************************************************************/
;;;112    void Joystick_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;113    {
;;;114      pInformation->Current_Configuration = 0;
000002  4c0f              LDR      r4,|L14.64|
000004  2500              MOVS     r5,#0
000006  6820              LDR      r0,[r4,#0]  ; pInformation
000008  7285              STRB     r5,[r0,#0xa]
;;;115      /* Connect the device */
;;;116      PowerOn();
00000a  f7fffffe          BL       PowerOn
;;;117      /* USB interrupts initialization */
;;;118      _SetISTR(0);               /* clear pending interrupts */
00000e  480d              LDR      r0,|L14.68|
000010  6005              STR      r5,[r0,#0]
;;;119      wInterrupt_Mask = IMR_MSK;
000012  490d              LDR      r1,|L14.72|
000014  f44f403f          MOV      r0,#0xbf00
000018  8008              STRH     r0,[r1,#0]
;;;120      _SetCNTR(wInterrupt_Mask); /* set interrupts mask */
00001a  490a              LDR      r1,|L14.68|
00001c  1f09              SUBS     r1,r1,#4
00001e  6008              STR      r0,[r1,#0]
;;;121      pInformation->Current_Feature = Joystick_ConfigDescriptor[7];
000020  480a              LDR      r0,|L14.76|
000022  6821              LDR      r1,[r4,#0]  ; pInformation
000024  79c0              LDRB     r0,[r0,#7]  ; Joystick_ConfigDescriptor
000026  7248              STRB     r0,[r1,#9]
;;;122      /* Wait until device is configured */
;;;123      while (pInformation->Current_Configuration == 0)
000028  e002              B        |L14.48|
;;;124      {
;;;125        NOP_Process();
00002a  bf00              NOP      
                  |L14.44|
00002c  f7fffffe          BL       NOP_Process
                  |L14.48|
000030  6820              LDR      r0,[r4,#0]            ;123  ; pInformation
000032  7a80              LDRB     r0,[r0,#0xa]          ;123
000034  2800              CMP      r0,#0                 ;123
000036  d0f9              BEQ      |L14.44|
;;;126      }
;;;127    
;;;128      bDeviceState = CONFIGURED;
000038  4905              LDR      r1,|L14.80|
00003a  2005              MOVS     r0,#5
00003c  7008              STRB     r0,[r1,#0]
;;;129    }
00003e  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

                  |L14.64|
                          DCD      pInformation
                  |L14.68|
                          DCD      0x40005c44
                  |L14.72|
                          DCD      wInterrupt_Mask
                  |L14.76|
                          DCD      Joystick_ConfigDescriptor
                  |L14.80|
                          DCD      bDeviceState

                          AREA ||.data||, DATA, ALIGN=0

                  Device_Table
000000  0201              DCB      0x02,0x01

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  ProtocolValue
                          DCD      0x00000000
                  Device_Descriptor
                          DCD      Joystick_DeviceDescriptor
000008  0012              DCW      0x0012
00000a  0000              DCB      0x00,0x00
                  Config_Descriptor
                          DCD      Joystick_ConfigDescriptor
000010  0022              DCW      0x0022
000012  0000              DCB      0x00,0x00
                  Joystick_Report_Descriptor
                          DCD      Joystick_ReportDescriptor
000018  004a              DCW      0x004a
00001a  0000              DCB      0x00,0x00
                  Mouse_Hid_Descriptor
                          DCD      Joystick_ConfigDescriptor+0x12
000020  0009              DCW      0x0009
000022  0000              DCB      0x00,0x00
                  Device_Property
                          DCD      Joystick_init
                          DCD      Joystick_Reset
                          DCD      Joystick_Status_In
                          DCD      Joystick_Status_Out
                          DCD      Joystick_Data_Setup
                          DCD      Joystick_NoData_Setup
                          DCD      Joystick_Get_Interface_Setting
                          DCD      Joystick_GetDeviceDescriptor
                          DCD      Joystick_GetConfigDescriptor
                          DCD      Joystick_GetStringDescriptor
                          DCD      0x00000000
000050  40000000          DCB      0x40,0x00,0x00,0x00
                  String_Descriptor
                          DCD      Joystick_StringLangID
000058  0004              DCW      0x0004
00005a  0000              DCB      0x00,0x00
                          DCD      Joystick_StringVendor
000060  0026              DCW      0x0026
000062  0000              DCB      0x00,0x00
                          DCD      Joystick_StringProduct
000068  001e              DCW      0x001e
00006a  0000              DCB      0x00,0x00
                          DCD      Joystick_StringSerial
000070  001a              DCW      0x001a
000072  0000              DCB      0x00,0x00

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  User_Standard_Requests
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
