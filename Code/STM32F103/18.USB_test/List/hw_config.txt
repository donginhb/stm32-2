; generated by ARM C/C++ Compiler, 4.1 [Build 713]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Obj\hw_config.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DVECT_TAB_FLASH --omf_browse=.\Obj\hw_config.crf hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=1

                  Enter_LowPowerMode PROC
;;;147    *******************************************************************************/
;;;148    void Enter_LowPowerMode(void)
000000  4770              BX       lr
;;;149    {
;;;150    }
;;;151    
                          ENDP


                          AREA ||i.JoyState||, CODE, READONLY, ALIGN=2

                  JoyState PROC
;;;216    *******************************************************************************/
;;;217    u8 JoyState(void)
000000  b510              PUSH     {r4,lr}
;;;218    {
;;;219      /* "right" key is pressed */
;;;220      if (!GPIO_ReadInputDataBit(GPIOE, JOY_RIGHT))
000002  4c17              LDR      r4,|L2.96|
000004  f44f6180          MOV      r1,#0x400
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_ReadInputDataBit
00000e  b1d8              CBZ      r0,|L2.72|
;;;221      {
;;;222        return RIGHT;
;;;223      }
;;;224      /* "left" key is pressed */
;;;225      if (!GPIO_ReadInputDataBit(GPIOE, JOY_LEFT))
000010  15a1              ASRS     r1,r4,#22
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_ReadInputDataBit
000018  b1c0              CBZ      r0,|L2.76|
;;;226      {
;;;227        return LEFT;
;;;228      }
;;;229      /* "up" key is pressed */
;;;230      if (!GPIO_ReadInputDataBit(GPIOE, JOY_UP))
00001a  1561              ASRS     r1,r4,#21
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  b1a8              CBZ      r0,|L2.80|
;;;231      {
;;;232        return UP;
;;;233      }
;;;234      /* "down" key is pressed */
;;;235      if (!GPIO_ReadInputDataBit(GPIOE, JOY_DOWN))
000024  14e1              ASRS     r1,r4,#19
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_ReadInputDataBit
00002c  b190              CBZ      r0,|L2.84|
;;;236      {
;;;237        return DOWN;
;;;238      }
;;;239      if (!GPIO_ReadInputDataBit(GPIOA, JOY_LEFT_BUTTON))
00002e  4c0d              LDR      r4,|L2.100|
000030  2180              MOVS     r1,#0x80
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       GPIO_ReadInputDataBit
000038  b170              CBZ      r0,|L2.88|
;;;240      {
;;;241        return LEFT_BUTTON;
;;;242      }
;;;243       if (!GPIO_ReadInputDataBit(GPIOA, JOY_RIGHT_BUTTON))
00003a  14a1              ASRS     r1,r4,#18
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       GPIO_ReadInputDataBit
000042  b158              CBZ      r0,|L2.92|
;;;244      {
;;;245        return RIGHT_BUTTON;
;;;246      }
;;;247      /* No key is pressed */
;;;248      else
;;;249      {
;;;250        return 0;
000044  2000              MOVS     r0,#0
;;;251      }
;;;252    }
000046  bd10              POP      {r4,pc}
                  |L2.72|
000048  2003              MOVS     r0,#3                 ;222
00004a  bd10              POP      {r4,pc}
                  |L2.76|
00004c  2002              MOVS     r0,#2                 ;227
00004e  bd10              POP      {r4,pc}
                  |L2.80|
000050  2004              MOVS     r0,#4                 ;232
000052  bd10              POP      {r4,pc}
                  |L2.84|
000054  2001              MOVS     r0,#1                 ;237
000056  bd10              POP      {r4,pc}
                  |L2.88|
000058  2005              MOVS     r0,#5                 ;241
00005a  bd10              POP      {r4,pc}
                  |L2.92|
00005c  2006              MOVS     r0,#6                 ;245
00005e  bd10              POP      {r4,pc}
;;;253    
                          ENDP

                  |L2.96|
                          DCD      0x40011800
                  |L2.100|
                          DCD      0x40010800

                          AREA ||i.Joystick_Send||, CODE, READONLY, ALIGN=1

                  Joystick_Send PROC
;;;260    *******************************************************************************/
;;;261    void Joystick_Send(u8 Keys)
000000  b5f8              PUSH     {r3-r7,lr}
;;;262    {
;;;263      u8 Mouse_Buffer[4] = {0, 0, 0, 0};
000002  2400              MOVS     r4,#0
;;;264      s8 X = 0, Y = 0,BUTTON=0;
;;;265    
;;;266      switch (Keys)
;;;267      {
;;;268        case LEFT:
;;;269          X += CURSOR_STEP;
;;;270          break;
;;;271        case RIGHT:
;;;272    
;;;273          X -= CURSOR_STEP;
000004  1ee3              SUBS     r3,r4,#3
000006  4621              MOV      r1,r4                 ;264
000008  4622              MOV      r2,r4                 ;264
00000a  4625              MOV      r5,r4                 ;264
00000c  9400              STR      r4,[sp,#0]            ;266
00000e  2807              CMP      r0,#7                 ;266
000010  d22e              BCS      |L3.112|
000012  e8dff000          TBB      [pc,r0]               ;266
000016  2d0a              DCB      0x2d,0x0a
000018  0406080c          DCB      0x04,0x06,0x08,0x0c
00001c  0e00              DCB      0x0e,0x00
00001e  2103              MOVS     r1,#3                 ;269
000020  e008              B        |L3.52|
000022  4619              MOV      r1,r3
;;;274          break;
000024  e006              B        |L3.52|
;;;275        case UP:
;;;276          Y -= CURSOR_STEP;
000026  461a              MOV      r2,r3
;;;277          break;
000028  e004              B        |L3.52|
;;;278        case DOWN:
;;;279          Y += CURSOR_STEP;
00002a  2203              MOVS     r2,#3
;;;280          break;
00002c  e002              B        |L3.52|
;;;281    	 case LEFT_BUTTON:
;;;282          BUTTON = BUTTON|0x01;
00002e  2501              MOVS     r5,#1
;;;283          break;
000030  e000              B        |L3.52|
;;;284     	 case RIGHT_BUTTON:
;;;285          BUTTON = BUTTON|0x02;
000032  2502              MOVS     r5,#2
                  |L3.52|
;;;286          break;
;;;287        
;;;288        default:
;;;289          return;
;;;290      }
;;;291    
;;;292      /* prepare buffer to send */
;;;293      Mouse_Buffer[0] = BUTTON;
000034  f88d5000          STRB     r5,[sp,#0]
;;;294      Mouse_Buffer[1] = X;
000038  f88d1001          STRB     r1,[sp,#1]
;;;295      Mouse_Buffer[2] = Y;
00003c  f88d2002          STRB     r2,[sp,#2]
;;;296    
;;;297      /*copy mouse position info in ENDP1 Tx Packet Memory Area*/
;;;298      UserToPMABufferCopy(Mouse_Buffer, GetEPTxAddr(ENDP1), 4);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       GetEPTxAddr
000046  4601              MOV      r1,r0
000048  2204              MOVS     r2,#4
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       UserToPMABufferCopy
;;;299      if(Mouse_Buffer[0]!= 0)
000050  f89d0000          LDRB     r0,[sp,#0]
000054  b148              CBZ      r0,|L3.106|
;;;300      {
;;;301        Mouse_Buffer[0] = 0;
000056  f88d4000          STRB     r4,[sp,#0]
;;;302        UserToPMABufferCopy(Mouse_Buffer, GetEPTxAddr(ENDP1), 4);
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       GetEPTxAddr
000060  4601              MOV      r1,r0
000062  2204              MOVS     r2,#4
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       UserToPMABufferCopy
                  |L3.106|
;;;303      } 
;;;304      /* enable endpoint for transmission */
;;;305      SetEPTxValid(ENDP1);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       SetEPTxValid
                  |L3.112|
;;;306    }
000070  bdf8              POP      {r3-r7,pc}
;;;307    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=1

                  Leave_LowPowerMode PROC
;;;158    *******************************************************************************/
;;;159    void Leave_LowPowerMode(void)
000000  4770              BX       lr
;;;160    {
;;;161    }
;;;162    
                          ENDP


                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;42     *******************************************************************************/
;;;43     void Set_System(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;44     {
;;;45       GPIO_InitTypeDef GPIO_InitStructure;
;;;46     
;;;47       /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------------------------*/   
;;;48       /* RCC system reset(for debug purpose) */
;;;49       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;50     
;;;51       /* Enable HSE */
;;;52       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;53     
;;;54       /* Wait till HSE is ready */
;;;55       HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  4931              LDR      r1,|L5.220|
;;;56     
;;;57       if(HSEStartUpStatus == SUCCESS)
000016  2801              CMP      r0,#1
000018  7008              STRB     r0,[r1,#0]            ;55
00001a  d125              BNE      |L5.104|
;;;58       {
;;;59         /* Enable Prefetch Buffer */
;;;60         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;61     
;;;62         /* Flash 2 wait state */
;;;63         FLASH_SetLatency(FLASH_Latency_2);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       FLASH_SetLatency
;;;64      
;;;65         /* HCLK = SYSCLK */
;;;66         RCC_HCLKConfig(RCC_SYSCLK_Div1); 
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       RCC_HCLKConfig
;;;67       
;;;68         /* PCLK2 = HCLK */
;;;69         RCC_PCLK2Config(RCC_HCLK_Div1); 
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       RCC_PCLK2Config
;;;70     
;;;71         /* PCLK1 = HCLK/2 */
;;;72         RCC_PCLK1Config(RCC_HCLK_Div2);
000034  11a0              ASRS     r0,r4,#6
000036  f7fffffe          BL       RCC_PCLK1Config
;;;73     
;;;74         /* ADCCLK = PCLK2/6 */
;;;75         RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00003a  1060              ASRS     r0,r4,#1
00003c  f7fffffe          BL       RCC_ADCCLKConfig
;;;76     
;;;77         /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;78         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000040  f44f11e0          MOV      r1,#0x1c0000
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RCC_PLLConfig
;;;79     
;;;80         /* Enable PLL */ 
;;;81         RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
                  |L5.80|
;;;82     
;;;83         /* Wait till PLL is ready */
;;;84         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  2039              MOVS     r0,#0x39
000052  f7fffffe          BL       RCC_GetFlagStatus
000056  2800              CMP      r0,#0
000058  d0fa              BEQ      |L5.80|
;;;85         {
;;;86         }
;;;87     
;;;88         /* Select PLL as system clock source */
;;;89         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       RCC_SYSCLKConfig
                  |L5.96|
;;;90     
;;;91         /* Wait till PLL is used as system clock source */
;;;92         while(RCC_GetSYSCLKSource() != 0x08)
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L5.96|
                  |L5.104|
;;;93         {
;;;94         }
;;;95       }
;;;96       
;;;97       /* Enable GPIOD and GPIOE clock */
;;;98       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE| RCC_APB2Periph_GPIOC, ENABLE);
000068  2101              MOVS     r1,#1
00006a  2070              MOVS     r0,#0x70
00006c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;99       
;;;100      /* PD.13 used as USB pull-up */
;;;101      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000070  f44f5000          MOV      r0,#0x2000
000074  f8ad0000          STRH     r0,[sp,#0]
;;;102      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000078  2403              MOVS     r4,#3
00007a  f88d4002          STRB     r4,[sp,#2]
;;;103      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
00007e  2014              MOVS     r0,#0x14
000080  f88d0003          STRB     r0,[sp,#3]
;;;104      GPIO_Init(GPIOD, &GPIO_InitStructure);
000084  4669              MOV      r1,sp
000086  4816              LDR      r0,|L5.224|
000088  f7fffffe          BL       GPIO_Init
;;;105    
;;;106      /* Configure the JoyStick IOs */
;;;107      /* Key up + Key down  */
;;;108      GPIO_InitStructure.GPIO_Pin = JOY_UP | JOY_DOWN ;
00008c  f44f6020          MOV      r0,#0xa00
000090  f8ad0000          STRH     r0,[sp,#0]
;;;109      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;110      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
;;;111      GPIO_Init(GPIOE, &GPIO_InitStructure);
000094  4e13              LDR      r6,|L5.228|
000096  f88d4002          STRB     r4,[sp,#2]            ;109
00009a  2548              MOVS     r5,#0x48              ;110
00009c  f88d5003          STRB     r5,[sp,#3]            ;110
0000a0  4669              MOV      r1,sp
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       GPIO_Init
;;;112    
;;;113      /* Key left + Key right */
;;;114      GPIO_InitStructure.GPIO_Pin = JOY_LEFT | JOY_RIGHT;
0000a8  f44f60a0          MOV      r0,#0x500
0000ac  f8ad0000          STRH     r0,[sp,#0]
;;;115      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000b0  f88d4002          STRB     r4,[sp,#2]
;;;116      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
0000b4  f88d5003          STRB     r5,[sp,#3]
;;;117      GPIO_Init(GPIOE, &GPIO_InitStructure);
0000b8  4669              MOV      r1,sp
0000ba  4630              MOV      r0,r6
0000bc  f7fffffe          BL       GPIO_Init
;;;118        /* Right_button + Left_button */
;;;119      GPIO_InitStructure.GPIO_Pin = JOY_LEFT_BUTTON|JOY_RIGHT_BUTTON;
0000c0  f44f5084          MOV      r0,#0x1080
0000c4  f8ad0000          STRH     r0,[sp,#0]
;;;120      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c8  f88d4002          STRB     r4,[sp,#2]
;;;121      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
0000cc  f88d5003          STRB     r5,[sp,#3]
;;;122      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000d0  4669              MOV      r1,sp
0000d2  4805              LDR      r0,|L5.232|
0000d4  f7fffffe          BL       GPIO_Init
;;;123    }
0000d8  bdf8              POP      {r3-r7,pc}
;;;124    
                          ENDP

0000da  0000              DCW      0x0000
                  |L5.220|
                          DCD      ||.data||
                  |L5.224|
                          DCD      0x40011400
                  |L5.228|
                          DCD      0x40011800
                  |L5.232|
                          DCD      0x40010800

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;131    *******************************************************************************/
;;;132    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134      /* Select USBCLK source */
;;;135      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;136    
;;;137      /* Enable USB clock */
;;;138      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;139    }
;;;140    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;197    *******************************************************************************/
;;;198    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;199    { 
;;;200      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;201      {
;;;202        GPIO_ResetBits(GPIOD, GPIO_Pin_13);
000004  f44f5100          MOV      r1,#0x2000
;;;203      }
;;;204      else
;;;205      {
;;;206        GPIO_SetBits(GPIOD, GPIO_Pin_13);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L7.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L7.16|
000010  f7ffbffe          B.W      GPIO_SetBits
;;;207      }
;;;208    }
;;;209    
                          ENDP

                  |L7.20|
                          DCD      0x40011400

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;169    *******************************************************************************/
;;;170    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;171    {
;;;172      NVIC_InitTypeDef NVIC_InitStructure;
;;;173    
;;;174    #ifdef  VECT_TAB_RAM  
;;;175      /* Set the Vector Table base location at 0x20000000 */ 
;;;176      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;177    #else  /* VECT_TAB_FLASH */
;;;178      /* Set the Vector Table base location at 0x08000000 */
;;;179      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;180    #endif 
;;;181    
;;;182      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
00000c  f44f60e0          MOV      r0,#0x700
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;183    
;;;184      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN_RX0_IRQChannel;
000014  2014              MOVS     r0,#0x14
000016  f88d0000          STRB     r0,[sp,#0]
;;;185      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2000              MOVS     r0,#0
00001c  f88d0001          STRB     r0,[sp,#1]
;;;186      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d0002          STRB     r0,[sp,#2]
;;;187      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2001              MOVS     r0,#1
000026  f88d0003          STRB     r0,[sp,#3]
;;;188      NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;189    }
000030  bd08              POP      {r3,pc}
;;;190    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00
