; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\output\main.o --depend=.\output\main.d --device=DARMSTM --apcs=interwork -O3 -I.\ -Id:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||i.CAN_Interrupt||, CODE, READONLY, ALIGN=2

                  CAN_Interrupt PROC
;;;275    *******************************************************************************/
;;;276    TestStatus CAN_Interrupt(void)
000000  b530              PUSH     {r4,r5,lr}
;;;277    {
000002  b08d              SUB      sp,sp,#0x34
;;;278      CAN_InitTypeDef        CAN_InitStructure;
;;;279      CAN_FilterInitTypeDef  CAN_FilterInitStructure;
;;;280      CanTxMsg TxMessage;
;;;281      u8 i=0;
;;;282    
;;;283      /* CAN register init */
;;;284      CAN_DeInit();
000004  f7fffffe          BL       CAN_DeInit
;;;285      CAN_StructInit(&CAN_InitStructure);
000008  a80a              ADD      r0,sp,#0x28
00000a  f7fffffe          BL       CAN_StructInit
;;;286    
;;;287      /* CAN cell init */
;;;288      CAN_InitStructure.CAN_TTCM=DISABLE;
00000e  2400              MOVS     r4,#0
;;;289      CAN_InitStructure.CAN_ABOM=DISABLE;
;;;290      CAN_InitStructure.CAN_AWUM=DISABLE;
;;;291      CAN_InitStructure.CAN_NART=DISABLE;
;;;292      CAN_InitStructure.CAN_RFLM=DISABLE;
;;;293      CAN_InitStructure.CAN_TXFP=DISABLE;
;;;294      CAN_InitStructure.CAN_Mode=CAN_Mode_LoopBack;
;;;295      CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;
;;;296      CAN_InitStructure.CAN_BS1=CAN_BS1_8tq;
000010  2007              MOVS     r0,#7
000012  f88d0030          STRB     r0,[sp,#0x30]
000016  f88d402c          STRB     r4,[sp,#0x2c]         ;292
00001a  2501              MOVS     r5,#1                 ;294
;;;297      CAN_InitStructure.CAN_BS2=CAN_BS2_7tq;
00001c  2006              MOVS     r0,#6
00001e  f88d402d          STRB     r4,[sp,#0x2d]         ;293
000022  f88d0031          STRB     r0,[sp,#0x31]
000026  f88d502e          STRB     r5,[sp,#0x2e]         ;294
00002a  940a              STR      r4,[sp,#0x28]         ;292
00002c  f88d402f          STRB     r4,[sp,#0x2f]         ;295
;;;298      CAN_InitStructure.CAN_Prescaler=1;
000030  f8ad5032          STRH     r5,[sp,#0x32]
;;;299      CAN_Init(&CAN_InitStructure);
000034  a80a              ADD      r0,sp,#0x28
000036  f7fffffe          BL       CAN_Init
;;;300    
;;;301      /* CAN filter init */
;;;302      CAN_FilterInitStructure.CAN_FilterNumber=1;
00003a  f88d5018          STRB     r5,[sp,#0x18]
;;;303      CAN_FilterInitStructure.CAN_FilterMode=CAN_FilterMode_IdMask;
00003e  f88d4019          STRB     r4,[sp,#0x19]
;;;304      CAN_FilterInitStructure.CAN_FilterScale=CAN_FilterScale_32bit;
;;;305      CAN_FilterInitStructure.CAN_FilterIdHigh=0x0000;
000042  f8ad401c          STRH     r4,[sp,#0x1c]
;;;306      CAN_FilterInitStructure.CAN_FilterIdLow=0x0000;
;;;307      CAN_FilterInitStructure.CAN_FilterMaskIdHigh=0x0000;
000046  f8ad4020          STRH     r4,[sp,#0x20]
;;;308      CAN_FilterInitStructure.CAN_FilterMaskIdLow=0x0000;
;;;309      CAN_FilterInitStructure.CAN_FilterFIFOAssignment=CAN_FIFO0;
00004a  f8ad4024          STRH     r4,[sp,#0x24]
00004e  f88d501a          STRB     r5,[sp,#0x1a]         ;304
000052  f8ad401e          STRH     r4,[sp,#0x1e]         ;306
000056  f8ad4022          STRH     r4,[sp,#0x22]         ;308
;;;310      CAN_FilterInitStructure.CAN_FilterActivation=ENABLE;
00005a  f88d5026          STRB     r5,[sp,#0x26]
;;;311      CAN_FilterInit(&CAN_FilterInitStructure);
00005e  a806              ADD      r0,sp,#0x18
000060  f7fffffe          BL       CAN_FilterInit
;;;312    
;;;313      /* CAN FIFO0 message pending interrupt enable */ 
;;;314      CAN_ITConfig(CAN_IT_FMP0, ENABLE);
000064  2101              MOVS     r1,#1
000066  2002              MOVS     r0,#2
000068  f7fffffe          BL       CAN_ITConfig
;;;315    
;;;316      /* transmit 1 message */
;;;317      TxMessage.StdId=0x12;
00006c  2012              MOVS     r0,#0x12
;;;318      TxMessage.ExtId=0x34;
00006e  9001              STR      r0,[sp,#4]
000070  2034              MOVS     r0,#0x34
;;;319      TxMessage.IDE=CAN_ID_EXT;
000072  9002              STR      r0,[sp,#8]
000074  2004              MOVS     r0,#4
000076  f88d000c          STRB     r0,[sp,#0xc]
;;;320      TxMessage.RTR=CAN_RTR_DATA;
00007a  f88d400d          STRB     r4,[sp,#0xd]
;;;321      TxMessage.DLC=2;
00007e  2002              MOVS     r0,#2
000080  f88d000e          STRB     r0,[sp,#0xe]
;;;322      TxMessage.Data[0]=0xDE;
000084  20de              MOVS     r0,#0xde
000086  f88d000f          STRB     r0,[sp,#0xf]
;;;323      TxMessage.Data[1]=0xCA;
00008a  20ca              MOVS     r0,#0xca
00008c  f88d0010          STRB     r0,[sp,#0x10]
;;;324      CAN_Transmit(&TxMessage);
000090  a801              ADD      r0,sp,#4
000092  f7fffffe          BL       CAN_Transmit
;;;325    
;;;326      /* initialize the value that will be returned */
;;;327      ret=0xFF;
000096  4c07              LDR      r4,|L1.180|
000098  20ff              MOVS     r0,#0xff
00009a  6060              STR      r0,[r4,#4]  ; ret
                  |L1.156|
;;;328           
;;;329      /* receive message with interrupt handling */
;;;330      i=0;
;;;331      while((ret==0xFF)&&(i<0XFFF))
00009c  6860              LDR      r0,[r4,#4]  ; ret
00009e  28ff              CMP      r0,#0xff
0000a0  d0fc              BEQ      |L1.156|
;;;332        i++;
;;;333      if (i==0xFFF)
;;;334      	ret=0;  
;;;335    
;;;336      /* disable interrupt handling */
;;;337      CAN_ITConfig(CAN_IT_FMP0, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2002              MOVS     r0,#2
0000a6  f7fffffe          BL       CAN_ITConfig
;;;338    
;;;339      return (TestStatus)ret;
0000aa  6860              LDR      r0,[r4,#4]  ; ret
;;;340    }
0000ac  b00d              ADD      sp,sp,#0x34
0000ae  b2c0              UXTB     r0,r0                 ;339
0000b0  bd30              POP      {r4,r5,pc}
;;;341    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L1.180|
                          DCD      ||.data||

                          AREA ||i.CAN_Polling||, CODE, READONLY, ALIGN=1

                  CAN_Polling PROC
;;;194    
;;;195    TestStatus CAN_Polling(void)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
000002  b092              SUB      sp,sp,#0x48
;;;197      CAN_InitTypeDef        CAN_InitStructure;
;;;198      CAN_FilterInitTypeDef  CAN_FilterInitStructure;
;;;199      CanTxMsg TxMessage;
;;;200      CanRxMsg RxMessage;
;;;201      u16 i=0;
000004  2400              MOVS     r4,#0
;;;202      u8 TransmitMailbox;
;;;203    
;;;204      /* CAN register init */
;;;205      CAN_DeInit();
000006  f7fffffe          BL       CAN_DeInit
;;;206      CAN_StructInit(&CAN_InitStructure);
00000a  a80f              ADD      r0,sp,#0x3c
00000c  f7fffffe          BL       CAN_StructInit
;;;207    
;;;208      /* CAN cell init */
;;;209      CAN_InitStructure.CAN_TTCM=DISABLE;
;;;210      CAN_InitStructure.CAN_ABOM=DISABLE;
;;;211      CAN_InitStructure.CAN_AWUM=DISABLE;
;;;212      CAN_InitStructure.CAN_NART=DISABLE;
;;;213      CAN_InitStructure.CAN_RFLM=DISABLE;
;;;214      CAN_InitStructure.CAN_TXFP=DISABLE;
;;;215      CAN_InitStructure.CAN_Mode=CAN_Mode_LoopBack;
;;;216      CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;
;;;217      CAN_InitStructure.CAN_BS1=CAN_BS1_8tq;
000010  2007              MOVS     r0,#7
000012  2500              MOVS     r5,#0                 ;209
000014  f88d0044          STRB     r0,[sp,#0x44]
;;;218      CAN_InitStructure.CAN_BS2=CAN_BS2_7tq;
000018  2006              MOVS     r0,#6
00001a  f88d5040          STRB     r5,[sp,#0x40]         ;213
00001e  f88d0045          STRB     r0,[sp,#0x45]
000022  f88d5041          STRB     r5,[sp,#0x41]         ;214
000026  2601              MOVS     r6,#1                 ;215
;;;219      CAN_InitStructure.CAN_Prescaler=5;
000028  2005              MOVS     r0,#5
00002a  f88d6042          STRB     r6,[sp,#0x42]         ;215
00002e  f8ad0046          STRH     r0,[sp,#0x46]
000032  950f              STR      r5,[sp,#0x3c]         ;213
000034  f88d5043          STRB     r5,[sp,#0x43]         ;216
;;;220      CAN_Init(&CAN_InitStructure);
000038  a80f              ADD      r0,sp,#0x3c
00003a  f7fffffe          BL       CAN_Init
;;;221    
;;;222      /* CAN filter init */
;;;223      CAN_FilterInitStructure.CAN_FilterNumber=0;
00003e  f88d502c          STRB     r5,[sp,#0x2c]
;;;224      CAN_FilterInitStructure.CAN_FilterMode=CAN_FilterMode_IdMask;
000042  f88d502d          STRB     r5,[sp,#0x2d]
;;;225      CAN_FilterInitStructure.CAN_FilterScale=CAN_FilterScale_32bit;
;;;226      CAN_FilterInitStructure.CAN_FilterIdHigh=0x0000;
000046  f8ad5030          STRH     r5,[sp,#0x30]
;;;227      CAN_FilterInitStructure.CAN_FilterIdLow=0x0000;
;;;228      CAN_FilterInitStructure.CAN_FilterMaskIdHigh=0x0000;
00004a  f8ad5034          STRH     r5,[sp,#0x34]
;;;229      CAN_FilterInitStructure.CAN_FilterMaskIdLow=0x0000;
;;;230      CAN_FilterInitStructure.CAN_FilterFIFOAssignment=0;
00004e  f8ad5038          STRH     r5,[sp,#0x38]
000052  f88d602e          STRB     r6,[sp,#0x2e]         ;225
000056  f8ad5032          STRH     r5,[sp,#0x32]         ;227
00005a  f8ad5036          STRH     r5,[sp,#0x36]         ;229
;;;231      CAN_FilterInitStructure.CAN_FilterActivation=ENABLE;
00005e  f88d603a          STRB     r6,[sp,#0x3a]
;;;232      CAN_FilterInit(&CAN_FilterInitStructure);
000062  a80b              ADD      r0,sp,#0x2c
000064  f7fffffe          BL       CAN_FilterInit
;;;233    
;;;234      /* transmit */
;;;235      TxMessage.StdId=0x11;
000068  2011              MOVS     r0,#0x11
;;;236      TxMessage.RTR=CAN_RTR_DATA;
00006a  9006              STR      r0,[sp,#0x18]
00006c  f88d5021          STRB     r5,[sp,#0x21]
;;;237      TxMessage.IDE=CAN_ID_STD;
000070  f88d5020          STRB     r5,[sp,#0x20]
;;;238      TxMessage.DLC=2;
000074  2002              MOVS     r0,#2
000076  f88d0022          STRB     r0,[sp,#0x22]
;;;239      TxMessage.Data[0]=0xCA;
00007a  20ca              MOVS     r0,#0xca
00007c  f88d0023          STRB     r0,[sp,#0x23]
;;;240      TxMessage.Data[1]=0xFE;
000080  20fe              MOVS     r0,#0xfe
000082  f88d0024          STRB     r0,[sp,#0x24]
;;;241    
;;;242      TransmitMailbox=CAN_Transmit(&TxMessage);
000086  a806              ADD      r0,sp,#0x18
000088  f7fffffe          BL       CAN_Transmit
00008c  4606              MOV      r6,r0
;;;243      i=0;
;;;244      while((CAN_TransmitStatus(TransmitMailbox)!=CANTXOK)&&(i!=0xFF))
00008e  e001              B        |L2.148|
                  |L2.144|
;;;245        i++;
000090  1c64              ADDS     r4,r4,#1
000092  b2a4              UXTH     r4,r4
                  |L2.148|
000094  4630              MOV      r0,r6                 ;244
000096  f7fffffe          BL       CAN_TransmitStatus
00009a  2801              CMP      r0,#1                 ;244
00009c  d001              BEQ      |L2.162|
00009e  2cff              CMP      r4,#0xff              ;244
0000a0  d1f6              BNE      |L2.144|
                  |L2.162|
;;;246    
;;;247      i=0;
0000a2  2400              MOVS     r4,#0
;;;248      while((CAN_MessagePending(CAN_FIFO0)<1)&&(i!=0xFF))
0000a4  e001              B        |L2.170|
                  |L2.166|
;;;249        i++;
0000a6  1c64              ADDS     r4,r4,#1
0000a8  b2a4              UXTH     r4,r4
                  |L2.170|
0000aa  2000              MOVS     r0,#0                 ;248
0000ac  f7fffffe          BL       CAN_MessagePending
0000b0  b908              CBNZ     r0,|L2.182|
0000b2  2cff              CMP      r4,#0xff              ;248
0000b4  d1f7              BNE      |L2.166|
                  |L2.182|
;;;250    
;;;251      /* receive */
;;;252      RxMessage.StdId=0x00;
;;;253      RxMessage.IDE=CAN_ID_STD;
0000b6  f88d500c          STRB     r5,[sp,#0xc]
;;;254      RxMessage.DLC=0;
0000ba  f88d500e          STRB     r5,[sp,#0xe]
0000be  9501              STR      r5,[sp,#4]            ;253
;;;255      RxMessage.Data[0]=0x00;
0000c0  f88d500f          STRB     r5,[sp,#0xf]
;;;256      RxMessage.Data[1]=0x00;
0000c4  f88d5010          STRB     r5,[sp,#0x10]
;;;257      CAN_Receive(CAN_FIFO0, &RxMessage);
0000c8  a901              ADD      r1,sp,#4
0000ca  2000              MOVS     r0,#0
0000cc  f7fffffe          BL       CAN_Receive
;;;258    
;;;259      if (RxMessage.StdId!=0x11) return FAILED;
0000d0  9801              LDR      r0,[sp,#4]
0000d2  2811              CMP      r0,#0x11
0000d4  d10d              BNE      |L2.242|
;;;260    
;;;261      if (RxMessage.IDE!=CAN_ID_STD) return FAILED;
0000d6  f89d000c          LDRB     r0,[sp,#0xc]
0000da  b950              CBNZ     r0,|L2.242|
;;;262    
;;;263      if (RxMessage.DLC!=2) return FAILED;
0000dc  f89d000e          LDRB     r0,[sp,#0xe]
0000e0  2802              CMP      r0,#2
0000e2  d106              BNE      |L2.242|
;;;264    
;;;265      if ((RxMessage.Data[0]<<8|RxMessage.Data[1])!=0xCAFE) return FAILED;
0000e4  f8bd000f          LDRH     r0,[sp,#0xf]
0000e8  ba40              REV16    r0,r0
0000ea  f5a0414a          SUB      r1,r0,#0xca00
0000ee  39fe              SUBS     r1,r1,#0xfe
0000f0  d002              BEQ      |L2.248|
                  |L2.242|
0000f2  2000              MOVS     r0,#0
                  |L2.244|
;;;266      
;;;267      return PASSED; /* Test Passed */
;;;268    }
0000f4  b012              ADD      sp,sp,#0x48
0000f6  bd70              POP      {r4-r6,pc}
                  |L2.248|
0000f8  2001              MOVS     r0,#1                 ;267
0000fa  e7fb              B        |L2.244|
;;;269    /*******************************************************************************
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;139    *******************************************************************************/
;;;140    void GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;141    {
;;;142      GPIO_InitTypeDef GPIO_InitStructure;
;;;143    
;;;144      /* Configure PC.06, PC.07, PC.08 and PC.09 as Output push-pull */
;;;145      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
000002  f44f7070          MOV      r0,#0x3c0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;146      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000a  2010              MOVS     r0,#0x10
00000c  f88d0003          STRB     r0,[sp,#3]
;;;147      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;148      GPIO_Init(GPIOC, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  480c              LDR      r0,|L3.76|
00001a  f7fffffe          BL       GPIO_Init
;;;149    
;;;150      /* Configure CAN pin: RX */
;;;151      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
00001e  f44f6000          MOV      r0,#0x800
000022  f8ad0000          STRH     r0,[sp,#0]
;;;152      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000026  2048              MOVS     r0,#0x48
;;;153      GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  4c09              LDR      r4,|L3.80|
00002a  f88d0003          STRB     r0,[sp,#3]            ;152
00002e  4669              MOV      r1,sp
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_Init
;;;154      
;;;155      /* Configure CAN pin: TX */
;;;156      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000036  14a0              ASRS     r0,r4,#18
000038  f8ad0000          STRH     r0,[sp,#0]
;;;157      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00003c  2018              MOVS     r0,#0x18
00003e  f88d0003          STRB     r0,[sp,#3]
;;;158      GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       GPIO_Init
;;;159    }
00004a  bd38              POP      {r3-r5,pc}
;;;160    
                          ENDP

                  |L3.76|
                          DCD      0x40011000
                  |L3.80|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;167    *******************************************************************************/
;;;168    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;169    {
;;;170      NVIC_InitTypeDef NVIC_InitStructure;
;;;171    
;;;172    #ifdef  VECT_TAB_RAM  
;;;173      /* Set the Vector Table base location at 0x20000000 */ 
;;;174      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;175    #else  /* VECT_TAB_FLASH  */
;;;176      /* Set the Vector Table base location at 0x08000000 */ 
;;;177      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;178    #endif
;;;179    
;;;180      /* enabling interrupt */
;;;181      NVIC_InitStructure.NVIC_IRQChannel=USB_LP_CAN_RX0_IRQChannel;
00000c  2014              MOVS     r0,#0x14
00000e  f88d0000          STRB     r0,[sp,#0]
;;;182      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000012  2000              MOVS     r0,#0
000014  f88d0001          STRB     r0,[sp,#1]
;;;183      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000018  f88d0002          STRB     r0,[sp,#2]
;;;184      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;185      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;186    }
000028  bd08              POP      {r3,pc}
;;;187    /*******************************************************************************
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;91     *******************************************************************************/
;;;92     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94       /* RCC system reset(for debug purpose) */
;;;95       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;96     
;;;97       /* Enable HSE */
;;;98       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;99     
;;;100      /* Wait till HSE is ready */
;;;101      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4911              LDR      r1,|L5.88|
000014  7048              STRB     r0,[r1,#1]
;;;102    
;;;103      if(HSEStartUpStatus == SUCCESS)
000016  b2c0              UXTB     r0,r0
000018  2801              CMP      r0,#1
00001a  d113              BNE      |L5.68|
;;;104      {
;;;105        /* HCLK = SYSCLK */
;;;106        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       RCC_HCLKConfig
;;;107      
;;;108        /* PCLK2 = HCLK */
;;;109        RCC_PCLK2Config(RCC_HCLK_Div1); 
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       RCC_PCLK2Config
;;;110    
;;;111        /* PCLK1 = HCLK/2 */
;;;112        RCC_PCLK1Config(RCC_HCLK_Div2);
000028  f44f6080          MOV      r0,#0x400
00002c  f7fffffe          BL       RCC_PCLK1Config
;;;113    
;;;114        /* Enable Prefetch Buffer */
;;;115        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000030  2010              MOVS     r0,#0x10
000032  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;116    
;;;117        /* Select HSE as system clock source */
;;;118        RCC_SYSCLKConfig(RCC_SYSCLKSource_HSE);
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       RCC_SYSCLKConfig
                  |L5.60|
;;;119    
;;;120        /* Wait till HSE is used as system clock source */
;;;121        while(RCC_GetSYSCLKSource() != 0x04)
00003c  f7fffffe          BL       RCC_GetSYSCLKSource
000040  2804              CMP      r0,#4
000042  d1fb              BNE      |L5.60|
                  |L5.68|
;;;122        {
;;;123        }
;;;124      }
;;;125      
;;;126      /* GPIOA and GPIOC clock enable */
;;;127      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA  | RCC_APB2Periph_GPIOC, ENABLE);
000044  2101              MOVS     r1,#1
000046  2014              MOVS     r0,#0x14
000048  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;128    
;;;129      /* CAN Periph clock enable */
;;;130      RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  e8bd4010          POP      {r4,lr}
000052  0648              LSLS     r0,r1,#25
000054  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;131    }
;;;132    
                          ENDP

                  |L5.88|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;35     *******************************************************************************/
;;;36     int main(void)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
;;;38     
;;;39     #ifdef DEBUG
;;;40       debug();
;;;41     #endif
;;;42     
;;;43       /* System Clocks Configuration */
;;;44       RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;45     
;;;46       /* NVIC Configuration */
;;;47       NVIC_Configuration();
000006  f7fffffe          BL       NVIC_Configuration
;;;48       
;;;49       /* GPIO ports pins Configuration */
;;;50       GPIO_Configuration();
00000a  f7fffffe          BL       GPIO_Configuration
;;;51       
;;;52       /* CAN transmit at 100Kb/s and receive by polling in loopback mode*/
;;;53       TestRx = CAN_Polling();
00000e  f7fffffe          BL       CAN_Polling
000012  4c0c              LDR      r4,|L6.68|
000014  7020              STRB     r0,[r4,#0]
;;;54     
;;;55       if (TestRx == FAILED)
000016  7820              LDRB     r0,[r4,#0]  ; TestRx
;;;56       {
;;;57         /* Turn on led connected to PC.08 pin (LD3) */
;;;58         GPIO_SetBits(GPIOC, GPIO_Pin_8);
000018  4d0b              LDR      r5,|L6.72|
00001a  b908              CBNZ     r0,|L6.32|
00001c  15a9              ASRS     r1,r5,#22
00001e  e000              B        |L6.34|
                  |L6.32|
;;;59       }
;;;60       else
;;;61       {
;;;62         /* Turn on led connected to PC.06 pin (LD1) */
;;;63         GPIO_SetBits(GPIOC, GPIO_Pin_6);
000020  2140              MOVS     r1,#0x40
                  |L6.34|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       GPIO_SetBits
;;;64       }
;;;65     
;;;66       /* CAN transmit at 500Kb/s and receive by interrupt in loopback mode*/
;;;67       TestRx = CAN_Interrupt();
000028  f7fffffe          BL       CAN_Interrupt
00002c  7020              STRB     r0,[r4,#0]
;;;68     
;;;69       if (TestRx == FAILED)
00002e  7820              LDRB     r0,[r4,#0]  ; TestRx
000030  b910              CBNZ     r0,|L6.56|
;;;70       {
;;;71         /* Turn on led connected to PC.09 pin (LD4) */
;;;72         GPIO_SetBits(GPIOC, GPIO_Pin_9); 
000032  f44f7100          MOV      r1,#0x200
000036  e000              B        |L6.58|
                  |L6.56|
;;;73       }
;;;74       else
;;;75       {
;;;76         /* Turn on led connected to PC.07 pin (LD2) */
;;;77         GPIO_SetBits(GPIOC, GPIO_Pin_7);
000038  2180              MOVS     r1,#0x80
                  |L6.58|
00003a  4628              MOV      r0,r5                 ;72
00003c  f7fffffe          BL       GPIO_SetBits
                  |L6.64|
;;;78       }
;;;79       
;;;80       while(1)
000040  e7fe              B        |L6.64|
;;;81       {
;;;82       }
;;;83     }
;;;84     
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      ||.data||
                  |L6.72|
                          DCD      0x40011000

                          AREA ||.data||, DATA, ALIGN=2

                  TestRx
000000  00                DCB      0x00
                  HSEStartUpStatus
000001  000000            DCB      0x00,0x00,0x00
                  ||ret||
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
