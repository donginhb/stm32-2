; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\main.o --depend=.\output\main.d --device=DARMSTM --apcs=interwork -O3 -I..\common\library -I..\common\usb_library -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Buffercmp PROC
;;;240    *******************************************************************************/
;;;241    TestStatus Buffercmp(uc32* pBuffer, u32* pBuffer1, u16 BufferLength)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243      while(BufferLength--)
;;;244      {
;;;245        if(*pBuffer != *pBuffer1)
;;;246        {
;;;247          return FAILED;
;;;248        }
;;;249        
;;;250        pBuffer++;
;;;251        pBuffer1++;
000002  e007              B        |L1.20|
                  |L1.4|
000004  6803              LDR      r3,[r0,#0]            ;245
000006  680c              LDR      r4,[r1,#0]            ;245
000008  42a3              CMP      r3,r4                 ;245
00000a  d001              BEQ      |L1.16|
00000c  2000              MOVS     r0,#0                 ;247
;;;252      }
;;;253    
;;;254      return PASSED;  
;;;255    }
00000e  bd10              POP      {r4,pc}
                  |L1.16|
000010  1d00              ADDS     r0,r0,#4              ;250
000012  1d09              ADDS     r1,r1,#4              ;251
                  |L1.20|
000014  0013              MOVS     r3,r2                 ;243
000016  f1a20201          SUB      r2,r2,#1              ;243
00001a  b292              UXTH     r2,r2                 ;243
00001c  d1f2              BNE      |L1.4|
00001e  2001              MOVS     r0,#1                 ;254
000020  bd10              POP      {r4,pc}
;;;256    
                          ENDP

                  USART_Configuration PROC
;;;286    *******************************************************************************/
;;;287    void USART_Configuration(void)
000022  b530              PUSH     {r4,r5,lr}
;;;288    {
000024  b087              SUB      sp,sp,#0x1c
;;;289      USART_InitTypeDef USART_InitStructure;
;;;290    USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;291    /* USART1 configuration ------------------------------------------------------*/
;;;292      /* USART1 configured as follow:
;;;293            - BaudRate = 19200 baud  
;;;294            - Word Length = 8 Bits
;;;295            - One Stop Bit
;;;296            - No parity
;;;297            - Hardware flow control disabled (RTS and CTS signals)
;;;298            - Receive and transmit enabled
;;;299            - USART Clock disabled
;;;300            - USART CPOL: Clock is active low
;;;301            - USART CPHA: Data is captured on the middle 
;;;302            - USART LastBit: The clock pulse of the last data bit is not output to 
;;;303                             the SCLK pin
;;;304      */
;;;305    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000026  2400              MOVS     r4,#0
;;;306    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;307    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000028  f44f7000          MOV      r0,#0x200
00002c  f8ad0008          STRH     r0,[sp,#8]
;;;308    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;309    /* Configure the USART1 synchronous paramters */
;;;310    USART_ClockInit(USART1, &USART_ClockInitStructure);
000030  4d87              LDR      r5,|L1.592|
000032  f8ad4004          STRH     r4,[sp,#4]            ;305
000036  f8ad4006          STRH     r4,[sp,#6]            ;306
00003a  f8ad400a          STRH     r4,[sp,#0xa]          ;308
00003e  a901              ADD      r1,sp,#4
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       USART_ClockInit
;;;311    
;;;312    USART_InitStructure.USART_BaudRate = 19200;
000046  f44f4096          MOV      r0,#0x4b00
;;;313    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004a  9003              STR      r0,[sp,#0xc]
;;;314    USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;315    USART_InitStructure.USART_Parity = USART_Parity_No ;
00004c  f8ad4014          STRH     r4,[sp,#0x14]
;;;316    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;317    
;;;318    
;;;319    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000050  200c              MOVS     r0,#0xc
000052  f8ad4010          STRH     r4,[sp,#0x10]         ;313
000056  f8ad0016          STRH     r0,[sp,#0x16]
00005a  f8ad4012          STRH     r4,[sp,#0x12]         ;314
00005e  f8ad4018          STRH     r4,[sp,#0x18]         ;316
;;;320    /* Configure USART1 basic and asynchronous paramters */
;;;321    USART_Init(USART1, &USART_InitStructure);
000062  a903              ADD      r1,sp,#0xc
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       USART_Init
;;;322        
;;;323      /* Enable USART1 */
;;;324      USART_Cmd(USART1, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       USART_Cmd
;;;325    }
000072  b007              ADD      sp,sp,#0x1c
000074  bd30              POP      {r4,r5,pc}
;;;326    
                          ENDP

                  GPIO_Configuration PROC
;;;188    *******************************************************************************/
;;;189    void GPIO_Configuration(void)
000076  b538              PUSH     {r3-r5,lr}
;;;190    {
;;;191      GPIO_InitTypeDef GPIO_InitStructure;
;;;192        
;;;193      /* Configure USART1 Tx (PA.09) as alternate function push-pull */	
;;;194      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000078  2003              MOVS     r0,#3
00007a  f88d0002          STRB     r0,[sp,#2]
;;;195      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00007e  f44f7000          MOV      r0,#0x200
000082  f8ad0000          STRH     r0,[sp,#0]
;;;196      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000086  2018              MOVS     r0,#0x18
;;;197      GPIO_Init(GPIOA, &GPIO_InitStructure);
000088  4c72              LDR      r4,|L1.596|
00008a  f88d0003          STRB     r0,[sp,#3]            ;196
00008e  4669              MOV      r1,sp
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       GPIO_Init
;;;198        
;;;199      /* Configure USART1 Rx (PA.10) as input floating */
;;;200      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000096  1520              ASRS     r0,r4,#20
000098  f8ad0000          STRH     r0,[sp,#0]
;;;201      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00009c  2004              MOVS     r0,#4
00009e  f88d0003          STRB     r0,[sp,#3]
;;;202      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000a2  4669              MOV      r1,sp
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       GPIO_Init
;;;203    }
0000aa  bd38              POP      {r3-r5,pc}
;;;204    
                          ENDP

                  NVIC_Configuration PROC
;;;211    *******************************************************************************/
;;;212    void NVIC_Configuration(void)
0000ac  b508              PUSH     {r3,lr}
;;;213    {
;;;214      NVIC_InitTypeDef NVIC_InitStructure;
;;;215      
;;;216    #ifdef  VECT_TAB_RAM  
;;;217      /* Set the Vector Table base location at 0x20000000 */ 
;;;218      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;219    #else  /* VECT_TAB_FLASH  */
;;;220      /* Set the Vector Table base location at 0x08000000 */ 
;;;221      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
0000ae  2100              MOVS     r1,#0
0000b0  f04f6000          MOV      r0,#0x8000000
0000b4  f7fffffe          BL       NVIC_SetVectorTable
;;;222    #endif
;;;223    
;;;224      /* Enable DMA channel6 IRQ Channel */
;;;225      NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel6_IRQChannel;
0000b8  2010              MOVS     r0,#0x10
0000ba  f88d0000          STRB     r0,[sp,#0]
;;;226      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0000be  2000              MOVS     r0,#0
0000c0  f88d0001          STRB     r0,[sp,#1]
;;;227      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000c4  f88d0002          STRB     r0,[sp,#2]
;;;228      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000c8  2001              MOVS     r0,#1
0000ca  f88d0003          STRB     r0,[sp,#3]
;;;229      NVIC_Init(&NVIC_InitStructure);
0000ce  4668              MOV      r0,sp
0000d0  f7fffffe          BL       NVIC_Init
;;;230    }
0000d4  bd08              POP      {r3,pc}
;;;231    
                          ENDP

                  RCC_Configuration PROC
;;;141    *******************************************************************************/
;;;142    void RCC_Configuration(void)
0000d6  b510              PUSH     {r4,lr}
;;;143    {
;;;144      /* RCC system reset(for debug purpose) */
;;;145      RCC_DeInit();
0000d8  f7fffffe          BL       RCC_DeInit
;;;146       /* Enable HSE */
;;;147      RCC_HSEConfig(RCC_HSE_ON);
0000dc  f44f3480          MOV      r4,#0x10000
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       RCC_HSEConfig
;;;148       /* Wait till HSE is ready */
;;;149      HSEStartUpStatus = RCC_WaitForHSEStartUp();
0000e6  f7fffffe          BL       RCC_WaitForHSEStartUp
0000ea  495b              LDR      r1,|L1.600|
0000ec  7048              STRB     r0,[r1,#1]
;;;150       if(HSEStartUpStatus == SUCCESS)
0000ee  b2c0              UXTB     r0,r0
0000f0  2801              CMP      r0,#1
0000f2  d123              BNE      |L1.316|
;;;151      {
;;;152        /* HCLK = SYSCLK */
;;;153        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
0000f4  2000              MOVS     r0,#0
0000f6  f7fffffe          BL       RCC_HCLKConfig
;;;154          /* PCLK2 = HCLK */
;;;155        RCC_PCLK2Config(RCC_HCLK_Div1); 
0000fa  2000              MOVS     r0,#0
0000fc  f7fffffe          BL       RCC_PCLK2Config
;;;156          /* PCLK1 = HCLK/2 */
;;;157        RCC_PCLK1Config(RCC_HCLK_Div2);
000100  11a0              ASRS     r0,r4,#6
000102  f7fffffe          BL       RCC_PCLK1Config
;;;158          /* Flash 2 wait state */
;;;159        FLASH_SetLatency(FLASH_Latency_2);
000106  2002              MOVS     r0,#2
000108  f7fffffe          BL       FLASH_SetLatency
;;;160        /* Enable Prefetch Buffer */
;;;161        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00010c  2010              MOVS     r0,#0x10
00010e  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;162           /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;163        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000112  f44f11e0          MOV      r1,#0x1c0000
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       RCC_PLLConfig
;;;164           /* Enable PLL */ 
;;;165        RCC_PLLCmd(ENABLE);
00011c  2001              MOVS     r0,#1
00011e  f7fffffe          BL       RCC_PLLCmd
                  |L1.290|
;;;166    	    /* Wait till PLL is ready */
;;;167        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000122  2039              MOVS     r0,#0x39
000124  f7fffffe          BL       RCC_GetFlagStatus
000128  2800              CMP      r0,#0
00012a  d0fa              BEQ      |L1.290|
;;;168        {
;;;169        }
;;;170           /* Select PLL as system clock source */
;;;171        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00012c  2002              MOVS     r0,#2
00012e  f7fffffe          BL       RCC_SYSCLKConfig
;;;172           /* Wait till PLL is used as system clock source */
;;;173        while(RCC_GetSYSCLKSource() != 0x08)
000132  bf00              NOP      
                  |L1.308|
000134  f7fffffe          BL       RCC_GetSYSCLKSource
000138  2808              CMP      r0,#8
00013a  d1fb              BNE      |L1.308|
                  |L1.316|
;;;174        {
;;;175        }
;;;176      }
;;;177         /* Enable DMA,USART1 and GPIOA clock */
;;;178       RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);
00013c  2101              MOVS     r1,#1
00013e  f2440004          MOV      r0,#0x4004
000142  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;179       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000146  2101              MOVS     r1,#1
000148  e8bd4010          POP      {r4,lr}
00014c  4608              MOV      r0,r1
00014e  f7ffbffe          B.W      RCC_AHBPeriphClockCmd
;;;180    }
;;;181    
                          ENDP

                  main PROC
;;;60     *******************************************************************************/
;;;61     int main(void)
000152  e92d41f0          PUSH     {r4-r8,lr}
;;;62     {
;;;63       int count;
;;;64     #ifdef DEBUG
;;;65       debug();
;;;66     #endif
;;;67     
;;;68       /* System Clocks Configuration */
;;;69       RCC_Configuration();
000156  f7fffffe          BL       RCC_Configuration
;;;70            
;;;71       /* NVIC configuration */
;;;72       NVIC_Configuration();
00015a  f7fffffe          BL       NVIC_Configuration
;;;73     
;;;74         /* Configure the GPIOs */
;;;75       GPIO_Configuration();
00015e  f7fffffe          BL       GPIO_Configuration
;;;76     
;;;77         /* Configure the USART1 */
;;;78       USART_Configuration();
000162  f7fffffe          BL       USART_Configuration
;;;79     
;;;80       printf("\n boot success!\n");
000166  a03d              ADR      r0,|L1.604|
000168  f7fffffe          BL       __2printf
;;;81     
;;;82       /* DMA channel6 configuration */
;;;83       DMA_DeInit(DMA1_Channel6);
00016c  4c40              LDR      r4,|L1.624|
00016e  4620              MOV      r0,r4
000170  f7fffffe          BL       DMA_DeInit
;;;84       DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)SRC_Const_Buffer;
000174  4840              LDR      r0,|L1.632|
000176  4f3f              LDR      r7,|L1.628|
;;;85       DMA_InitStructure.DMA_MemoryBaseAddr = (u32)DST_Buffer;
000178  f100062c          ADD      r6,r0,#0x2c
;;;86       DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
;;;87       DMA_InitStructure.DMA_BufferSize = BufferSize;
;;;88       DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;
00017c  e9c07600          STRD     r7,r6,[r0,#0]
000180  2100              MOVS     r1,#0                 ;86
000182  2220              MOVS     r2,#0x20              ;87
000184  e9c01202          STRD     r1,r2,[r0,#8]
000188  2240              MOVS     r2,#0x40
;;;89       DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00018a  6102              STR      r2,[r0,#0x10]  ; DMA_InitStructure
00018c  2280              MOVS     r2,#0x80
;;;90       DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
00018e  6142              STR      r2,[r0,#0x14]  ; DMA_InitStructure
000190  0092              LSLS     r2,r2,#2
;;;91       DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
000192  6182              STR      r2,[r0,#0x18]  ; DMA_InitStructure
000194  0092              LSLS     r2,r2,#2
;;;92       DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
;;;93       DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000196  e9c02107          STRD     r2,r1,[r0,#0x1c]
00019a  0091              LSLS     r1,r2,#2
;;;94       DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;
00019c  6241              STR      r1,[r0,#0x24]  ; DMA_InitStructure
00019e  0049              LSLS     r1,r1,#1
;;;95       DMA_Init(DMA1_Channel6, &DMA_InitStructure);
0001a0  6281              STR      r1,[r0,#0x28]  ; DMA_InitStructure
0001a2  4601              MOV      r1,r0
0001a4  4620              MOV      r0,r4
0001a6  f7fffffe          BL       DMA_Init
;;;96     
;;;97       /* Enable DMA Channel6 Transfer Complete interrupt */
;;;98       DMA_ITConfig(DMA1_Channel6, DMA_IT_TC, ENABLE);
0001aa  2201              MOVS     r2,#1
0001ac  2102              MOVS     r1,#2
0001ae  4620              MOV      r0,r4
0001b0  f7fffffe          BL       DMA_ITConfig
;;;99     
;;;100      /* Get Current Data Counter value before transfer begins */
;;;101      CurrDataCounter= DMA_GetCurrDataCounter(DMA1_Channel6);
0001b4  4620              MOV      r0,r4
0001b6  f7fffffe          BL       DMA_GetCurrDataCounter
0001ba  4d27              LDR      r5,|L1.600|
0001bc  8068              STRH     r0,[r5,#2]
;;;102    
;;;103      /* Enable DMA Channel6 transfer */
;;;104      DMA_Cmd(DMA1_Channel6, ENABLE);
0001be  2101              MOVS     r1,#1
0001c0  4620              MOV      r0,r4
0001c2  f7fffffe          BL       DMA_Cmd
                  |L1.454|
;;;105      /* Wait for completing transfer */
;;;106      while( CurrDataCounter!=0) ;
0001c6  8868              LDRH     r0,[r5,#2]  ; CurrDataCounter
0001c8  2800              CMP      r0,#0
0001ca  d1fc              BNE      |L1.454|
;;;107    
;;;108      printf(" Complete transfer!\n");
0001cc  a02b              ADR      r0,|L1.636|
0001ce  f7fffffe          BL       __2printf
;;;109      printf("\n The contents of the SRC_Const_Buffer are:");
0001d2  a030              ADR      r0,|L1.660|
0001d4  f7fffffe          BL       __2printf
;;;110      for(count=0;count<BufferSize;count++)
0001d8  2400              MOVS     r4,#0
                  |L1.474|
;;;111          {
;;;112    		if(count%4==0) printf("\n");
0001da  07a0              LSLS     r0,r4,#30
0001dc  d102              BNE      |L1.484|
0001de  a038              ADR      r0,|L1.704|
0001e0  f7fffffe          BL       __2printf
                  |L1.484|
;;;113            printf("0x%-9x",SRC_Const_Buffer[count]);
0001e4  f8571024          LDR      r1,[r7,r4,LSL #2]
0001e8  a036              ADR      r0,|L1.708|
0001ea  f7fffffe          BL       __2printf
0001ee  1c64              ADDS     r4,r4,#1              ;110
0001f0  2c20              CMP      r4,#0x20              ;110
0001f2  dbf2              BLT      |L1.474|
;;;114    	   }
;;;115      printf("\n The contents of the DST_Buffer are:");
0001f4  a035              ADR      r0,|L1.716|
0001f6  f7fffffe          BL       __2printf
;;;116      for(count=0;count<BufferSize;count++)
0001fa  2400              MOVS     r4,#0
                  |L1.508|
;;;117          {
;;;118    		if(count%4==0) printf("\n");
0001fc  07a0              LSLS     r0,r4,#30
0001fe  d102              BNE      |L1.518|
000200  a02f              ADR      r0,|L1.704|
000202  f7fffffe          BL       __2printf
                  |L1.518|
;;;119            printf("0x%-9x",DST_Buffer[count]);
000206  f8561024          LDR      r1,[r6,r4,LSL #2]
00020a  a02e              ADR      r0,|L1.708|
00020c  f7fffffe          BL       __2printf
000210  1c64              ADDS     r4,r4,#1              ;116
000212  2c20              CMP      r4,#0x20              ;116
000214  dbf2              BLT      |L1.508|
;;;120    	   }
;;;121    
;;;122      /* Check if the transmitted and received data are equal */
;;;123      TransferStatus = Buffercmp(SRC_Const_Buffer, DST_Buffer, BufferSize);
000216  4918              LDR      r1,|L1.632|
000218  2220              MOVS     r2,#0x20
00021a  312c              ADDS     r1,r1,#0x2c
00021c  4815              LDR      r0,|L1.628|
00021e  f7fffffe          BL       Buffercmp
000222  7028              STRB     r0,[r5,#0]
;;;124      /* TransferStatus = PASSED, if the transmitted and received data 
;;;125         are the same */
;;;126      /* TransferStatus = FAILED, if the transmitted and received data 
;;;127         are different */
;;;128     if(TransferStatus== FAILED) 
000224  7828              LDRB     r0,[r5,#0]  ; TransferStatus
000226  b908              CBNZ     r0,|L1.556|
;;;129                  printf("\n DMA test fail!\n");
000228  a032              ADR      r0,|L1.756|
00022a  e000              B        |L1.558|
                  |L1.556|
;;;130     else
;;;131                  printf("\n DMA test success!\n");    
00022c  a036              ADR      r0,|L1.776|
                  |L1.558|
00022e  f7fffffe          BL       __2printf
                  |L1.562|
;;;132      while(1) ;
000232  e7fe              B        |L1.562|
;;;133    }
;;;134    
                          ENDP

                  fputc PROC
;;;334    
;;;335    int fputc(int ch, FILE *f)
000234  b510              PUSH     {r4,lr}
;;;336    {
000236  4604              MOV      r4,r0
;;;337    #ifdef DBG_ITM
;;;338    /* 将Printf内容发往ITM激励寄存器端口  */
;;;339      if (DEMCR & TRCENA) {
;;;340        while (ITM_Port32(0) == 0);
;;;341        ITM_Port8(0) = ch;
;;;342      }
;;;343    #else  
;;;344    /* 将Printf内容发往串口 */
;;;345      USART_SendData(USART1, (unsigned char) ch);
000238  b2c1              UXTB     r1,r0
00023a  4805              LDR      r0,|L1.592|
00023c  f7fffffe          BL       USART_SendData
;;;346      while (!(USART1->SR & USART_FLAG_TXE));
000240  4837              LDR      r0,|L1.800|
000242  bf00              NOP      
                  |L1.580|
000244  f8b01800          LDRH     r1,[r0,#0x800]
000248  0609              LSLS     r1,r1,#24
00024a  d5fb              BPL      |L1.580|
;;;347    #endif  
;;;348      return (ch);
00024c  4620              MOV      r0,r4
;;;349    }
00024e  bd10              POP      {r4,pc}
;;;350    
                          ENDP

                  |L1.592|
                          DCD      0x40013800
                  |L1.596|
                          DCD      0x40010800
                  |L1.600|
                          DCD      ||.data||
                  |L1.604|
00025c  0a20626f6f742073756363657373210a00        DCB      "\n boot success!\n",0
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L1.624|
                          DCD      0x4002006c
                  |L1.628|
                          DCD      ||.constdata||
                  |L1.632|
                          DCD      ||.bss||
                  |L1.636|
00027c  20436f6d706c657465207472616e73666572210a00        DCB      " Complete transfer!\n",0
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0
                  |L1.660|
000294  0a2054686520636f6e74656e7473206f6620746865205352435f436f6e73745f427566666572206172653a00        DCB      "\n The contents of the SRC_Const_Buffer are:",0
                  |L1.704|
0002c0  0a00              DCB      "\n",0
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L1.708|
0002c4  3078252d397800        DCB      "0x%-9x",0
0002cb  00                DCB      0
                  |L1.716|
0002cc  0a2054686520636f6e74656e7473206f6620746865204453545f427566666572206172653a00        DCB      "\n The contents of the DST_Buffer are:",0
0002f2  00                DCB      0
0002f3  00                DCB      0
                  |L1.756|
0002f4  0a20444d412074657374206661696c210a00        DCB      "\n DMA test fail!\n",0
000306  00                DCB      0
000307  00                DCB      0
                  |L1.776|
000308  0a20444d4120746573742073756363657373210a00        DCB      "\n DMA test success!\n",0
00031d  00                DCB      0
00031e  00                DCB      0
00031f  00                DCB      0
                  |L1.800|
                          DCD      0x40013000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMA_InitStructure
                          %        44
                  DST_Buffer
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  SRC_Const_Buffer
                          DCD      0x01020304
                          DCD      0x05060708
                          DCD      0x090a0b0c
                          DCD      0x0d0e0f10
                          DCD      0x11121314
                          DCD      0x15161718
                          DCD      0x191a1b1c
                          DCD      0x1d1e1f20
                          DCD      0x21222324
                          DCD      0x25262728
                          DCD      0x292a2b2c
                          DCD      0x2d2e2f30
                          DCD      0x31323334
                          DCD      0x35363738
                          DCD      0x393a3b3c
                          DCD      0x3d3e3f40
                          DCD      0x41424344
                          DCD      0x45464748
                          DCD      0x494a4b4c
                          DCD      0x4d4e4f50
                          DCD      0x51525354
                          DCD      0x55565758
                          DCD      0x595a5b5c
                          DCD      0x5d5e5f60
                          DCD      0x61626364
                          DCD      0x65666768
                          DCD      0x696a6b6c
                          DCD      0x6d6e6f70
                          DCD      0x71727374
                          DCD      0x75767778
                          DCD      0x797a7b7c
                          DCD      0x7d7e7f80

                          AREA ||.data||, DATA, ALIGN=1

                  TransferStatus
000000  00                DCB      0x00
                  HSEStartUpStatus
000001  00                DCB      0x00
                  CurrDataCounter
000002  0000              DCW      0x0000

                  __ARM_use_no_argv EQU 0
